#![feature(prelude_import)]
//! PoolSync: A library for synchronizing and managing various types of liquidity pools across different blockchains
//!
//! This library provides functionality to interact with and synchronize data from
//! various decentralized exchange protocols across multiple blockchain networks.
//! It supports different pool types like Uniswap V2, Uniswap V3, and SushiSwap,
//! and can work with multiple blockchain networks such as Ethereum and Base.
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
pub use chain::Chain;
pub use pool_sync::PoolSync;
pub use pools::{Pool, PoolInfo, PoolType};
mod builder {
    //! PoolSync Builder Implementation
    //!
    //! This module provides a builder pattern for constructing a PoolSync instance,
    //! allowing for flexible configuration of pool types and chains to be synced.
    use aerodome::AerodomeFetcher;
    use pancake_swap::{PancakeSwapV2Fetcher, PancakeSwapV3Fetcher};
    use sushiswap::{SushiSwapV2Fetcher, SushiSwapV3Fetcher};
    use uniswap::{UniswapV2Fetcher, UniswapV3Fetcher};
    use crate::errors::*;
    use crate::pools::*;
    use crate::{Chain, PoolSync, PoolType};
    use std::collections::HashMap;
    use std::sync::Arc;
    /// Builder for constructing a PoolSync instance
    pub struct PoolSyncBuilder {
        /// Mapping from the pool type to the implementation of its fetcher
        fetchers: HashMap<PoolType, Arc<dyn PoolFetcher>>,
        /// The chain to be synced on
        chain: Option<Chain>,
        /// Rate limit on the rpc endpoint
        rate_limit: Option<usize>,
    }
    #[automatically_derived]
    impl ::core::default::Default for PoolSyncBuilder {
        #[inline]
        fn default() -> PoolSyncBuilder {
            PoolSyncBuilder {
                fetchers: ::core::default::Default::default(),
                chain: ::core::default::Default::default(),
                rate_limit: ::core::default::Default::default(),
            }
        }
    }
    impl PoolSyncBuilder {
        /// Adds a new pool type to be synced
        /// The builder instance for method chaining
        pub fn add_pool(mut self, pool_type: PoolType) -> Self {
            match pool_type {
                PoolType::UniswapV2 => {
                    self.fetchers
                        .insert(PoolType::UniswapV2, Arc::new(UniswapV2Fetcher));
                }
                PoolType::UniswapV3 => {
                    self.fetchers
                        .insert(PoolType::UniswapV3, Arc::new(UniswapV3Fetcher));
                }
                PoolType::SushiSwapV2 => {
                    self.fetchers
                        .insert(PoolType::SushiSwapV2, Arc::new(SushiSwapV2Fetcher));
                }
                PoolType::SushiSwapV3 => {
                    self.fetchers
                        .insert(PoolType::SushiSwapV3, Arc::new(SushiSwapV3Fetcher));
                }
                PoolType::PancakeSwapV2 => {
                    self.fetchers
                        .insert(PoolType::PancakeSwapV2, Arc::new(PancakeSwapV2Fetcher));
                }
                PoolType::PancakeSwapV3 => {
                    self.fetchers
                        .insert(PoolType::PancakeSwapV3, Arc::new(PancakeSwapV3Fetcher));
                }
                PoolType::Aerodome => {
                    self.fetchers.insert(PoolType::Aerodome, Arc::new(AerodomeFetcher));
                }
            }
            self
        }
        /// Add multiple pools to be synced
        pub fn add_pools(mut self, pools: &[PoolType]) -> Self {
            for pool in pools.into_iter() {
                self = self.add_pool(*pool);
            }
            self
        }
        /// Sets the chain to sync on
        /// The builder instance for method chaining
        pub fn chain(mut self, chain: Chain) -> Self {
            self.chain = Some(chain);
            self
        }
        /// Set the rate limit of the rpc
        /// The builder instance for method chaining
        pub fn rate_limit(mut self, rate_limit: usize) -> Self {
            self.rate_limit = Some(rate_limit);
            self
        }
        /// Consumes the builder and produces a constructed PoolSync
        pub fn build(self) -> Result<PoolSync, PoolSyncError> {
            let chain = self.chain.ok_or(PoolSyncError::ChainNotSet)?;
            for pool_type in self.fetchers.keys() {
                if !chain.supported(pool_type) {
                    return Err(PoolSyncError::UnsupportedPoolType);
                }
            }
            let rate_limit = self.rate_limit.unwrap_or(10000) as u64;
            Ok(PoolSync {
                fetchers: self.fetchers,
                rate_limit,
                chain,
            })
        }
    }
}
mod cache {
    //! Pool Synchronization Cache Implementation
    //!
    //! This module provides functionality for caching pool synchronization data,
    //! including structures and functions for reading from and writing to cache files.
    use crate::chain::Chain;
    use crate::pools::{Pool, PoolType};
    use serde::{Deserialize, Serialize};
    use std::fs;
    use std::path::Path;
    /// Cache for a protocol, facilitates easier syncing
    pub struct PoolCache {
        /// The last block number that was synced
        pub last_synced_block: u64,
        /// The type of pool this cache is for
        pub pool_type: PoolType,
        /// The list of pools that have been synced
        pub pools: Vec<Pool>,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for PoolCache {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "PoolCache",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "last_synced_block",
                    &self.last_synced_block,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "pool_type",
                    &self.pool_type,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "pools",
                    &self.pools,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for PoolCache {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "last_synced_block" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            "pool_type" => _serde::__private::Ok(__Field::__field1),
                            "pools" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"last_synced_block" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            b"pool_type" => _serde::__private::Ok(__Field::__field1),
                            b"pools" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<PoolCache>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = PoolCache;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct PoolCache",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct PoolCache with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            PoolType,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct PoolCache with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            Vec<Pool>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct PoolCache with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(PoolCache {
                            last_synced_block: __field0,
                            pool_type: __field1,
                            pools: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<PoolType> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<Vec<Pool>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "last_synced_block",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "pool_type",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<PoolType>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("pools"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Vec<Pool>>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("last_synced_block")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("pool_type")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("pools")?
                            }
                        };
                        _serde::__private::Ok(PoolCache {
                            last_synced_block: __field0,
                            pool_type: __field1,
                            pools: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "last_synced_block",
                    "pool_type",
                    "pools",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "PoolCache",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<PoolCache>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    /// Reads the cache file for the specified pool type and chain
    pub fn read_cache_file(pool_type: &PoolType, chain: Chain) -> PoolCache {
        let pool_cache_file = {
            let res = ::alloc::fmt::format(
                format_args!("cache/{0}_{1}_cache.json", chain, pool_type),
            );
            res
        };
        if Path::new(&pool_cache_file).exists() {
            let file_content = fs::read_to_string(pool_cache_file).unwrap();
            let pool_cache: PoolCache = serde_json::from_str(&file_content).unwrap();
            pool_cache
        } else {
            PoolCache {
                last_synced_block: 10000000,
                pool_type: *pool_type,
                pools: Vec::new(),
            }
        }
    }
    /// Writes the provided PoolCache to a cache file
    pub fn write_cache_file(pool_cache: &PoolCache, chain: Chain) {
        let pool_cache_file = {
            let res = ::alloc::fmt::format(
                format_args!("cache/{0}_{1}_cache.json", chain, pool_cache.pool_type),
            );
            res
        };
        let json = serde_json::to_string(&pool_cache).unwrap();
        let _ = fs::write(pool_cache_file, json);
    }
}
mod chain {
    //! Chain Support and Pool Type Management
    //!
    //! This module defines the supported blockchain networks (Chains) and manages
    //! the mapping of supported pool types for each chain.
    use crate::PoolType;
    use once_cell::sync::Lazy;
    use std::collections::{HashMap, HashSet};
    use std::fmt;
    /// Enum representing supported blockchain networks
    pub enum Chain {
        /// Ethereum mainnet
        Ethereum,
        /// Base chain
        Base,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Chain {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    Chain::Ethereum => "Ethereum",
                    Chain::Base => "Base",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Chain {}
    #[automatically_derived]
    impl ::core::clone::Clone for Chain {
        #[inline]
        fn clone(&self) -> Chain {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Chain {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Chain {
        #[inline]
        fn eq(&self, other: &Chain) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for Chain {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Chain {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Chain,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            ::core::cmp::PartialOrd::partial_cmp(&__self_discr, &__arg1_discr)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Chain {
        #[inline]
        fn cmp(&self, other: &Chain) -> ::core::cmp::Ordering {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Chain {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_discr, state)
        }
    }
    /// Static mapping of supported pool types for each chain
    ///
    /// This mapping is important because not all protocols are deployed on all chains,
    /// and the contract addresses for the same protocol may differ across chains.
    static CHAIN_POOLS: Lazy<HashMap<Chain, HashSet<PoolType>>> = Lazy::new(|| {
        let mut m = HashMap::new();
        m.insert(
            Chain::Ethereum,
            [
                PoolType::UniswapV2,
                PoolType::UniswapV3,
                PoolType::SushiSwapV2,
                PoolType::SushiSwapV3,
                PoolType::PancakeSwapV2,
                PoolType::PancakeSwapV3,
            ]
                .iter()
                .cloned()
                .collect(),
        );
        m.insert(
            Chain::Base,
            [
                PoolType::UniswapV2,
                PoolType::UniswapV3,
                PoolType::SushiSwapV2,
                PoolType::SushiSwapV3,
                PoolType::PancakeSwapV2,
                PoolType::PancakeSwapV3,
                PoolType::Aerodome,
            ]
                .iter()
                .cloned()
                .collect(),
        );
        m
    });
    impl Chain {
        /// Determines if a given pool type is supported on this chain
        pub fn supported(&self, pool_type: &PoolType) -> bool {
            CHAIN_POOLS.get(self).map(|pools| pools.contains(pool_type)).unwrap_or(false)
        }
    }
    impl fmt::Display for Chain {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.write_fmt(format_args!("{0:?}", self))
        }
    }
}
mod errors {
    //! PoolSync Error Types
    //!
    //! This module defines the custom error types used throughout the PoolSync operations.
    //! It leverages the `thiserror` crate for deriving the `Error` trait and providing
    //! formatted error messages.
    use thiserror::Error;
    /// Enumerates the various error types that can occur during PoolSync operations
    pub enum PoolSyncError {
        /// Represents errors that occur when interacting with the blockchain provider
        #[error("Provider error: {0}")]
        ProviderError(String),
        /// Represents I/O errors that may occur during file operations
        #[error("IO error: {0}")]
        IoError(#[from] std::io::Error),
        /// Represents errors that occur during JSON serialization or deserialization
        #[error("JSON error: {0}")]
        JsonError(#[from] serde_json::Error),
        /// Indicates that an unsupported pool type was encountered
        #[error("Pool not supported")]
        UnsupportedPoolType,
        /// Indicates that the chain was not set when it was required
        #[error("Chain not set")]
        ChainNotSet,
    }
    #[allow(unused_qualifications)]
    impl std::error::Error for PoolSyncError {
        fn source(&self) -> ::core::option::Option<&(dyn std::error::Error + 'static)> {
            use thiserror::__private::AsDynError as _;
            #[allow(deprecated)]
            match self {
                PoolSyncError::ProviderError { .. } => ::core::option::Option::None,
                PoolSyncError::IoError { 0: source, .. } => {
                    ::core::option::Option::Some(source.as_dyn_error())
                }
                PoolSyncError::JsonError { 0: source, .. } => {
                    ::core::option::Option::Some(source.as_dyn_error())
                }
                PoolSyncError::UnsupportedPoolType { .. } => ::core::option::Option::None,
                PoolSyncError::ChainNotSet { .. } => ::core::option::Option::None,
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::core::fmt::Display for PoolSyncError {
        fn fmt(&self, __formatter: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            use thiserror::__private::AsDisplay as _;
            #[allow(unused_variables, deprecated, clippy::used_underscore_binding)]
            match self {
                PoolSyncError::ProviderError(_0) => {
                    __formatter
                        .write_fmt(format_args!("Provider error: {0}", _0.as_display()))
                }
                PoolSyncError::IoError(_0) => {
                    __formatter.write_fmt(format_args!("IO error: {0}", _0.as_display()))
                }
                PoolSyncError::JsonError(_0) => {
                    __formatter
                        .write_fmt(format_args!("JSON error: {0}", _0.as_display()))
                }
                PoolSyncError::UnsupportedPoolType {} => {
                    __formatter.write_str("Pool not supported")
                }
                PoolSyncError::ChainNotSet {} => __formatter.write_str("Chain not set"),
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::core::convert::From<std::io::Error> for PoolSyncError {
        #[allow(deprecated)]
        fn from(source: std::io::Error) -> Self {
            PoolSyncError::IoError {
                0: source,
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::core::convert::From<serde_json::Error> for PoolSyncError {
        #[allow(deprecated)]
        fn from(source: serde_json::Error) -> Self {
            PoolSyncError::JsonError {
                0: source,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PoolSyncError {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                PoolSyncError::ProviderError(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "ProviderError",
                        &__self_0,
                    )
                }
                PoolSyncError::IoError(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "IoError",
                        &__self_0,
                    )
                }
                PoolSyncError::JsonError(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "JsonError",
                        &__self_0,
                    )
                }
                PoolSyncError::UnsupportedPoolType => {
                    ::core::fmt::Formatter::write_str(f, "UnsupportedPoolType")
                }
                PoolSyncError::ChainNotSet => {
                    ::core::fmt::Formatter::write_str(f, "ChainNotSet")
                }
            }
        }
    }
}
mod rpc {
    use alloy::network::Network;
    use alloy::primitives::Address;
    use alloy::providers::Provider;
    use alloy::rpc::types::Filter;
    use alloy::transports::Transport;
    use futures::future::join_all;
    use futures::stream;
    use futures::stream::StreamExt;
    use rand::Rng;
    use ratelimit::Ratelimiter;
    use std::sync::Arc;
    use std::time::Duration;
    use tokio::sync::Semaphore;
    use tokio::task::JoinHandle;
    use crate::pools::PoolFetcher;
    use crate::util::create_progress_bar;
    use crate::Chain;
    use crate::Pool;
    use crate::PoolType;
    /// The number of blocks to query in one call to get_logs
    const STEP_SIZE: u64 = 10_000;
    const MAX_RETRIES: u32 = 5;
    const INITIAL_BACKOFF: u64 = 1000;
    pub struct Rpc;
    impl Rpc {
        pub async fn fetch_pool_addrs<P, T, N>(
            start_block: u64,
            end_block: u64,
            provider: Arc<P>,
            fetcher: Arc<dyn PoolFetcher>,
            chain: Chain,
            requests_per_second: u64,
        ) -> Option<Vec<Address>>
        where
            P: Provider<T, N> + 'static,
            T: Transport + Clone + 'static,
            N: Network,
        {
            let block_difference = end_block.saturating_sub(start_block);
            if block_difference > 0 {
                let (total_steps, step_size) = if block_difference < STEP_SIZE {
                    (1, block_difference)
                } else {
                    (
                        ((block_difference as f64) / (STEP_SIZE as f64)).ceil() as u64,
                        STEP_SIZE,
                    )
                };
                let info = {
                    let res = ::alloc::fmt::format(
                        format_args!("{0} address sync", fetcher.pool_type()),
                    );
                    res
                };
                let progress_bar = create_progress_bar(total_steps, info);
                let block_ranges: Vec<_> = (start_block..=end_block)
                    .step_by(step_size as usize)
                    .map(|from_block| {
                        let to_block = (from_block + step_size - 1).min(end_block);
                        (from_block, to_block)
                    })
                    .collect();
                let results = stream::iter(block_ranges)
                    .map(|(from_block, to_block)| {
                        let provider = provider.clone();
                        let fetcher = fetcher.clone();
                        let progress_bar = progress_bar.clone();
                        async move {
                            let mut retry_count = 0;
                            let mut backoff = INITIAL_BACKOFF;
                            loop {
                                let filter = Filter::new()
                                    .address(fetcher.factory_address(chain))
                                    .event(fetcher.pair_created_signature())
                                    .from_block(from_block)
                                    .to_block(to_block);
                                match provider.get_logs(&filter).await {
                                    Ok(logs) => {
                                        let addresses: Vec<Address> = logs
                                            .iter()
                                            .map(|log| fetcher.log_to_address(&log.inner))
                                            .collect();
                                        progress_bar.inc(1);
                                        return addresses;
                                    }
                                    Err(e) => {
                                        if retry_count >= MAX_RETRIES {
                                            {
                                                ::std::io::_eprint(
                                                    format_args!(
                                                        "Max retries reached for blocks {0}-{1}: {2:?}\n",
                                                        from_block,
                                                        to_block,
                                                        e,
                                                    ),
                                                );
                                            };
                                            return Vec::new();
                                        }
                                        let jitter = rand::thread_rng().gen_range(0..=100);
                                        let sleep_duration = Duration::from_millis(
                                            backoff + jitter,
                                        );
                                        tokio::time::sleep(sleep_duration).await;
                                        retry_count += 1;
                                        backoff *= 2;
                                    }
                                }
                            }
                        }
                    })
                    .buffer_unordered(requests_per_second as usize)
                    .collect::<Vec<Vec<Address>>>()
                    .await;
                let all_addresses: Vec<Address> = results
                    .into_iter()
                    .flatten()
                    .collect();
                Some(all_addresses)
            } else {
                None
            }
        }
        pub async fn populate_pools<P, T, N>(
            pool_addrs: Vec<Address>,
            provider: Arc<P>,
            pool: PoolType,
            requests_per_second: u64,
        ) -> Vec<Pool>
        where
            P: Provider<T, N> + 'static,
            T: Transport + Clone + 'static,
            N: Network,
        {
            let total_tasks = (pool_addrs.len() + 39) / 40;
            let info = {
                let res = ::alloc::fmt::format(format_args!("{0} data sync", pool));
                res
            };
            let progress_bar = create_progress_bar(total_tasks as u64, info);
            {
                ::std::io::_print(
                    format_args!("V3 addresses len: {0}\n", pool_addrs.len()),
                );
            };
            let addr_chunks: Vec<Vec<Address>> = pool_addrs
                .chunks(40)
                .map(|chunk| chunk.to_vec())
                .collect();
            let results = stream::iter(addr_chunks)
                .map(|chunk| {
                    let provider = provider.clone();
                    let progress_bar = progress_bar.clone();
                    let pool = pool.clone();
                    async move {
                        let mut retry_count = 0;
                        let mut backoff = INITIAL_BACKOFF;
                        loop {
                            match pool
                                .build_pools_from_addrs(provider.clone(), chunk.clone())
                                .await
                            {
                                populated_pools if !populated_pools.is_empty() => {
                                    progress_bar.inc(1);
                                    return populated_pools;
                                }
                                _ => {
                                    if retry_count >= MAX_RETRIES {
                                        {
                                            ::std::io::_eprint(
                                                format_args!("Max retries reached for chunk\n"),
                                            );
                                        };
                                        return Vec::new();
                                    }
                                    let jitter = rand::thread_rng().gen_range(0..=100);
                                    let sleep_duration = Duration::from_millis(
                                        backoff + jitter,
                                    );
                                    tokio::time::sleep(sleep_duration).await;
                                    retry_count += 1;
                                    backoff *= 2;
                                }
                            }
                        }
                    }
                })
                .buffer_unordered(requests_per_second as usize * 2)
                .collect::<Vec<Vec<Pool>>>()
                .await;
            let populated_pools: Vec<Pool> = results.into_iter().flatten().collect();
            populated_pools
        }
    }
}
pub mod filter {
    use crate::{Pool, PoolInfo};
    use alloy::primitives::Address;
    use reqwest::header::{HeaderMap, HeaderValue};
    use serde::Deserialize;
    use std::collections::HashSet;
    use std::str::FromStr;
    use thiserror::Error;
    use crate::Chain;
    struct BirdeyeResponse {
        data: ResponseData,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for BirdeyeResponse {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "BirdeyeResponse",
                "data",
                &&self.data,
            )
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for BirdeyeResponse {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "data" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"data" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<BirdeyeResponse>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = BirdeyeResponse;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct BirdeyeResponse",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ResponseData,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct BirdeyeResponse with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(BirdeyeResponse { data: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<ResponseData> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("data"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ResponseData,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("data")?
                            }
                        };
                        _serde::__private::Ok(BirdeyeResponse { data: __field0 })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["data"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "BirdeyeResponse",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<BirdeyeResponse>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    struct ResponseData {
        tokens: Vec<Token>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ResponseData {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "ResponseData",
                "tokens",
                &&self.tokens,
            )
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ResponseData {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "tokens" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"tokens" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ResponseData>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ResponseData;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ResponseData",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            Vec<Token>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct ResponseData with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ResponseData { tokens: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<Vec<Token>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("tokens"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Vec<Token>>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("tokens")?
                            }
                        };
                        _serde::__private::Ok(ResponseData { tokens: __field0 })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["tokens"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ResponseData",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ResponseData>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    struct Token {
        address: String,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Token {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "Token",
                "address",
                &&self.address,
            )
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Token {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "address" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"address" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Token>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Token;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Token",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Token with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Token { address: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "address",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("address")?
                            }
                        };
                        _serde::__private::Ok(Token { address: __field0 })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["address"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Token",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Token>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    pub enum FilterError {
        #[error("API request failed: {0}")]
        ApiError(#[from] reqwest::Error),
        #[error("Environment variable not set: {0}")]
        EnvVarError(#[from] std::env::VarError),
        #[error("Invalid header value: {0}")]
        InvalidHeaderValue(#[from] reqwest::header::InvalidHeaderValue),
    }
    #[allow(unused_qualifications)]
    impl std::error::Error for FilterError {
        fn source(&self) -> ::core::option::Option<&(dyn std::error::Error + 'static)> {
            use thiserror::__private::AsDynError as _;
            #[allow(deprecated)]
            match self {
                FilterError::ApiError { 0: source, .. } => {
                    ::core::option::Option::Some(source.as_dyn_error())
                }
                FilterError::EnvVarError { 0: source, .. } => {
                    ::core::option::Option::Some(source.as_dyn_error())
                }
                FilterError::InvalidHeaderValue { 0: source, .. } => {
                    ::core::option::Option::Some(source.as_dyn_error())
                }
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::core::fmt::Display for FilterError {
        fn fmt(&self, __formatter: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            use thiserror::__private::AsDisplay as _;
            #[allow(unused_variables, deprecated, clippy::used_underscore_binding)]
            match self {
                FilterError::ApiError(_0) => {
                    __formatter
                        .write_fmt(
                            format_args!("API request failed: {0}", _0.as_display()),
                        )
                }
                FilterError::EnvVarError(_0) => {
                    __formatter
                        .write_fmt(
                            format_args!(
                                "Environment variable not set: {0}",
                                _0.as_display(),
                            ),
                        )
                }
                FilterError::InvalidHeaderValue(_0) => {
                    __formatter
                        .write_fmt(
                            format_args!("Invalid header value: {0}", _0.as_display()),
                        )
                }
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::core::convert::From<reqwest::Error> for FilterError {
        #[allow(deprecated)]
        fn from(source: reqwest::Error) -> Self {
            FilterError::ApiError { 0: source }
        }
    }
    #[allow(unused_qualifications)]
    impl ::core::convert::From<std::env::VarError> for FilterError {
        #[allow(deprecated)]
        fn from(source: std::env::VarError) -> Self {
            FilterError::EnvVarError {
                0: source,
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::core::convert::From<reqwest::header::InvalidHeaderValue> for FilterError {
        #[allow(deprecated)]
        fn from(source: reqwest::header::InvalidHeaderValue) -> Self {
            FilterError::InvalidHeaderValue {
                0: source,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for FilterError {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                FilterError::ApiError(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "ApiError",
                        &__self_0,
                    )
                }
                FilterError::EnvVarError(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "EnvVarError",
                        &__self_0,
                    )
                }
                FilterError::InvalidHeaderValue(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "InvalidHeaderValue",
                        &__self_0,
                    )
                }
            }
        }
    }
    pub async fn fetch_top_volume_tokens(
        num_results: usize,
        chain: Chain,
    ) -> Vec<Address> {
        let top_volume_tokens = query_birdeye(num_results, chain).await;
        top_volume_tokens
            .into_iter()
            .map(|addr| Address::from_str(&addr).unwrap())
            .collect()
    }
    async fn query_birdeye(num_results: usize, chain: Chain) -> Vec<String> {
        let client = reqwest::Client::new();
        let mut headers = HeaderMap::new();
        let api_key = std::env::var("BIRDEYE_KEY").unwrap();
        headers.insert("X-API-KEY", HeaderValue::from_str(&api_key).unwrap());
        if chain == Chain::Ethereum {
            headers.insert("x-chain", HeaderValue::from_static("ethereum"));
        } else if chain == Chain::Base {
            headers.insert("x-chain", HeaderValue::from_static("base"));
        }
        let mut query_params: Vec<(usize, usize)> = Vec::new();
        if num_results < 50 {
            query_params.push((0, num_results));
        } else {
            for offset in (0..num_results).step_by(50) {
                query_params.push((offset, 50));
            }
        }
        let mut addresses: Vec<String> = Vec::new();
        for (offset, num) in query_params {
            let response = client
                .get("https://public-api.birdeye.so/defi/tokenlist")
                .headers(headers.clone())
                .query(
                    &[
                        ("sort_by", "v24hUSD"),
                        ("sort_type", "desc"),
                        ("offset", &offset.to_string()),
                        ("limit", &num.to_string()),
                    ],
                )
                .send()
                .await
                .unwrap();
            if response.status().is_success() {
                let birdeye_response: BirdeyeResponse = response.json().await.unwrap();
                let results: Vec<String> = birdeye_response
                    .data
                    .tokens
                    .into_iter()
                    .map(|token| token.address)
                    .collect();
                addresses.extend(results);
            }
        }
        addresses
    }
}
mod pool_sync {
    //! PoolSync Core Implementation
    //!
    //! This module contains the core functionality for synchronizing pools across different
    //! blockchain networks and protocols. It includes the main `PoolSync` struct and its
    //! associated methods for configuring and executing the synchronization process.
    //!
    use alloy::network::Network;
    use alloy::providers::Provider;
    use alloy::transports::Transport;
    use std::collections::HashMap;
    use std::sync::Arc;
    use crate::builder::PoolSyncBuilder;
    use crate::cache::{read_cache_file, write_cache_file, PoolCache};
    use crate::chain::Chain;
    use crate::errors::*;
    use crate::pools::*;
    use crate::rpc::Rpc;
    /// The maximum number of retries for a failed query
    const MAX_RETRIES: u32 = 5;
    /// The main struct for pool synchronization
    pub struct PoolSync {
        /// Map of pool types to their fetcher implementations
        pub fetchers: HashMap<PoolType, Arc<dyn PoolFetcher>>,
        /// The chain to sync on
        pub chain: Chain,
        /// The rate limit of the rpc
        pub rate_limit: u64,
    }
    impl PoolSync {
        /// Construct a new builder to configure sync parameters
        pub fn builder() -> PoolSyncBuilder {
            PoolSyncBuilder::default()
        }
        /// Synchronizes all added pools for the specified chain
        pub async fn sync_pools<P, T, N>(
            &self,
            provider: Arc<P>,
        ) -> Result<Vec<Pool>, PoolSyncError>
        where
            P: Provider<T, N> + 'static,
            T: Transport + Clone + 'static,
            N: Network,
        {
            std::fs::create_dir_all("cache").unwrap();
            let mut pool_caches: Vec<PoolCache> = self
                .fetchers
                .keys()
                .map(|pool_type| read_cache_file(pool_type, self.chain))
                .collect();
            let end_block = provider.get_block_number().await.unwrap();
            for cache in &mut pool_caches {
                let start_block = cache.last_synced_block;
                let fetcher = self.fetchers[&cache.pool_type].clone();
                let pool_addrs = Rpc::fetch_pool_addrs(
                        start_block,
                        end_block,
                        provider.clone(),
                        fetcher.clone(),
                        self.chain,
                        self.rate_limit,
                    )
                    .await
                    .unwrap();
                let populated_pools = Rpc::populate_pools(
                        pool_addrs,
                        provider.clone(),
                        cache.pool_type,
                        self.rate_limit,
                    )
                    .await;
                cache.pools.extend(populated_pools);
                cache.last_synced_block = end_block;
                write_cache_file(cache, self.chain);
            }
            Ok(pool_caches.into_iter().flat_map(|cache| cache.pools).collect())
        }
    }
}
mod pools {
    //! Core definitions for pool synchronization
    //!
    //! This module defines the core structures and traits used in the pool synchronization system.
    //! It includes enumerations for supported pool types, a unified `Pool` enum, and a trait for
    //! fetching and decoding pool creation events.
    use crate::chain::Chain;
    use crate::impl_pool_info;
    use alloy::primitives::{Address, Log};
    use alloy::providers::Provider;
    use alloy::transports::Transport;
    use alloy::network::Network;
    use pool_structure::{UniswapV2Pool, UniswapV3Pool};
    use serde::{Deserialize, Serialize};
    use std::{fmt, sync::Arc};
    use alloy::primitives::U128;
    mod pool_structure {
        use alloy::primitives::{Address, U128, U256};
        use std::collections::HashMap;
        use serde::{Deserialize, Serialize};
        pub struct UniswapV2Pool {
            pub address: Address,
            pub token0: Address,
            pub token1: Address,
            pub token0_name: String,
            pub token1_name: String,
            pub token0_decimals: u8,
            pub token1_decimals: u8,
            pub token0_reserves: U128,
            pub token1_reserves: U128,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for UniswapV2Pool {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "address",
                    "token0",
                    "token1",
                    "token0_name",
                    "token1_name",
                    "token0_decimals",
                    "token1_decimals",
                    "token0_reserves",
                    "token1_reserves",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.address,
                    &self.token0,
                    &self.token1,
                    &self.token0_name,
                    &self.token1_name,
                    &self.token0_decimals,
                    &self.token1_decimals,
                    &self.token0_reserves,
                    &&self.token1_reserves,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "UniswapV2Pool",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for UniswapV2Pool {
            #[inline]
            fn clone(&self) -> UniswapV2Pool {
                UniswapV2Pool {
                    address: ::core::clone::Clone::clone(&self.address),
                    token0: ::core::clone::Clone::clone(&self.token0),
                    token1: ::core::clone::Clone::clone(&self.token1),
                    token0_name: ::core::clone::Clone::clone(&self.token0_name),
                    token1_name: ::core::clone::Clone::clone(&self.token1_name),
                    token0_decimals: ::core::clone::Clone::clone(&self.token0_decimals),
                    token1_decimals: ::core::clone::Clone::clone(&self.token1_decimals),
                    token0_reserves: ::core::clone::Clone::clone(&self.token0_reserves),
                    token1_reserves: ::core::clone::Clone::clone(&self.token1_reserves),
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for UniswapV2Pool {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "UniswapV2Pool",
                        false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "address",
                        &self.address,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "token0",
                        &self.token0,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "token1",
                        &self.token1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "token0_name",
                        &self.token0_name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "token1_name",
                        &self.token1_name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "token0_decimals",
                        &self.token0_decimals,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "token1_decimals",
                        &self.token1_decimals,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "token0_reserves",
                        &self.token0_reserves,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "token1_reserves",
                        &self.token1_reserves,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for UniswapV2Pool {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                        __field7,
                        __field8,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                7u64 => _serde::__private::Ok(__Field::__field7),
                                8u64 => _serde::__private::Ok(__Field::__field8),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "address" => _serde::__private::Ok(__Field::__field0),
                                "token0" => _serde::__private::Ok(__Field::__field1),
                                "token1" => _serde::__private::Ok(__Field::__field2),
                                "token0_name" => _serde::__private::Ok(__Field::__field3),
                                "token1_name" => _serde::__private::Ok(__Field::__field4),
                                "token0_decimals" => {
                                    _serde::__private::Ok(__Field::__field5)
                                }
                                "token1_decimals" => {
                                    _serde::__private::Ok(__Field::__field6)
                                }
                                "token0_reserves" => {
                                    _serde::__private::Ok(__Field::__field7)
                                }
                                "token1_reserves" => {
                                    _serde::__private::Ok(__Field::__field8)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"address" => _serde::__private::Ok(__Field::__field0),
                                b"token0" => _serde::__private::Ok(__Field::__field1),
                                b"token1" => _serde::__private::Ok(__Field::__field2),
                                b"token0_name" => _serde::__private::Ok(__Field::__field3),
                                b"token1_name" => _serde::__private::Ok(__Field::__field4),
                                b"token0_decimals" => {
                                    _serde::__private::Ok(__Field::__field5)
                                }
                                b"token1_decimals" => {
                                    _serde::__private::Ok(__Field::__field6)
                                }
                                b"token0_reserves" => {
                                    _serde::__private::Ok(__Field::__field7)
                                }
                                b"token1_reserves" => {
                                    _serde::__private::Ok(__Field::__field8)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<UniswapV2Pool>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = UniswapV2Pool;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct UniswapV2Pool",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                Address,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct UniswapV2Pool with 9 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Address,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct UniswapV2Pool with 9 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                Address,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct UniswapV2Pool with 9 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct UniswapV2Pool with 9 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct UniswapV2Pool with 9 elements",
                                        ),
                                    );
                                }
                            };
                            let __field5 = match _serde::de::SeqAccess::next_element::<
                                u8,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            5usize,
                                            &"struct UniswapV2Pool with 9 elements",
                                        ),
                                    );
                                }
                            };
                            let __field6 = match _serde::de::SeqAccess::next_element::<
                                u8,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            6usize,
                                            &"struct UniswapV2Pool with 9 elements",
                                        ),
                                    );
                                }
                            };
                            let __field7 = match _serde::de::SeqAccess::next_element::<
                                U128,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            7usize,
                                            &"struct UniswapV2Pool with 9 elements",
                                        ),
                                    );
                                }
                            };
                            let __field8 = match _serde::de::SeqAccess::next_element::<
                                U128,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            8usize,
                                            &"struct UniswapV2Pool with 9 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(UniswapV2Pool {
                                address: __field0,
                                token0: __field1,
                                token1: __field2,
                                token0_name: __field3,
                                token1_name: __field4,
                                token0_decimals: __field5,
                                token1_decimals: __field6,
                                token0_reserves: __field7,
                                token1_reserves: __field8,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<Address> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Address> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<Address> = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field4: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field5: _serde::__private::Option<u8> = _serde::__private::None;
                            let mut __field6: _serde::__private::Option<u8> = _serde::__private::None;
                            let mut __field7: _serde::__private::Option<U128> = _serde::__private::None;
                            let mut __field8: _serde::__private::Option<U128> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "address",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Address>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("token0"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Address>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("token1"),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Address>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "token0_name",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "token1_name",
                                                ),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field5 => {
                                        if _serde::__private::Option::is_some(&__field5) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "token0_decimals",
                                                ),
                                            );
                                        }
                                        __field5 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<u8>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field6 => {
                                        if _serde::__private::Option::is_some(&__field6) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "token1_decimals",
                                                ),
                                            );
                                        }
                                        __field6 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<u8>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field7 => {
                                        if _serde::__private::Option::is_some(&__field7) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "token0_reserves",
                                                ),
                                            );
                                        }
                                        __field7 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<U128>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field8 => {
                                        if _serde::__private::Option::is_some(&__field8) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "token1_reserves",
                                                ),
                                            );
                                        }
                                        __field8 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<U128>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("address")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("token0")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("token1")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("token0_name")?
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("token1_name")?
                                }
                            };
                            let __field5 = match __field5 {
                                _serde::__private::Some(__field5) => __field5,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("token0_decimals")?
                                }
                            };
                            let __field6 = match __field6 {
                                _serde::__private::Some(__field6) => __field6,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("token1_decimals")?
                                }
                            };
                            let __field7 = match __field7 {
                                _serde::__private::Some(__field7) => __field7,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("token0_reserves")?
                                }
                            };
                            let __field8 = match __field8 {
                                _serde::__private::Some(__field8) => __field8,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("token1_reserves")?
                                }
                            };
                            _serde::__private::Ok(UniswapV2Pool {
                                address: __field0,
                                token0: __field1,
                                token1: __field2,
                                token0_name: __field3,
                                token1_name: __field4,
                                token0_decimals: __field5,
                                token1_decimals: __field6,
                                token0_reserves: __field7,
                                token1_reserves: __field8,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "address",
                        "token0",
                        "token1",
                        "token0_name",
                        "token1_name",
                        "token0_decimals",
                        "token1_decimals",
                        "token0_reserves",
                        "token1_reserves",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "UniswapV2Pool",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<UniswapV2Pool>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::default::Default for UniswapV2Pool {
            #[inline]
            fn default() -> UniswapV2Pool {
                UniswapV2Pool {
                    address: ::core::default::Default::default(),
                    token0: ::core::default::Default::default(),
                    token1: ::core::default::Default::default(),
                    token0_name: ::core::default::Default::default(),
                    token1_name: ::core::default::Default::default(),
                    token0_decimals: ::core::default::Default::default(),
                    token1_decimals: ::core::default::Default::default(),
                    token0_reserves: ::core::default::Default::default(),
                    token1_reserves: ::core::default::Default::default(),
                }
            }
        }
        pub struct UniswapV3Pool {
            pub address: Address,
            pub token0: Address,
            pub token1: Address,
            pub token0_name: String,
            pub token1_name: String,
            pub token0_decimals: u8,
            pub token1_decimals: u8,
            pub liquidity: U128,
            pub sqrt_price: U256,
            pub fee: u32,
            pub tick: i32,
            pub tick_spacing: i32,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for UniswapV3Pool {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "address",
                    "token0",
                    "token1",
                    "token0_name",
                    "token1_name",
                    "token0_decimals",
                    "token1_decimals",
                    "liquidity",
                    "sqrt_price",
                    "fee",
                    "tick",
                    "tick_spacing",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.address,
                    &self.token0,
                    &self.token1,
                    &self.token0_name,
                    &self.token1_name,
                    &self.token0_decimals,
                    &self.token1_decimals,
                    &self.liquidity,
                    &self.sqrt_price,
                    &self.fee,
                    &self.tick,
                    &&self.tick_spacing,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "UniswapV3Pool",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for UniswapV3Pool {
            #[inline]
            fn clone(&self) -> UniswapV3Pool {
                UniswapV3Pool {
                    address: ::core::clone::Clone::clone(&self.address),
                    token0: ::core::clone::Clone::clone(&self.token0),
                    token1: ::core::clone::Clone::clone(&self.token1),
                    token0_name: ::core::clone::Clone::clone(&self.token0_name),
                    token1_name: ::core::clone::Clone::clone(&self.token1_name),
                    token0_decimals: ::core::clone::Clone::clone(&self.token0_decimals),
                    token1_decimals: ::core::clone::Clone::clone(&self.token1_decimals),
                    liquidity: ::core::clone::Clone::clone(&self.liquidity),
                    sqrt_price: ::core::clone::Clone::clone(&self.sqrt_price),
                    fee: ::core::clone::Clone::clone(&self.fee),
                    tick: ::core::clone::Clone::clone(&self.tick),
                    tick_spacing: ::core::clone::Clone::clone(&self.tick_spacing),
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for UniswapV3Pool {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "UniswapV3Pool",
                        false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "address",
                        &self.address,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "token0",
                        &self.token0,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "token1",
                        &self.token1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "token0_name",
                        &self.token0_name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "token1_name",
                        &self.token1_name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "token0_decimals",
                        &self.token0_decimals,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "token1_decimals",
                        &self.token1_decimals,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "liquidity",
                        &self.liquidity,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "sqrt_price",
                        &self.sqrt_price,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "fee",
                        &self.fee,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "tick",
                        &self.tick,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "tick_spacing",
                        &self.tick_spacing,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for UniswapV3Pool {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                        __field7,
                        __field8,
                        __field9,
                        __field10,
                        __field11,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                7u64 => _serde::__private::Ok(__Field::__field7),
                                8u64 => _serde::__private::Ok(__Field::__field8),
                                9u64 => _serde::__private::Ok(__Field::__field9),
                                10u64 => _serde::__private::Ok(__Field::__field10),
                                11u64 => _serde::__private::Ok(__Field::__field11),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "address" => _serde::__private::Ok(__Field::__field0),
                                "token0" => _serde::__private::Ok(__Field::__field1),
                                "token1" => _serde::__private::Ok(__Field::__field2),
                                "token0_name" => _serde::__private::Ok(__Field::__field3),
                                "token1_name" => _serde::__private::Ok(__Field::__field4),
                                "token0_decimals" => {
                                    _serde::__private::Ok(__Field::__field5)
                                }
                                "token1_decimals" => {
                                    _serde::__private::Ok(__Field::__field6)
                                }
                                "liquidity" => _serde::__private::Ok(__Field::__field7),
                                "sqrt_price" => _serde::__private::Ok(__Field::__field8),
                                "fee" => _serde::__private::Ok(__Field::__field9),
                                "tick" => _serde::__private::Ok(__Field::__field10),
                                "tick_spacing" => _serde::__private::Ok(__Field::__field11),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"address" => _serde::__private::Ok(__Field::__field0),
                                b"token0" => _serde::__private::Ok(__Field::__field1),
                                b"token1" => _serde::__private::Ok(__Field::__field2),
                                b"token0_name" => _serde::__private::Ok(__Field::__field3),
                                b"token1_name" => _serde::__private::Ok(__Field::__field4),
                                b"token0_decimals" => {
                                    _serde::__private::Ok(__Field::__field5)
                                }
                                b"token1_decimals" => {
                                    _serde::__private::Ok(__Field::__field6)
                                }
                                b"liquidity" => _serde::__private::Ok(__Field::__field7),
                                b"sqrt_price" => _serde::__private::Ok(__Field::__field8),
                                b"fee" => _serde::__private::Ok(__Field::__field9),
                                b"tick" => _serde::__private::Ok(__Field::__field10),
                                b"tick_spacing" => _serde::__private::Ok(__Field::__field11),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<UniswapV3Pool>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = UniswapV3Pool;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct UniswapV3Pool",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                Address,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct UniswapV3Pool with 12 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Address,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct UniswapV3Pool with 12 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                Address,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct UniswapV3Pool with 12 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct UniswapV3Pool with 12 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct UniswapV3Pool with 12 elements",
                                        ),
                                    );
                                }
                            };
                            let __field5 = match _serde::de::SeqAccess::next_element::<
                                u8,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            5usize,
                                            &"struct UniswapV3Pool with 12 elements",
                                        ),
                                    );
                                }
                            };
                            let __field6 = match _serde::de::SeqAccess::next_element::<
                                u8,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            6usize,
                                            &"struct UniswapV3Pool with 12 elements",
                                        ),
                                    );
                                }
                            };
                            let __field7 = match _serde::de::SeqAccess::next_element::<
                                U128,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            7usize,
                                            &"struct UniswapV3Pool with 12 elements",
                                        ),
                                    );
                                }
                            };
                            let __field8 = match _serde::de::SeqAccess::next_element::<
                                U256,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            8usize,
                                            &"struct UniswapV3Pool with 12 elements",
                                        ),
                                    );
                                }
                            };
                            let __field9 = match _serde::de::SeqAccess::next_element::<
                                u32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            9usize,
                                            &"struct UniswapV3Pool with 12 elements",
                                        ),
                                    );
                                }
                            };
                            let __field10 = match _serde::de::SeqAccess::next_element::<
                                i32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            10usize,
                                            &"struct UniswapV3Pool with 12 elements",
                                        ),
                                    );
                                }
                            };
                            let __field11 = match _serde::de::SeqAccess::next_element::<
                                i32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            11usize,
                                            &"struct UniswapV3Pool with 12 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(UniswapV3Pool {
                                address: __field0,
                                token0: __field1,
                                token1: __field2,
                                token0_name: __field3,
                                token1_name: __field4,
                                token0_decimals: __field5,
                                token1_decimals: __field6,
                                liquidity: __field7,
                                sqrt_price: __field8,
                                fee: __field9,
                                tick: __field10,
                                tick_spacing: __field11,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<Address> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Address> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<Address> = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field4: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field5: _serde::__private::Option<u8> = _serde::__private::None;
                            let mut __field6: _serde::__private::Option<u8> = _serde::__private::None;
                            let mut __field7: _serde::__private::Option<U128> = _serde::__private::None;
                            let mut __field8: _serde::__private::Option<U256> = _serde::__private::None;
                            let mut __field9: _serde::__private::Option<u32> = _serde::__private::None;
                            let mut __field10: _serde::__private::Option<i32> = _serde::__private::None;
                            let mut __field11: _serde::__private::Option<i32> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "address",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Address>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("token0"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Address>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("token1"),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Address>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "token0_name",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "token1_name",
                                                ),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field5 => {
                                        if _serde::__private::Option::is_some(&__field5) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "token0_decimals",
                                                ),
                                            );
                                        }
                                        __field5 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<u8>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field6 => {
                                        if _serde::__private::Option::is_some(&__field6) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "token1_decimals",
                                                ),
                                            );
                                        }
                                        __field6 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<u8>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field7 => {
                                        if _serde::__private::Option::is_some(&__field7) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "liquidity",
                                                ),
                                            );
                                        }
                                        __field7 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<U128>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field8 => {
                                        if _serde::__private::Option::is_some(&__field8) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "sqrt_price",
                                                ),
                                            );
                                        }
                                        __field8 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<U256>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field9 => {
                                        if _serde::__private::Option::is_some(&__field9) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("fee"),
                                            );
                                        }
                                        __field9 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<u32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field10 => {
                                        if _serde::__private::Option::is_some(&__field10) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("tick"),
                                            );
                                        }
                                        __field10 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<i32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field11 => {
                                        if _serde::__private::Option::is_some(&__field11) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "tick_spacing",
                                                ),
                                            );
                                        }
                                        __field11 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<i32>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("address")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("token0")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("token1")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("token0_name")?
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("token1_name")?
                                }
                            };
                            let __field5 = match __field5 {
                                _serde::__private::Some(__field5) => __field5,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("token0_decimals")?
                                }
                            };
                            let __field6 = match __field6 {
                                _serde::__private::Some(__field6) => __field6,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("token1_decimals")?
                                }
                            };
                            let __field7 = match __field7 {
                                _serde::__private::Some(__field7) => __field7,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("liquidity")?
                                }
                            };
                            let __field8 = match __field8 {
                                _serde::__private::Some(__field8) => __field8,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("sqrt_price")?
                                }
                            };
                            let __field9 = match __field9 {
                                _serde::__private::Some(__field9) => __field9,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("fee")?
                                }
                            };
                            let __field10 = match __field10 {
                                _serde::__private::Some(__field10) => __field10,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("tick")?
                                }
                            };
                            let __field11 = match __field11 {
                                _serde::__private::Some(__field11) => __field11,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("tick_spacing")?
                                }
                            };
                            _serde::__private::Ok(UniswapV3Pool {
                                address: __field0,
                                token0: __field1,
                                token1: __field2,
                                token0_name: __field3,
                                token1_name: __field4,
                                token0_decimals: __field5,
                                token1_decimals: __field6,
                                liquidity: __field7,
                                sqrt_price: __field8,
                                fee: __field9,
                                tick: __field10,
                                tick_spacing: __field11,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "address",
                        "token0",
                        "token1",
                        "token0_name",
                        "token1_name",
                        "token0_decimals",
                        "token1_decimals",
                        "liquidity",
                        "sqrt_price",
                        "fee",
                        "tick",
                        "tick_spacing",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "UniswapV3Pool",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<UniswapV3Pool>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::default::Default for UniswapV3Pool {
            #[inline]
            fn default() -> UniswapV3Pool {
                UniswapV3Pool {
                    address: ::core::default::Default::default(),
                    token0: ::core::default::Default::default(),
                    token1: ::core::default::Default::default(),
                    token0_name: ::core::default::Default::default(),
                    token1_name: ::core::default::Default::default(),
                    token0_decimals: ::core::default::Default::default(),
                    token1_decimals: ::core::default::Default::default(),
                    liquidity: ::core::default::Default::default(),
                    sqrt_price: ::core::default::Default::default(),
                    fee: ::core::default::Default::default(),
                    tick: ::core::default::Default::default(),
                    tick_spacing: ::core::default::Default::default(),
                }
            }
        }
        impl UniswapV2Pool {
            pub fn is_valid(&self) -> bool {
                self.address != Address::ZERO && self.token0 != Address::ZERO
                    && self.token1 != Address::ZERO
            }
        }
        impl UniswapV3Pool {
            pub fn is_valid(&self) -> bool {
                self.address != Address::ZERO && self.token0 != Address::ZERO
                    && self.token1 != Address::ZERO
            }
        }
    }
    mod gen {
        use alloy::sol;
        const _: &'static [u8] = b"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeToSetter\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"PairCreated\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allPairs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allPairsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"createPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeTo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeToSetter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeTo\",\"type\":\"address\"}],\"name\":\"setFeeTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeToSetter\",\"type\":\"address\"}],\"name\":\"setFeeToSetter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]";
        /**

Generated by the following Solidity interface...
```solidity
interface UniswapV2Factory {
    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);

    constructor(address _feeToSetter);

    function allPairs(uint256) external view returns (address);
    function allPairsLength() external view returns (uint256);
    function createPair(address tokenA, address tokenB) external returns (address pair);
    function feeTo() external view returns (address);
    function feeToSetter() external view returns (address);
    function getPair(address, address) external view returns (address);
    function setFeeTo(address _feeTo) external;
    function setFeeToSetter(address _feeToSetter) external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "_feeToSetter",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "allPairs",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "allPairsLength",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "createPair",
    "inputs": [
      {
        "name": "tokenA",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "tokenB",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "pair",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "feeTo",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "feeToSetter",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getPair",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "setFeeTo",
    "inputs": [
      {
        "name": "_feeTo",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setFeeToSetter",
    "inputs": [
      {
        "name": "_feeToSetter",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "PairCreated",
    "inputs": [
      {
        "name": "token0",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "token1",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "pair",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  }
]
```*/
        #[allow(non_camel_case_types, non_snake_case, clippy::style)]
        pub mod UniswapV2Factory {
            use super::*;
            use ::alloy::sol_types as alloy_sol_types;
            /**Event with signature `PairCreated(address,address,address,uint256)` and selector `0x0d3648bd0f6ba80134a33ba9275ac585d9d315f0ad8355cddefde31afa28d0e9`.
```solidity
event PairCreated(address indexed token0, address indexed token1, address pair, uint256);
```*/
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            pub struct PairCreated {
                #[allow(missing_docs)]
                pub token0: ::alloy::sol_types::private::Address,
                #[allow(missing_docs)]
                pub token1: ::alloy::sol_types::private::Address,
                #[allow(missing_docs)]
                pub pair: ::alloy::sol_types::private::Address,
                #[allow(missing_docs)]
                pub _3: ::alloy::sol_types::private::U256,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            impl ::core::clone::Clone for PairCreated {
                #[inline]
                fn clone(&self) -> PairCreated {
                    PairCreated {
                        token0: ::core::clone::Clone::clone(&self.token0),
                        token1: ::core::clone::Clone::clone(&self.token1),
                        pair: ::core::clone::Clone::clone(&self.pair),
                        _3: ::core::clone::Clone::clone(&self._3),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            impl ::core::fmt::Debug for PairCreated {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "PairCreated",
                        "token0",
                        &self.token0,
                        "token1",
                        &self.token1,
                        "pair",
                        &self.pair,
                        "_3",
                        &&self._3,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                #[automatically_derived]
                impl alloy_sol_types::SolEvent for PairCreated {
                    type DataTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Uint<256>,
                    );
                    type DataToken<'a> = <Self::DataTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type TopicList = (
                        alloy_sol_types::sol_data::FixedBytes<32>,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                    );
                    const SIGNATURE: &'static str = "PairCreated(address,address,address,uint256)";
                    const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                        13u8,
                        54u8,
                        72u8,
                        189u8,
                        15u8,
                        107u8,
                        168u8,
                        1u8,
                        52u8,
                        163u8,
                        59u8,
                        169u8,
                        39u8,
                        90u8,
                        197u8,
                        133u8,
                        217u8,
                        211u8,
                        21u8,
                        240u8,
                        173u8,
                        131u8,
                        85u8,
                        205u8,
                        222u8,
                        253u8,
                        227u8,
                        26u8,
                        250u8,
                        40u8,
                        208u8,
                        233u8,
                    ]);
                    const ANONYMOUS: bool = false;
                    #[allow(unused_variables)]
                    #[inline]
                    fn new(
                        topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                        data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        Self {
                            token0: topics.1,
                            token1: topics.2,
                            pair: data.0,
                            _3: data.1,
                        }
                    }
                    #[inline]
                    fn tokenize_body(&self) -> Self::DataToken<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self.pair,
                            ),
                            <::alloy::sol_types::sol_data::Uint<
                                256,
                            > as alloy_sol_types::SolType>::tokenize(&self._3),
                        )
                    }
                    #[inline]
                    fn topics(
                        &self,
                    ) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                        (
                            Self::SIGNATURE_HASH.into(),
                            self.token0.clone(),
                            self.token1.clone(),
                        )
                    }
                    #[inline]
                    fn encode_topics_raw(
                        &self,
                        out: &mut [alloy_sol_types::abi::token::WordToken],
                    ) -> alloy_sol_types::Result<()> {
                        if out.len()
                            < <Self::TopicList as alloy_sol_types::TopicList>::COUNT
                        {
                            return Err(alloy_sol_types::Error::Overrun);
                        }
                        out[0usize] = alloy_sol_types::abi::token::WordToken(
                            Self::SIGNATURE_HASH,
                        );
                        out[1usize] = <::alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                            &self.token0,
                        );
                        out[2usize] = <::alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                            &self.token1,
                        );
                        Ok(())
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::private::IntoLogData for PairCreated {
                    fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                        From::from(self)
                    }
                    fn into_log_data(self) -> alloy_sol_types::private::LogData {
                        From::from(&self)
                    }
                }
                #[automatically_derived]
                impl From<&PairCreated> for alloy_sol_types::private::LogData {
                    #[inline]
                    fn from(this: &PairCreated) -> alloy_sol_types::private::LogData {
                        alloy_sol_types::SolEvent::encode_log_data(this)
                    }
                }
            };
            /**Constructor`.
```solidity
constructor(address _feeToSetter);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct constructorCall {
                pub _feeToSetter: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for constructorCall {
                #[inline]
                fn clone(&self) -> constructorCall {
                    constructorCall {
                        _feeToSetter: ::core::clone::Clone::clone(&self._feeToSetter),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for constructorCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "constructorCall",
                        "_feeToSetter",
                        &&self._feeToSetter,
                    )
                }
            }
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<constructorCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: constructorCall) -> Self {
                            (value._feeToSetter,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for constructorCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _feeToSetter: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolConstructor for constructorCall {
                    type Parameters<'a> = (::alloy::sol_types::sol_data::Address,);
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self._feeToSetter,
                            ),
                        )
                    }
                }
            };
            /**Function with signature `allPairs(uint256)` and selector `0x1e3dd18b`.
```solidity
function allPairs(uint256) external view returns (address);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct allPairsCall {
                pub _0: ::alloy::sol_types::private::U256,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for allPairsCall {
                #[inline]
                fn clone(&self) -> allPairsCall {
                    allPairsCall {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for allPairsCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "allPairsCall",
                        "_0",
                        &&self._0,
                    )
                }
            }
            ///Container type for the return parameters of the [`allPairs(uint256)`](allPairsCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct allPairsReturn {
                pub _0: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for allPairsReturn {
                #[inline]
                fn clone(&self) -> allPairsReturn {
                    allPairsReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for allPairsReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "allPairsReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Uint<256>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (::alloy::sol_types::private::U256,);
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<allPairsCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: allPairsCall) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for allPairsCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<allPairsReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: allPairsReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for allPairsReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for allPairsCall {
                    type Parameters<'a> = (::alloy::sol_types::sol_data::Uint<256>,);
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = allPairsReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Address,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "allPairs(uint256)";
                    const SELECTOR: [u8; 4] = [30u8, 61u8, 209u8, 139u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Uint<
                                256,
                            > as alloy_sol_types::SolType>::tokenize(&self._0),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `allPairsLength()` and selector `0x574f2ba3`.
```solidity
function allPairsLength() external view returns (uint256);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct allPairsLengthCall {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for allPairsLengthCall {
                #[inline]
                fn clone(&self) -> allPairsLengthCall {
                    allPairsLengthCall {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for allPairsLengthCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "allPairsLengthCall")
                }
            }
            ///Container type for the return parameters of the [`allPairsLength()`](allPairsLengthCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct allPairsLengthReturn {
                pub _0: ::alloy::sol_types::private::U256,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for allPairsLengthReturn {
                #[inline]
                fn clone(&self) -> allPairsLengthReturn {
                    allPairsLengthReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for allPairsLengthReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "allPairsLengthReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<allPairsLengthCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: allPairsLengthCall) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for allPairsLengthCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Uint<256>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (::alloy::sol_types::private::U256,);
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<allPairsLengthReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: allPairsLengthReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for allPairsLengthReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for allPairsLengthCall {
                    type Parameters<'a> = ();
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = allPairsLengthReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Uint<256>,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "allPairsLength()";
                    const SELECTOR: [u8; 4] = [87u8, 79u8, 43u8, 163u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `createPair(address,address)` and selector `0xc9c65396`.
```solidity
function createPair(address tokenA, address tokenB) external returns (address pair);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct createPairCall {
                pub tokenA: ::alloy::sol_types::private::Address,
                pub tokenB: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for createPairCall {
                #[inline]
                fn clone(&self) -> createPairCall {
                    createPairCall {
                        tokenA: ::core::clone::Clone::clone(&self.tokenA),
                        tokenB: ::core::clone::Clone::clone(&self.tokenB),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for createPairCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "createPairCall",
                        "tokenA",
                        &self.tokenA,
                        "tokenB",
                        &&self.tokenB,
                    )
                }
            }
            ///Container type for the return parameters of the [`createPair(address,address)`](createPairCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct createPairReturn {
                pub pair: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for createPairReturn {
                #[inline]
                fn clone(&self) -> createPairReturn {
                    createPairReturn {
                        pair: ::core::clone::Clone::clone(&self.pair),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for createPairReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "createPairReturn",
                        "pair",
                        &&self.pair,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<createPairCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: createPairCall) -> Self {
                            (value.tokenA, value.tokenB)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for createPairCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {
                                tokenA: tuple.0,
                                tokenB: tuple.1,
                            }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<createPairReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: createPairReturn) -> Self {
                            (value.pair,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for createPairReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { pair: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for createPairCall {
                    type Parameters<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                    );
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = createPairReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Address,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "createPair(address,address)";
                    const SELECTOR: [u8; 4] = [201u8, 198u8, 83u8, 150u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self.tokenA,
                            ),
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self.tokenB,
                            ),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `feeTo()` and selector `0x017e7e58`.
```solidity
function feeTo() external view returns (address);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct feeToCall {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for feeToCall {
                #[inline]
                fn clone(&self) -> feeToCall {
                    feeToCall {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for feeToCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "feeToCall")
                }
            }
            ///Container type for the return parameters of the [`feeTo()`](feeToCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct feeToReturn {
                pub _0: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for feeToReturn {
                #[inline]
                fn clone(&self) -> feeToReturn {
                    feeToReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for feeToReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "feeToReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<feeToCall> for UnderlyingRustTuple<'_> {
                        fn from(value: feeToCall) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>> for feeToCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<feeToReturn> for UnderlyingRustTuple<'_> {
                        fn from(value: feeToReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>> for feeToReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for feeToCall {
                    type Parameters<'a> = ();
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = feeToReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Address,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "feeTo()";
                    const SELECTOR: [u8; 4] = [1u8, 126u8, 126u8, 88u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `feeToSetter()` and selector `0x094b7415`.
```solidity
function feeToSetter() external view returns (address);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct feeToSetterCall {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for feeToSetterCall {
                #[inline]
                fn clone(&self) -> feeToSetterCall {
                    feeToSetterCall {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for feeToSetterCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "feeToSetterCall")
                }
            }
            ///Container type for the return parameters of the [`feeToSetter()`](feeToSetterCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct feeToSetterReturn {
                pub _0: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for feeToSetterReturn {
                #[inline]
                fn clone(&self) -> feeToSetterReturn {
                    feeToSetterReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for feeToSetterReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "feeToSetterReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<feeToSetterCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: feeToSetterCall) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for feeToSetterCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<feeToSetterReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: feeToSetterReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for feeToSetterReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for feeToSetterCall {
                    type Parameters<'a> = ();
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = feeToSetterReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Address,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "feeToSetter()";
                    const SELECTOR: [u8; 4] = [9u8, 75u8, 116u8, 21u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `getPair(address,address)` and selector `0xe6a43905`.
```solidity
function getPair(address, address) external view returns (address);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct getPairCall {
                pub _0: ::alloy::sol_types::private::Address,
                pub _1: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for getPairCall {
                #[inline]
                fn clone(&self) -> getPairCall {
                    getPairCall {
                        _0: ::core::clone::Clone::clone(&self._0),
                        _1: ::core::clone::Clone::clone(&self._1),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for getPairCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "getPairCall",
                        "_0",
                        &self._0,
                        "_1",
                        &&self._1,
                    )
                }
            }
            ///Container type for the return parameters of the [`getPair(address,address)`](getPairCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct getPairReturn {
                pub _0: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for getPairReturn {
                #[inline]
                fn clone(&self) -> getPairReturn {
                    getPairReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for getPairReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "getPairReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<getPairCall> for UnderlyingRustTuple<'_> {
                        fn from(value: getPairCall) -> Self {
                            (value._0, value._1)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>> for getPairCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0, _1: tuple.1 }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<getPairReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: getPairReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for getPairReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for getPairCall {
                    type Parameters<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                    );
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = getPairReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Address,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "getPair(address,address)";
                    const SELECTOR: [u8; 4] = [230u8, 164u8, 57u8, 5u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self._0,
                            ),
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self._1,
                            ),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `setFeeTo(address)` and selector `0xf46901ed`.
```solidity
function setFeeTo(address _feeTo) external;
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct setFeeToCall {
                pub _feeTo: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for setFeeToCall {
                #[inline]
                fn clone(&self) -> setFeeToCall {
                    setFeeToCall {
                        _feeTo: ::core::clone::Clone::clone(&self._feeTo),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for setFeeToCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "setFeeToCall",
                        "_feeTo",
                        &&self._feeTo,
                    )
                }
            }
            ///Container type for the return parameters of the [`setFeeTo(address)`](setFeeToCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct setFeeToReturn {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for setFeeToReturn {
                #[inline]
                fn clone(&self) -> setFeeToReturn {
                    setFeeToReturn {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for setFeeToReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "setFeeToReturn")
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<setFeeToCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: setFeeToCall) -> Self {
                            (value._feeTo,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for setFeeToCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _feeTo: tuple.0 }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<setFeeToReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: setFeeToReturn) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for setFeeToReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for setFeeToCall {
                    type Parameters<'a> = (::alloy::sol_types::sol_data::Address,);
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = setFeeToReturn;
                    type ReturnTuple<'a> = ();
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "setFeeTo(address)";
                    const SELECTOR: [u8; 4] = [244u8, 105u8, 1u8, 237u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self._feeTo,
                            ),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `setFeeToSetter(address)` and selector `0xa2e74af6`.
```solidity
function setFeeToSetter(address _feeToSetter) external;
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct setFeeToSetterCall {
                pub _feeToSetter: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for setFeeToSetterCall {
                #[inline]
                fn clone(&self) -> setFeeToSetterCall {
                    setFeeToSetterCall {
                        _feeToSetter: ::core::clone::Clone::clone(&self._feeToSetter),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for setFeeToSetterCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "setFeeToSetterCall",
                        "_feeToSetter",
                        &&self._feeToSetter,
                    )
                }
            }
            ///Container type for the return parameters of the [`setFeeToSetter(address)`](setFeeToSetterCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct setFeeToSetterReturn {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for setFeeToSetterReturn {
                #[inline]
                fn clone(&self) -> setFeeToSetterReturn {
                    setFeeToSetterReturn {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for setFeeToSetterReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "setFeeToSetterReturn")
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<setFeeToSetterCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: setFeeToSetterCall) -> Self {
                            (value._feeToSetter,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for setFeeToSetterCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _feeToSetter: tuple.0 }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<setFeeToSetterReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: setFeeToSetterReturn) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for setFeeToSetterReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for setFeeToSetterCall {
                    type Parameters<'a> = (::alloy::sol_types::sol_data::Address,);
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = setFeeToSetterReturn;
                    type ReturnTuple<'a> = ();
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "setFeeToSetter(address)";
                    const SELECTOR: [u8; 4] = [162u8, 231u8, 74u8, 246u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self._feeToSetter,
                            ),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            ///Container for all the [`UniswapV2Factory`](self) function calls.
            pub enum UniswapV2FactoryCalls {
                allPairs(allPairsCall),
                allPairsLength(allPairsLengthCall),
                createPair(createPairCall),
                feeTo(feeToCall),
                feeToSetter(feeToSetterCall),
                getPair(getPairCall),
                setFeeTo(setFeeToCall),
                setFeeToSetter(setFeeToSetterCall),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for UniswapV2FactoryCalls {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        UniswapV2FactoryCalls::allPairs(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "allPairs",
                                &__self_0,
                            )
                        }
                        UniswapV2FactoryCalls::allPairsLength(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "allPairsLength",
                                &__self_0,
                            )
                        }
                        UniswapV2FactoryCalls::createPair(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "createPair",
                                &__self_0,
                            )
                        }
                        UniswapV2FactoryCalls::feeTo(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "feeTo",
                                &__self_0,
                            )
                        }
                        UniswapV2FactoryCalls::feeToSetter(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "feeToSetter",
                                &__self_0,
                            )
                        }
                        UniswapV2FactoryCalls::getPair(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "getPair",
                                &__self_0,
                            )
                        }
                        UniswapV2FactoryCalls::setFeeTo(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "setFeeTo",
                                &__self_0,
                            )
                        }
                        UniswapV2FactoryCalls::setFeeToSetter(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "setFeeToSetter",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl UniswapV2FactoryCalls {
                /// All the selectors of this enum.
                ///
                /// Note that the selectors might not be in the same order as the variants.
                /// No guarantees are made about the order of the selectors.
                ///
                /// Prefer using `SolInterface` methods instead.
                pub const SELECTORS: &'static [[u8; 4usize]] = &[
                    [1u8, 126u8, 126u8, 88u8],
                    [9u8, 75u8, 116u8, 21u8],
                    [30u8, 61u8, 209u8, 139u8],
                    [87u8, 79u8, 43u8, 163u8],
                    [162u8, 231u8, 74u8, 246u8],
                    [201u8, 198u8, 83u8, 150u8],
                    [230u8, 164u8, 57u8, 5u8],
                    [244u8, 105u8, 1u8, 237u8],
                ];
            }
            #[automatically_derived]
            impl alloy_sol_types::SolInterface for UniswapV2FactoryCalls {
                const NAME: &'static str = "UniswapV2FactoryCalls";
                const MIN_DATA_LENGTH: usize = 0usize;
                const COUNT: usize = 8usize;
                #[inline]
                fn selector(&self) -> [u8; 4] {
                    match self {
                        Self::allPairs(_) => {
                            <allPairsCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::allPairsLength(_) => {
                            <allPairsLengthCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::createPair(_) => {
                            <createPairCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::feeTo(_) => {
                            <feeToCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::feeToSetter(_) => {
                            <feeToSetterCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::getPair(_) => {
                            <getPairCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::setFeeTo(_) => {
                            <setFeeToCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::setFeeToSetter(_) => {
                            <setFeeToSetterCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                    }
                }
                #[inline]
                fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
                    Self::SELECTORS.get(i).copied()
                }
                #[inline]
                fn valid_selector(selector: [u8; 4]) -> bool {
                    Self::SELECTORS.binary_search(&selector).is_ok()
                }
                #[inline]
                #[allow(unsafe_code, non_snake_case)]
                fn abi_decode_raw(
                    selector: [u8; 4],
                    data: &[u8],
                    validate: bool,
                ) -> alloy_sol_types::Result<Self> {
                    static DECODE_SHIMS: &[fn(
                        &[u8],
                        bool,
                    ) -> alloy_sol_types::Result<UniswapV2FactoryCalls>] = &[
                        {
                            fn feeTo(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<UniswapV2FactoryCalls> {
                                <feeToCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(UniswapV2FactoryCalls::feeTo)
                            }
                            feeTo
                        },
                        {
                            fn feeToSetter(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<UniswapV2FactoryCalls> {
                                <feeToSetterCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(UniswapV2FactoryCalls::feeToSetter)
                            }
                            feeToSetter
                        },
                        {
                            fn allPairs(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<UniswapV2FactoryCalls> {
                                <allPairsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(UniswapV2FactoryCalls::allPairs)
                            }
                            allPairs
                        },
                        {
                            fn allPairsLength(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<UniswapV2FactoryCalls> {
                                <allPairsLengthCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(UniswapV2FactoryCalls::allPairsLength)
                            }
                            allPairsLength
                        },
                        {
                            fn setFeeToSetter(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<UniswapV2FactoryCalls> {
                                <setFeeToSetterCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(UniswapV2FactoryCalls::setFeeToSetter)
                            }
                            setFeeToSetter
                        },
                        {
                            fn createPair(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<UniswapV2FactoryCalls> {
                                <createPairCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(UniswapV2FactoryCalls::createPair)
                            }
                            createPair
                        },
                        {
                            fn getPair(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<UniswapV2FactoryCalls> {
                                <getPairCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(UniswapV2FactoryCalls::getPair)
                            }
                            getPair
                        },
                        {
                            fn setFeeTo(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<UniswapV2FactoryCalls> {
                                <setFeeToCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(UniswapV2FactoryCalls::setFeeTo)
                            }
                            setFeeTo
                        },
                    ];
                    let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                        return Err(
                            alloy_sol_types::Error::unknown_selector(
                                <Self as alloy_sol_types::SolInterface>::NAME,
                                selector,
                            ),
                        );
                    };
                    (unsafe { DECODE_SHIMS.get_unchecked(idx) })(data, validate)
                }
                #[inline]
                fn abi_encoded_size(&self) -> usize {
                    match self {
                        Self::allPairs(inner) => {
                            <allPairsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::allPairsLength(inner) => {
                            <allPairsLengthCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::createPair(inner) => {
                            <createPairCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::feeTo(inner) => {
                            <feeToCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::feeToSetter(inner) => {
                            <feeToSetterCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::getPair(inner) => {
                            <getPairCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::setFeeTo(inner) => {
                            <setFeeToCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::setFeeToSetter(inner) => {
                            <setFeeToSetterCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                    }
                }
                #[inline]
                fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                    match self {
                        Self::allPairs(inner) => {
                            <allPairsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::allPairsLength(inner) => {
                            <allPairsLengthCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::createPair(inner) => {
                            <createPairCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::feeTo(inner) => {
                            <feeToCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::feeToSetter(inner) => {
                            <feeToSetterCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::getPair(inner) => {
                            <getPairCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::setFeeTo(inner) => {
                            <setFeeToCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::setFeeToSetter(inner) => {
                            <setFeeToSetterCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                    }
                }
            }
            ///Container for all the [`UniswapV2Factory`](self) events.
            pub enum UniswapV2FactoryEvents {
                PairCreated(PairCreated),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for UniswapV2FactoryEvents {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        UniswapV2FactoryEvents::PairCreated(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "PairCreated",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl UniswapV2FactoryEvents {
                /// All the selectors of this enum.
                ///
                /// Note that the selectors might not be in the same order as the variants.
                /// No guarantees are made about the order of the selectors.
                ///
                /// Prefer using `SolInterface` methods instead.
                pub const SELECTORS: &'static [[u8; 32usize]] = &[
                    [
                        13u8,
                        54u8,
                        72u8,
                        189u8,
                        15u8,
                        107u8,
                        168u8,
                        1u8,
                        52u8,
                        163u8,
                        59u8,
                        169u8,
                        39u8,
                        90u8,
                        197u8,
                        133u8,
                        217u8,
                        211u8,
                        21u8,
                        240u8,
                        173u8,
                        131u8,
                        85u8,
                        205u8,
                        222u8,
                        253u8,
                        227u8,
                        26u8,
                        250u8,
                        40u8,
                        208u8,
                        233u8,
                    ],
                ];
            }
            #[automatically_derived]
            impl alloy_sol_types::SolEventInterface for UniswapV2FactoryEvents {
                const NAME: &'static str = "UniswapV2FactoryEvents";
                const COUNT: usize = 1usize;
                fn decode_raw_log(
                    topics: &[alloy_sol_types::Word],
                    data: &[u8],
                    validate: bool,
                ) -> alloy_sol_types::Result<Self> {
                    match topics.first().copied() {
                        Some(
                            <PairCreated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                        ) => {
                            <PairCreated as alloy_sol_types::SolEvent>::decode_raw_log(
                                    topics,
                                    data,
                                    validate,
                                )
                                .map(Self::PairCreated)
                        }
                        _ => {
                            alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                                name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                                log: alloy_sol_types::private::Box::new(
                                    alloy_sol_types::private::LogData::new_unchecked(
                                        topics.to_vec(),
                                        data.to_vec().into(),
                                    ),
                                ),
                            })
                        }
                    }
                }
            }
            #[automatically_derived]
            impl alloy_sol_types::private::IntoLogData for UniswapV2FactoryEvents {
                fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                    match self {
                        Self::PairCreated(inner) => {
                            alloy_sol_types::private::IntoLogData::to_log_data(inner)
                        }
                    }
                }
                fn into_log_data(self) -> alloy_sol_types::private::LogData {
                    match self {
                        Self::PairCreated(inner) => {
                            alloy_sol_types::private::IntoLogData::into_log_data(inner)
                        }
                    }
                }
            }
            use ::alloy::contract as alloy_contract;
            /**Creates a new wrapper around an on-chain [`UniswapV2Factory`](self) contract instance.

See the [wrapper's documentation](`UniswapV2FactoryInstance`) for more details.*/
            #[inline]
            pub const fn new<
                T: alloy_contract::private::Transport + ::core::clone::Clone,
                P: alloy_contract::private::Provider<T, N>,
                N: alloy_contract::private::Network,
            >(
                address: alloy_sol_types::private::Address,
                provider: P,
            ) -> UniswapV2FactoryInstance<T, P, N> {
                UniswapV2FactoryInstance::<T, P, N>::new(address, provider)
            }
            /**A [`UniswapV2Factory`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`UniswapV2Factory`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
            pub struct UniswapV2FactoryInstance<
                T,
                P,
                N = alloy_contract::private::Ethereum,
            > {
                address: alloy_sol_types::private::Address,
                provider: P,
                _network_transport: ::core::marker::PhantomData<(N, T)>,
            }
            #[automatically_derived]
            impl<
                T: ::core::clone::Clone,
                P: ::core::clone::Clone,
                N: ::core::clone::Clone,
            > ::core::clone::Clone for UniswapV2FactoryInstance<T, P, N> {
                #[inline]
                fn clone(&self) -> UniswapV2FactoryInstance<T, P, N> {
                    UniswapV2FactoryInstance {
                        address: ::core::clone::Clone::clone(&self.address),
                        provider: ::core::clone::Clone::clone(&self.provider),
                        _network_transport: ::core::clone::Clone::clone(
                            &self._network_transport,
                        ),
                    }
                }
            }
            #[automatically_derived]
            impl<T, P, N> ::core::fmt::Debug for UniswapV2FactoryInstance<T, P, N> {
                #[inline]
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_tuple("UniswapV2FactoryInstance")
                        .field(&self.address)
                        .finish()
                }
            }
            /// Instantiation and getters/setters.
            #[automatically_derived]
            impl<
                T: alloy_contract::private::Transport + ::core::clone::Clone,
                P: alloy_contract::private::Provider<T, N>,
                N: alloy_contract::private::Network,
            > UniswapV2FactoryInstance<T, P, N> {
                /**Creates a new wrapper around an on-chain [`UniswapV2Factory`](self) contract instance.

See the [wrapper's documentation](`UniswapV2FactoryInstance`) for more details.*/
                #[inline]
                pub const fn new(
                    address: alloy_sol_types::private::Address,
                    provider: P,
                ) -> Self {
                    Self {
                        address,
                        provider,
                        _network_transport: ::core::marker::PhantomData,
                    }
                }
                /// Returns a reference to the address.
                #[inline]
                pub const fn address(&self) -> &alloy_sol_types::private::Address {
                    &self.address
                }
                /// Sets the address.
                #[inline]
                pub fn set_address(
                    &mut self,
                    address: alloy_sol_types::private::Address,
                ) {
                    self.address = address;
                }
                /// Sets the address and returns `self`.
                pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
                    self.set_address(address);
                    self
                }
                /// Returns a reference to the provider.
                #[inline]
                pub const fn provider(&self) -> &P {
                    &self.provider
                }
            }
            impl<T, P: ::core::clone::Clone, N> UniswapV2FactoryInstance<T, &P, N> {
                /// Clones the provider and returns a new instance with the cloned provider.
                #[inline]
                pub fn with_cloned_provider(self) -> UniswapV2FactoryInstance<T, P, N> {
                    UniswapV2FactoryInstance {
                        address: self.address,
                        provider: ::core::clone::Clone::clone(&self.provider),
                        _network_transport: ::core::marker::PhantomData,
                    }
                }
            }
            /// Function calls.
            #[automatically_derived]
            impl<
                T: alloy_contract::private::Transport + ::core::clone::Clone,
                P: alloy_contract::private::Provider<T, N>,
                N: alloy_contract::private::Network,
            > UniswapV2FactoryInstance<T, P, N> {
                /// Creates a new call builder using this contract instance's provider and address.
                ///
                /// Note that the call can be any function call, not just those defined in this
                /// contract. Prefer using the other methods for building type-safe contract calls.
                pub fn call_builder<C: alloy_sol_types::SolCall>(
                    &self,
                    call: &C,
                ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
                    alloy_contract::SolCallBuilder::new_sol(
                        &self.provider,
                        &self.address,
                        call,
                    )
                }
                ///Creates a new call builder for the [`allPairs`] function.
                pub fn allPairs(
                    &self,
                    _0: ::alloy::sol_types::private::U256,
                ) -> alloy_contract::SolCallBuilder<T, &P, allPairsCall, N> {
                    self.call_builder(&allPairsCall { _0 })
                }
                ///Creates a new call builder for the [`allPairsLength`] function.
                pub fn allPairsLength(
                    &self,
                ) -> alloy_contract::SolCallBuilder<T, &P, allPairsLengthCall, N> {
                    self.call_builder(&allPairsLengthCall {})
                }
                ///Creates a new call builder for the [`createPair`] function.
                pub fn createPair(
                    &self,
                    tokenA: ::alloy::sol_types::private::Address,
                    tokenB: ::alloy::sol_types::private::Address,
                ) -> alloy_contract::SolCallBuilder<T, &P, createPairCall, N> {
                    self.call_builder(&createPairCall { tokenA, tokenB })
                }
                ///Creates a new call builder for the [`feeTo`] function.
                pub fn feeTo(
                    &self,
                ) -> alloy_contract::SolCallBuilder<T, &P, feeToCall, N> {
                    self.call_builder(&feeToCall {})
                }
                ///Creates a new call builder for the [`feeToSetter`] function.
                pub fn feeToSetter(
                    &self,
                ) -> alloy_contract::SolCallBuilder<T, &P, feeToSetterCall, N> {
                    self.call_builder(&feeToSetterCall {})
                }
                ///Creates a new call builder for the [`getPair`] function.
                pub fn getPair(
                    &self,
                    _0: ::alloy::sol_types::private::Address,
                    _1: ::alloy::sol_types::private::Address,
                ) -> alloy_contract::SolCallBuilder<T, &P, getPairCall, N> {
                    self.call_builder(&getPairCall { _0, _1 })
                }
                ///Creates a new call builder for the [`setFeeTo`] function.
                pub fn setFeeTo(
                    &self,
                    _feeTo: ::alloy::sol_types::private::Address,
                ) -> alloy_contract::SolCallBuilder<T, &P, setFeeToCall, N> {
                    self.call_builder(&setFeeToCall { _feeTo })
                }
                ///Creates a new call builder for the [`setFeeToSetter`] function.
                pub fn setFeeToSetter(
                    &self,
                    _feeToSetter: ::alloy::sol_types::private::Address,
                ) -> alloy_contract::SolCallBuilder<T, &P, setFeeToSetterCall, N> {
                    self.call_builder(&setFeeToSetterCall { _feeToSetter })
                }
            }
            /// Event filters.
            #[automatically_derived]
            impl<
                T: alloy_contract::private::Transport + ::core::clone::Clone,
                P: alloy_contract::private::Provider<T, N>,
                N: alloy_contract::private::Network,
            > UniswapV2FactoryInstance<T, P, N> {
                /// Creates a new event filter using this contract instance's provider and address.
                ///
                /// Note that the type can be any event, not just those defined in this contract.
                /// Prefer using the other methods for building type-safe event filters.
                pub fn event_filter<E: alloy_sol_types::SolEvent>(
                    &self,
                ) -> alloy_contract::Event<T, &P, E, N> {
                    alloy_contract::Event::new_sol(&self.provider, &self.address)
                }
                ///Creates a new event filter for the [`PairCreated`] event.
                pub fn PairCreated_filter(
                    &self,
                ) -> alloy_contract::Event<T, &P, PairCreated, N> {
                    self.event_filter::<PairCreated>()
                }
            }
        }
        const _: &'static [u8] = b"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"indexed\":true,\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"}],\"name\":\"FeeAmountEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"PoolCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"}],\"name\":\"createPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"}],\"name\":\"enableFeeAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"name\":\"feeAmountTickSpacing\",\"outputs\":[{\"internalType\":\"int24\",\"name\":\"\",\"type\":\"int24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"name\":\"getPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"parameters\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]";
        /**

Generated by the following Solidity interface...
```solidity
interface UniswapV3Factory {
    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);
    event OwnerChanged(address indexed oldOwner, address indexed newOwner);
    event PoolCreated(address indexed token0, address indexed token1, uint24 indexed fee, int24 tickSpacing, address pool);

    constructor();

    function createPool(address tokenA, address tokenB, uint24 fee) external returns (address pool);
    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;
    function feeAmountTickSpacing(uint24) external view returns (int24);
    function getPool(address, address, uint24) external view returns (address);
    function owner() external view returns (address);
    function parameters() external view returns (address factory, address token0, address token1, uint24 fee, int24 tickSpacing);
    function setOwner(address _owner) external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "createPool",
    "inputs": [
      {
        "name": "tokenA",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "tokenB",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "fee",
        "type": "uint24",
        "internalType": "uint24"
      }
    ],
    "outputs": [
      {
        "name": "pool",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "enableFeeAmount",
    "inputs": [
      {
        "name": "fee",
        "type": "uint24",
        "internalType": "uint24"
      },
      {
        "name": "tickSpacing",
        "type": "int24",
        "internalType": "int24"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "feeAmountTickSpacing",
    "inputs": [
      {
        "name": "",
        "type": "uint24",
        "internalType": "uint24"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "int24",
        "internalType": "int24"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getPool",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "",
        "type": "uint24",
        "internalType": "uint24"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "owner",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "parameters",
    "inputs": [],
    "outputs": [
      {
        "name": "factory",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "token0",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "token1",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "fee",
        "type": "uint24",
        "internalType": "uint24"
      },
      {
        "name": "tickSpacing",
        "type": "int24",
        "internalType": "int24"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "setOwner",
    "inputs": [
      {
        "name": "_owner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "FeeAmountEnabled",
    "inputs": [
      {
        "name": "fee",
        "type": "uint24",
        "indexed": true,
        "internalType": "uint24"
      },
      {
        "name": "tickSpacing",
        "type": "int24",
        "indexed": true,
        "internalType": "int24"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OwnerChanged",
    "inputs": [
      {
        "name": "oldOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "PoolCreated",
    "inputs": [
      {
        "name": "token0",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "token1",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "fee",
        "type": "uint24",
        "indexed": true,
        "internalType": "uint24"
      },
      {
        "name": "tickSpacing",
        "type": "int24",
        "indexed": false,
        "internalType": "int24"
      },
      {
        "name": "pool",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  }
]
```*/
        #[allow(non_camel_case_types, non_snake_case, clippy::style)]
        pub mod UniswapV3Factory {
            use super::*;
            use ::alloy::sol_types as alloy_sol_types;
            /**Event with signature `FeeAmountEnabled(uint24,int24)` and selector `0xc66a3fdf07232cdd185febcc6579d408c241b47ae2f9907d84be655141eeaecc`.
```solidity
event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);
```*/
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            pub struct FeeAmountEnabled {
                #[allow(missing_docs)]
                pub fee: <::alloy::sol_types::sol_data::Uint<
                    24,
                > as ::alloy::sol_types::SolType>::RustType,
                #[allow(missing_docs)]
                pub tickSpacing: <::alloy::sol_types::sol_data::Int<
                    24,
                > as ::alloy::sol_types::SolType>::RustType,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            impl ::core::clone::Clone for FeeAmountEnabled {
                #[inline]
                fn clone(&self) -> FeeAmountEnabled {
                    FeeAmountEnabled {
                        fee: ::core::clone::Clone::clone(&self.fee),
                        tickSpacing: ::core::clone::Clone::clone(&self.tickSpacing),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            impl ::core::fmt::Debug for FeeAmountEnabled {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "FeeAmountEnabled",
                        "fee",
                        &self.fee,
                        "tickSpacing",
                        &&self.tickSpacing,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                #[automatically_derived]
                impl alloy_sol_types::SolEvent for FeeAmountEnabled {
                    type DataTuple<'a> = ();
                    type DataToken<'a> = <Self::DataTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type TopicList = (
                        alloy_sol_types::sol_data::FixedBytes<32>,
                        ::alloy::sol_types::sol_data::Uint<24>,
                        ::alloy::sol_types::sol_data::Int<24>,
                    );
                    const SIGNATURE: &'static str = "FeeAmountEnabled(uint24,int24)";
                    const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                        198u8,
                        106u8,
                        63u8,
                        223u8,
                        7u8,
                        35u8,
                        44u8,
                        221u8,
                        24u8,
                        95u8,
                        235u8,
                        204u8,
                        101u8,
                        121u8,
                        212u8,
                        8u8,
                        194u8,
                        65u8,
                        180u8,
                        122u8,
                        226u8,
                        249u8,
                        144u8,
                        125u8,
                        132u8,
                        190u8,
                        101u8,
                        81u8,
                        65u8,
                        238u8,
                        174u8,
                        204u8,
                    ]);
                    const ANONYMOUS: bool = false;
                    #[allow(unused_variables)]
                    #[inline]
                    fn new(
                        topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                        data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        Self {
                            fee: topics.1,
                            tickSpacing: topics.2,
                        }
                    }
                    #[inline]
                    fn tokenize_body(&self) -> Self::DataToken<'_> {
                        ()
                    }
                    #[inline]
                    fn topics(
                        &self,
                    ) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                        (
                            Self::SIGNATURE_HASH.into(),
                            self.fee.clone(),
                            self.tickSpacing.clone(),
                        )
                    }
                    #[inline]
                    fn encode_topics_raw(
                        &self,
                        out: &mut [alloy_sol_types::abi::token::WordToken],
                    ) -> alloy_sol_types::Result<()> {
                        if out.len()
                            < <Self::TopicList as alloy_sol_types::TopicList>::COUNT
                        {
                            return Err(alloy_sol_types::Error::Overrun);
                        }
                        out[0usize] = alloy_sol_types::abi::token::WordToken(
                            Self::SIGNATURE_HASH,
                        );
                        out[1usize] = <::alloy::sol_types::sol_data::Uint<
                            24,
                        > as alloy_sol_types::EventTopic>::encode_topic(&self.fee);
                        out[2usize] = <::alloy::sol_types::sol_data::Int<
                            24,
                        > as alloy_sol_types::EventTopic>::encode_topic(
                            &self.tickSpacing,
                        );
                        Ok(())
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::private::IntoLogData for FeeAmountEnabled {
                    fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                        From::from(self)
                    }
                    fn into_log_data(self) -> alloy_sol_types::private::LogData {
                        From::from(&self)
                    }
                }
                #[automatically_derived]
                impl From<&FeeAmountEnabled> for alloy_sol_types::private::LogData {
                    #[inline]
                    fn from(
                        this: &FeeAmountEnabled,
                    ) -> alloy_sol_types::private::LogData {
                        alloy_sol_types::SolEvent::encode_log_data(this)
                    }
                }
            };
            /**Event with signature `OwnerChanged(address,address)` and selector `0xb532073b38c83145e3e5135377a08bf9aab55bc0fd7c1179cd4fb995d2a5159c`.
```solidity
event OwnerChanged(address indexed oldOwner, address indexed newOwner);
```*/
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            pub struct OwnerChanged {
                #[allow(missing_docs)]
                pub oldOwner: ::alloy::sol_types::private::Address,
                #[allow(missing_docs)]
                pub newOwner: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            impl ::core::clone::Clone for OwnerChanged {
                #[inline]
                fn clone(&self) -> OwnerChanged {
                    OwnerChanged {
                        oldOwner: ::core::clone::Clone::clone(&self.oldOwner),
                        newOwner: ::core::clone::Clone::clone(&self.newOwner),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            impl ::core::fmt::Debug for OwnerChanged {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "OwnerChanged",
                        "oldOwner",
                        &self.oldOwner,
                        "newOwner",
                        &&self.newOwner,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                #[automatically_derived]
                impl alloy_sol_types::SolEvent for OwnerChanged {
                    type DataTuple<'a> = ();
                    type DataToken<'a> = <Self::DataTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type TopicList = (
                        alloy_sol_types::sol_data::FixedBytes<32>,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                    );
                    const SIGNATURE: &'static str = "OwnerChanged(address,address)";
                    const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                        181u8,
                        50u8,
                        7u8,
                        59u8,
                        56u8,
                        200u8,
                        49u8,
                        69u8,
                        227u8,
                        229u8,
                        19u8,
                        83u8,
                        119u8,
                        160u8,
                        139u8,
                        249u8,
                        170u8,
                        181u8,
                        91u8,
                        192u8,
                        253u8,
                        124u8,
                        17u8,
                        121u8,
                        205u8,
                        79u8,
                        185u8,
                        149u8,
                        210u8,
                        165u8,
                        21u8,
                        156u8,
                    ]);
                    const ANONYMOUS: bool = false;
                    #[allow(unused_variables)]
                    #[inline]
                    fn new(
                        topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                        data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        Self {
                            oldOwner: topics.1,
                            newOwner: topics.2,
                        }
                    }
                    #[inline]
                    fn tokenize_body(&self) -> Self::DataToken<'_> {
                        ()
                    }
                    #[inline]
                    fn topics(
                        &self,
                    ) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                        (
                            Self::SIGNATURE_HASH.into(),
                            self.oldOwner.clone(),
                            self.newOwner.clone(),
                        )
                    }
                    #[inline]
                    fn encode_topics_raw(
                        &self,
                        out: &mut [alloy_sol_types::abi::token::WordToken],
                    ) -> alloy_sol_types::Result<()> {
                        if out.len()
                            < <Self::TopicList as alloy_sol_types::TopicList>::COUNT
                        {
                            return Err(alloy_sol_types::Error::Overrun);
                        }
                        out[0usize] = alloy_sol_types::abi::token::WordToken(
                            Self::SIGNATURE_HASH,
                        );
                        out[1usize] = <::alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                            &self.oldOwner,
                        );
                        out[2usize] = <::alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                            &self.newOwner,
                        );
                        Ok(())
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::private::IntoLogData for OwnerChanged {
                    fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                        From::from(self)
                    }
                    fn into_log_data(self) -> alloy_sol_types::private::LogData {
                        From::from(&self)
                    }
                }
                #[automatically_derived]
                impl From<&OwnerChanged> for alloy_sol_types::private::LogData {
                    #[inline]
                    fn from(this: &OwnerChanged) -> alloy_sol_types::private::LogData {
                        alloy_sol_types::SolEvent::encode_log_data(this)
                    }
                }
            };
            /**Event with signature `PoolCreated(address,address,uint24,int24,address)` and selector `0x783cca1c0412dd0d695e784568c96da2e9c22ff989357a2e8b1d9b2b4e6b7118`.
```solidity
event PoolCreated(address indexed token0, address indexed token1, uint24 indexed fee, int24 tickSpacing, address pool);
```*/
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            pub struct PoolCreated {
                #[allow(missing_docs)]
                pub token0: ::alloy::sol_types::private::Address,
                #[allow(missing_docs)]
                pub token1: ::alloy::sol_types::private::Address,
                #[allow(missing_docs)]
                pub fee: <::alloy::sol_types::sol_data::Uint<
                    24,
                > as ::alloy::sol_types::SolType>::RustType,
                #[allow(missing_docs)]
                pub tickSpacing: <::alloy::sol_types::sol_data::Int<
                    24,
                > as ::alloy::sol_types::SolType>::RustType,
                #[allow(missing_docs)]
                pub pool: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            impl ::core::clone::Clone for PoolCreated {
                #[inline]
                fn clone(&self) -> PoolCreated {
                    PoolCreated {
                        token0: ::core::clone::Clone::clone(&self.token0),
                        token1: ::core::clone::Clone::clone(&self.token1),
                        fee: ::core::clone::Clone::clone(&self.fee),
                        tickSpacing: ::core::clone::Clone::clone(&self.tickSpacing),
                        pool: ::core::clone::Clone::clone(&self.pool),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            impl ::core::fmt::Debug for PoolCreated {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "PoolCreated",
                        "token0",
                        &self.token0,
                        "token1",
                        &self.token1,
                        "fee",
                        &self.fee,
                        "tickSpacing",
                        &self.tickSpacing,
                        "pool",
                        &&self.pool,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                #[automatically_derived]
                impl alloy_sol_types::SolEvent for PoolCreated {
                    type DataTuple<'a> = (
                        ::alloy::sol_types::sol_data::Int<24>,
                        ::alloy::sol_types::sol_data::Address,
                    );
                    type DataToken<'a> = <Self::DataTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type TopicList = (
                        alloy_sol_types::sol_data::FixedBytes<32>,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Uint<24>,
                    );
                    const SIGNATURE: &'static str = "PoolCreated(address,address,uint24,int24,address)";
                    const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                        120u8,
                        60u8,
                        202u8,
                        28u8,
                        4u8,
                        18u8,
                        221u8,
                        13u8,
                        105u8,
                        94u8,
                        120u8,
                        69u8,
                        104u8,
                        201u8,
                        109u8,
                        162u8,
                        233u8,
                        194u8,
                        47u8,
                        249u8,
                        137u8,
                        53u8,
                        122u8,
                        46u8,
                        139u8,
                        29u8,
                        155u8,
                        43u8,
                        78u8,
                        107u8,
                        113u8,
                        24u8,
                    ]);
                    const ANONYMOUS: bool = false;
                    #[allow(unused_variables)]
                    #[inline]
                    fn new(
                        topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                        data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        Self {
                            token0: topics.1,
                            token1: topics.2,
                            fee: topics.3,
                            tickSpacing: data.0,
                            pool: data.1,
                        }
                    }
                    #[inline]
                    fn tokenize_body(&self) -> Self::DataToken<'_> {
                        (
                            <::alloy::sol_types::sol_data::Int<
                                24,
                            > as alloy_sol_types::SolType>::tokenize(&self.tickSpacing),
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self.pool,
                            ),
                        )
                    }
                    #[inline]
                    fn topics(
                        &self,
                    ) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                        (
                            Self::SIGNATURE_HASH.into(),
                            self.token0.clone(),
                            self.token1.clone(),
                            self.fee.clone(),
                        )
                    }
                    #[inline]
                    fn encode_topics_raw(
                        &self,
                        out: &mut [alloy_sol_types::abi::token::WordToken],
                    ) -> alloy_sol_types::Result<()> {
                        if out.len()
                            < <Self::TopicList as alloy_sol_types::TopicList>::COUNT
                        {
                            return Err(alloy_sol_types::Error::Overrun);
                        }
                        out[0usize] = alloy_sol_types::abi::token::WordToken(
                            Self::SIGNATURE_HASH,
                        );
                        out[1usize] = <::alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                            &self.token0,
                        );
                        out[2usize] = <::alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                            &self.token1,
                        );
                        out[3usize] = <::alloy::sol_types::sol_data::Uint<
                            24,
                        > as alloy_sol_types::EventTopic>::encode_topic(&self.fee);
                        Ok(())
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::private::IntoLogData for PoolCreated {
                    fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                        From::from(self)
                    }
                    fn into_log_data(self) -> alloy_sol_types::private::LogData {
                        From::from(&self)
                    }
                }
                #[automatically_derived]
                impl From<&PoolCreated> for alloy_sol_types::private::LogData {
                    #[inline]
                    fn from(this: &PoolCreated) -> alloy_sol_types::private::LogData {
                        alloy_sol_types::SolEvent::encode_log_data(this)
                    }
                }
            };
            /**Constructor`.
```solidity
constructor();
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct constructorCall {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for constructorCall {
                #[inline]
                fn clone(&self) -> constructorCall {
                    constructorCall {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for constructorCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "constructorCall")
                }
            }
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<constructorCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: constructorCall) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for constructorCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolConstructor for constructorCall {
                    type Parameters<'a> = ();
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                }
            };
            /**Function with signature `createPool(address,address,uint24)` and selector `0xa1671295`.
```solidity
function createPool(address tokenA, address tokenB, uint24 fee) external returns (address pool);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct createPoolCall {
                pub tokenA: ::alloy::sol_types::private::Address,
                pub tokenB: ::alloy::sol_types::private::Address,
                pub fee: <::alloy::sol_types::sol_data::Uint<
                    24,
                > as ::alloy::sol_types::SolType>::RustType,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for createPoolCall {
                #[inline]
                fn clone(&self) -> createPoolCall {
                    createPoolCall {
                        tokenA: ::core::clone::Clone::clone(&self.tokenA),
                        tokenB: ::core::clone::Clone::clone(&self.tokenB),
                        fee: ::core::clone::Clone::clone(&self.fee),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for createPoolCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "createPoolCall",
                        "tokenA",
                        &self.tokenA,
                        "tokenB",
                        &self.tokenB,
                        "fee",
                        &&self.fee,
                    )
                }
            }
            ///Container type for the return parameters of the [`createPool(address,address,uint24)`](createPoolCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct createPoolReturn {
                pub pool: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for createPoolReturn {
                #[inline]
                fn clone(&self) -> createPoolReturn {
                    createPoolReturn {
                        pool: ::core::clone::Clone::clone(&self.pool),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for createPoolReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "createPoolReturn",
                        "pool",
                        &&self.pool,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Uint<24>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                        ::alloy::sol_types::private::Address,
                        <::alloy::sol_types::sol_data::Uint<
                            24,
                        > as ::alloy::sol_types::SolType>::RustType,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<createPoolCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: createPoolCall) -> Self {
                            (value.tokenA, value.tokenB, value.fee)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for createPoolCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {
                                tokenA: tuple.0,
                                tokenB: tuple.1,
                                fee: tuple.2,
                            }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<createPoolReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: createPoolReturn) -> Self {
                            (value.pool,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for createPoolReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { pool: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for createPoolCall {
                    type Parameters<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Uint<24>,
                    );
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = createPoolReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Address,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "createPool(address,address,uint24)";
                    const SELECTOR: [u8; 4] = [161u8, 103u8, 18u8, 149u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self.tokenA,
                            ),
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self.tokenB,
                            ),
                            <::alloy::sol_types::sol_data::Uint<
                                24,
                            > as alloy_sol_types::SolType>::tokenize(&self.fee),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `enableFeeAmount(uint24,int24)` and selector `0x8a7c195f`.
```solidity
function enableFeeAmount(uint24 fee, int24 tickSpacing) external;
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct enableFeeAmountCall {
                pub fee: <::alloy::sol_types::sol_data::Uint<
                    24,
                > as ::alloy::sol_types::SolType>::RustType,
                pub tickSpacing: <::alloy::sol_types::sol_data::Int<
                    24,
                > as ::alloy::sol_types::SolType>::RustType,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for enableFeeAmountCall {
                #[inline]
                fn clone(&self) -> enableFeeAmountCall {
                    enableFeeAmountCall {
                        fee: ::core::clone::Clone::clone(&self.fee),
                        tickSpacing: ::core::clone::Clone::clone(&self.tickSpacing),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for enableFeeAmountCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "enableFeeAmountCall",
                        "fee",
                        &self.fee,
                        "tickSpacing",
                        &&self.tickSpacing,
                    )
                }
            }
            ///Container type for the return parameters of the [`enableFeeAmount(uint24,int24)`](enableFeeAmountCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct enableFeeAmountReturn {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for enableFeeAmountReturn {
                #[inline]
                fn clone(&self) -> enableFeeAmountReturn {
                    enableFeeAmountReturn {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for enableFeeAmountReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "enableFeeAmountReturn")
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Uint<24>,
                        ::alloy::sol_types::sol_data::Int<24>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        <::alloy::sol_types::sol_data::Uint<
                            24,
                        > as ::alloy::sol_types::SolType>::RustType,
                        <::alloy::sol_types::sol_data::Int<
                            24,
                        > as ::alloy::sol_types::SolType>::RustType,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<enableFeeAmountCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: enableFeeAmountCall) -> Self {
                            (value.fee, value.tickSpacing)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for enableFeeAmountCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {
                                fee: tuple.0,
                                tickSpacing: tuple.1,
                            }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<enableFeeAmountReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: enableFeeAmountReturn) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for enableFeeAmountReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for enableFeeAmountCall {
                    type Parameters<'a> = (
                        ::alloy::sol_types::sol_data::Uint<24>,
                        ::alloy::sol_types::sol_data::Int<24>,
                    );
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = enableFeeAmountReturn;
                    type ReturnTuple<'a> = ();
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "enableFeeAmount(uint24,int24)";
                    const SELECTOR: [u8; 4] = [138u8, 124u8, 25u8, 95u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Uint<
                                24,
                            > as alloy_sol_types::SolType>::tokenize(&self.fee),
                            <::alloy::sol_types::sol_data::Int<
                                24,
                            > as alloy_sol_types::SolType>::tokenize(&self.tickSpacing),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `feeAmountTickSpacing(uint24)` and selector `0x22afcccb`.
```solidity
function feeAmountTickSpacing(uint24) external view returns (int24);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct feeAmountTickSpacingCall {
                pub _0: <::alloy::sol_types::sol_data::Uint<
                    24,
                > as ::alloy::sol_types::SolType>::RustType,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for feeAmountTickSpacingCall {
                #[inline]
                fn clone(&self) -> feeAmountTickSpacingCall {
                    feeAmountTickSpacingCall {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for feeAmountTickSpacingCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "feeAmountTickSpacingCall",
                        "_0",
                        &&self._0,
                    )
                }
            }
            ///Container type for the return parameters of the [`feeAmountTickSpacing(uint24)`](feeAmountTickSpacingCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct feeAmountTickSpacingReturn {
                pub _0: <::alloy::sol_types::sol_data::Int<
                    24,
                > as ::alloy::sol_types::SolType>::RustType,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for feeAmountTickSpacingReturn {
                #[inline]
                fn clone(&self) -> feeAmountTickSpacingReturn {
                    feeAmountTickSpacingReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for feeAmountTickSpacingReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "feeAmountTickSpacingReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Uint<24>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        <::alloy::sol_types::sol_data::Uint<
                            24,
                        > as ::alloy::sol_types::SolType>::RustType,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<feeAmountTickSpacingCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: feeAmountTickSpacingCall) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for feeAmountTickSpacingCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Int<24>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        <::alloy::sol_types::sol_data::Int<
                            24,
                        > as ::alloy::sol_types::SolType>::RustType,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<feeAmountTickSpacingReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: feeAmountTickSpacingReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for feeAmountTickSpacingReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for feeAmountTickSpacingCall {
                    type Parameters<'a> = (::alloy::sol_types::sol_data::Uint<24>,);
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = feeAmountTickSpacingReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Int<24>,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "feeAmountTickSpacing(uint24)";
                    const SELECTOR: [u8; 4] = [34u8, 175u8, 204u8, 203u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Uint<
                                24,
                            > as alloy_sol_types::SolType>::tokenize(&self._0),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `getPool(address,address,uint24)` and selector `0x1698ee82`.
```solidity
function getPool(address, address, uint24) external view returns (address);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct getPoolCall {
                pub _0: ::alloy::sol_types::private::Address,
                pub _1: ::alloy::sol_types::private::Address,
                pub _2: <::alloy::sol_types::sol_data::Uint<
                    24,
                > as ::alloy::sol_types::SolType>::RustType,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for getPoolCall {
                #[inline]
                fn clone(&self) -> getPoolCall {
                    getPoolCall {
                        _0: ::core::clone::Clone::clone(&self._0),
                        _1: ::core::clone::Clone::clone(&self._1),
                        _2: ::core::clone::Clone::clone(&self._2),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for getPoolCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "getPoolCall",
                        "_0",
                        &self._0,
                        "_1",
                        &self._1,
                        "_2",
                        &&self._2,
                    )
                }
            }
            ///Container type for the return parameters of the [`getPool(address,address,uint24)`](getPoolCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct getPoolReturn {
                pub _0: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for getPoolReturn {
                #[inline]
                fn clone(&self) -> getPoolReturn {
                    getPoolReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for getPoolReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "getPoolReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Uint<24>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                        ::alloy::sol_types::private::Address,
                        <::alloy::sol_types::sol_data::Uint<
                            24,
                        > as ::alloy::sol_types::SolType>::RustType,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<getPoolCall> for UnderlyingRustTuple<'_> {
                        fn from(value: getPoolCall) -> Self {
                            (value._0, value._1, value._2)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>> for getPoolCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {
                                _0: tuple.0,
                                _1: tuple.1,
                                _2: tuple.2,
                            }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<getPoolReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: getPoolReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for getPoolReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for getPoolCall {
                    type Parameters<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Uint<24>,
                    );
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = getPoolReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Address,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "getPool(address,address,uint24)";
                    const SELECTOR: [u8; 4] = [22u8, 152u8, 238u8, 130u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self._0,
                            ),
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self._1,
                            ),
                            <::alloy::sol_types::sol_data::Uint<
                                24,
                            > as alloy_sol_types::SolType>::tokenize(&self._2),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `owner()` and selector `0x8da5cb5b`.
```solidity
function owner() external view returns (address);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct ownerCall {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for ownerCall {
                #[inline]
                fn clone(&self) -> ownerCall {
                    ownerCall {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for ownerCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "ownerCall")
                }
            }
            ///Container type for the return parameters of the [`owner()`](ownerCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct ownerReturn {
                pub _0: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for ownerReturn {
                #[inline]
                fn clone(&self) -> ownerReturn {
                    ownerReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for ownerReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "ownerReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<ownerCall> for UnderlyingRustTuple<'_> {
                        fn from(value: ownerCall) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<ownerReturn> for UnderlyingRustTuple<'_> {
                        fn from(value: ownerReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for ownerCall {
                    type Parameters<'a> = ();
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = ownerReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Address,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "owner()";
                    const SELECTOR: [u8; 4] = [141u8, 165u8, 203u8, 91u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `parameters()` and selector `0x89035730`.
```solidity
function parameters() external view returns (address factory, address token0, address token1, uint24 fee, int24 tickSpacing);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct parametersCall {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for parametersCall {
                #[inline]
                fn clone(&self) -> parametersCall {
                    parametersCall {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for parametersCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "parametersCall")
                }
            }
            ///Container type for the return parameters of the [`parameters()`](parametersCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct parametersReturn {
                pub factory: ::alloy::sol_types::private::Address,
                pub token0: ::alloy::sol_types::private::Address,
                pub token1: ::alloy::sol_types::private::Address,
                pub fee: <::alloy::sol_types::sol_data::Uint<
                    24,
                > as ::alloy::sol_types::SolType>::RustType,
                pub tickSpacing: <::alloy::sol_types::sol_data::Int<
                    24,
                > as ::alloy::sol_types::SolType>::RustType,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for parametersReturn {
                #[inline]
                fn clone(&self) -> parametersReturn {
                    parametersReturn {
                        factory: ::core::clone::Clone::clone(&self.factory),
                        token0: ::core::clone::Clone::clone(&self.token0),
                        token1: ::core::clone::Clone::clone(&self.token1),
                        fee: ::core::clone::Clone::clone(&self.fee),
                        tickSpacing: ::core::clone::Clone::clone(&self.tickSpacing),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for parametersReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "parametersReturn",
                        "factory",
                        &self.factory,
                        "token0",
                        &self.token0,
                        "token1",
                        &self.token1,
                        "fee",
                        &self.fee,
                        "tickSpacing",
                        &&self.tickSpacing,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<parametersCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: parametersCall) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for parametersCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Uint<24>,
                        ::alloy::sol_types::sol_data::Int<24>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                        ::alloy::sol_types::private::Address,
                        ::alloy::sol_types::private::Address,
                        <::alloy::sol_types::sol_data::Uint<
                            24,
                        > as ::alloy::sol_types::SolType>::RustType,
                        <::alloy::sol_types::sol_data::Int<
                            24,
                        > as ::alloy::sol_types::SolType>::RustType,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<parametersReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: parametersReturn) -> Self {
                            (
                                value.factory,
                                value.token0,
                                value.token1,
                                value.fee,
                                value.tickSpacing,
                            )
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for parametersReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {
                                factory: tuple.0,
                                token0: tuple.1,
                                token1: tuple.2,
                                fee: tuple.3,
                                tickSpacing: tuple.4,
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for parametersCall {
                    type Parameters<'a> = ();
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = parametersReturn;
                    type ReturnTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Uint<24>,
                        ::alloy::sol_types::sol_data::Int<24>,
                    );
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "parameters()";
                    const SELECTOR: [u8; 4] = [137u8, 3u8, 87u8, 48u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `setOwner(address)` and selector `0x13af4035`.
```solidity
function setOwner(address _owner) external;
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct setOwnerCall {
                pub _owner: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for setOwnerCall {
                #[inline]
                fn clone(&self) -> setOwnerCall {
                    setOwnerCall {
                        _owner: ::core::clone::Clone::clone(&self._owner),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for setOwnerCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "setOwnerCall",
                        "_owner",
                        &&self._owner,
                    )
                }
            }
            ///Container type for the return parameters of the [`setOwner(address)`](setOwnerCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct setOwnerReturn {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for setOwnerReturn {
                #[inline]
                fn clone(&self) -> setOwnerReturn {
                    setOwnerReturn {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for setOwnerReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "setOwnerReturn")
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<setOwnerCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: setOwnerCall) -> Self {
                            (value._owner,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for setOwnerCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _owner: tuple.0 }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<setOwnerReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: setOwnerReturn) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for setOwnerReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for setOwnerCall {
                    type Parameters<'a> = (::alloy::sol_types::sol_data::Address,);
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = setOwnerReturn;
                    type ReturnTuple<'a> = ();
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "setOwner(address)";
                    const SELECTOR: [u8; 4] = [19u8, 175u8, 64u8, 53u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self._owner,
                            ),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            ///Container for all the [`UniswapV3Factory`](self) function calls.
            pub enum UniswapV3FactoryCalls {
                createPool(createPoolCall),
                enableFeeAmount(enableFeeAmountCall),
                feeAmountTickSpacing(feeAmountTickSpacingCall),
                getPool(getPoolCall),
                owner(ownerCall),
                parameters(parametersCall),
                setOwner(setOwnerCall),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for UniswapV3FactoryCalls {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        UniswapV3FactoryCalls::createPool(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "createPool",
                                &__self_0,
                            )
                        }
                        UniswapV3FactoryCalls::enableFeeAmount(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "enableFeeAmount",
                                &__self_0,
                            )
                        }
                        UniswapV3FactoryCalls::feeAmountTickSpacing(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "feeAmountTickSpacing",
                                &__self_0,
                            )
                        }
                        UniswapV3FactoryCalls::getPool(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "getPool",
                                &__self_0,
                            )
                        }
                        UniswapV3FactoryCalls::owner(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "owner",
                                &__self_0,
                            )
                        }
                        UniswapV3FactoryCalls::parameters(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "parameters",
                                &__self_0,
                            )
                        }
                        UniswapV3FactoryCalls::setOwner(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "setOwner",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl UniswapV3FactoryCalls {
                /// All the selectors of this enum.
                ///
                /// Note that the selectors might not be in the same order as the variants.
                /// No guarantees are made about the order of the selectors.
                ///
                /// Prefer using `SolInterface` methods instead.
                pub const SELECTORS: &'static [[u8; 4usize]] = &[
                    [19u8, 175u8, 64u8, 53u8],
                    [22u8, 152u8, 238u8, 130u8],
                    [34u8, 175u8, 204u8, 203u8],
                    [137u8, 3u8, 87u8, 48u8],
                    [138u8, 124u8, 25u8, 95u8],
                    [141u8, 165u8, 203u8, 91u8],
                    [161u8, 103u8, 18u8, 149u8],
                ];
            }
            #[automatically_derived]
            impl alloy_sol_types::SolInterface for UniswapV3FactoryCalls {
                const NAME: &'static str = "UniswapV3FactoryCalls";
                const MIN_DATA_LENGTH: usize = 0usize;
                const COUNT: usize = 7usize;
                #[inline]
                fn selector(&self) -> [u8; 4] {
                    match self {
                        Self::createPool(_) => {
                            <createPoolCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::enableFeeAmount(_) => {
                            <enableFeeAmountCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::feeAmountTickSpacing(_) => {
                            <feeAmountTickSpacingCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::getPool(_) => {
                            <getPoolCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::owner(_) => {
                            <ownerCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::parameters(_) => {
                            <parametersCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::setOwner(_) => {
                            <setOwnerCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                    }
                }
                #[inline]
                fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
                    Self::SELECTORS.get(i).copied()
                }
                #[inline]
                fn valid_selector(selector: [u8; 4]) -> bool {
                    Self::SELECTORS.binary_search(&selector).is_ok()
                }
                #[inline]
                #[allow(unsafe_code, non_snake_case)]
                fn abi_decode_raw(
                    selector: [u8; 4],
                    data: &[u8],
                    validate: bool,
                ) -> alloy_sol_types::Result<Self> {
                    static DECODE_SHIMS: &[fn(
                        &[u8],
                        bool,
                    ) -> alloy_sol_types::Result<UniswapV3FactoryCalls>] = &[
                        {
                            fn setOwner(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<UniswapV3FactoryCalls> {
                                <setOwnerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(UniswapV3FactoryCalls::setOwner)
                            }
                            setOwner
                        },
                        {
                            fn getPool(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<UniswapV3FactoryCalls> {
                                <getPoolCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(UniswapV3FactoryCalls::getPool)
                            }
                            getPool
                        },
                        {
                            fn feeAmountTickSpacing(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<UniswapV3FactoryCalls> {
                                <feeAmountTickSpacingCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(UniswapV3FactoryCalls::feeAmountTickSpacing)
                            }
                            feeAmountTickSpacing
                        },
                        {
                            fn parameters(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<UniswapV3FactoryCalls> {
                                <parametersCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(UniswapV3FactoryCalls::parameters)
                            }
                            parameters
                        },
                        {
                            fn enableFeeAmount(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<UniswapV3FactoryCalls> {
                                <enableFeeAmountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(UniswapV3FactoryCalls::enableFeeAmount)
                            }
                            enableFeeAmount
                        },
                        {
                            fn owner(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<UniswapV3FactoryCalls> {
                                <ownerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(UniswapV3FactoryCalls::owner)
                            }
                            owner
                        },
                        {
                            fn createPool(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<UniswapV3FactoryCalls> {
                                <createPoolCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(UniswapV3FactoryCalls::createPool)
                            }
                            createPool
                        },
                    ];
                    let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                        return Err(
                            alloy_sol_types::Error::unknown_selector(
                                <Self as alloy_sol_types::SolInterface>::NAME,
                                selector,
                            ),
                        );
                    };
                    (unsafe { DECODE_SHIMS.get_unchecked(idx) })(data, validate)
                }
                #[inline]
                fn abi_encoded_size(&self) -> usize {
                    match self {
                        Self::createPool(inner) => {
                            <createPoolCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::enableFeeAmount(inner) => {
                            <enableFeeAmountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::feeAmountTickSpacing(inner) => {
                            <feeAmountTickSpacingCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::getPool(inner) => {
                            <getPoolCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::owner(inner) => {
                            <ownerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::parameters(inner) => {
                            <parametersCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::setOwner(inner) => {
                            <setOwnerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                    }
                }
                #[inline]
                fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                    match self {
                        Self::createPool(inner) => {
                            <createPoolCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::enableFeeAmount(inner) => {
                            <enableFeeAmountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::feeAmountTickSpacing(inner) => {
                            <feeAmountTickSpacingCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::getPool(inner) => {
                            <getPoolCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::owner(inner) => {
                            <ownerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::parameters(inner) => {
                            <parametersCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::setOwner(inner) => {
                            <setOwnerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                    }
                }
            }
            ///Container for all the [`UniswapV3Factory`](self) events.
            pub enum UniswapV3FactoryEvents {
                FeeAmountEnabled(FeeAmountEnabled),
                OwnerChanged(OwnerChanged),
                PoolCreated(PoolCreated),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for UniswapV3FactoryEvents {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        UniswapV3FactoryEvents::FeeAmountEnabled(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "FeeAmountEnabled",
                                &__self_0,
                            )
                        }
                        UniswapV3FactoryEvents::OwnerChanged(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "OwnerChanged",
                                &__self_0,
                            )
                        }
                        UniswapV3FactoryEvents::PoolCreated(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "PoolCreated",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl UniswapV3FactoryEvents {
                /// All the selectors of this enum.
                ///
                /// Note that the selectors might not be in the same order as the variants.
                /// No guarantees are made about the order of the selectors.
                ///
                /// Prefer using `SolInterface` methods instead.
                pub const SELECTORS: &'static [[u8; 32usize]] = &[
                    [
                        120u8,
                        60u8,
                        202u8,
                        28u8,
                        4u8,
                        18u8,
                        221u8,
                        13u8,
                        105u8,
                        94u8,
                        120u8,
                        69u8,
                        104u8,
                        201u8,
                        109u8,
                        162u8,
                        233u8,
                        194u8,
                        47u8,
                        249u8,
                        137u8,
                        53u8,
                        122u8,
                        46u8,
                        139u8,
                        29u8,
                        155u8,
                        43u8,
                        78u8,
                        107u8,
                        113u8,
                        24u8,
                    ],
                    [
                        181u8,
                        50u8,
                        7u8,
                        59u8,
                        56u8,
                        200u8,
                        49u8,
                        69u8,
                        227u8,
                        229u8,
                        19u8,
                        83u8,
                        119u8,
                        160u8,
                        139u8,
                        249u8,
                        170u8,
                        181u8,
                        91u8,
                        192u8,
                        253u8,
                        124u8,
                        17u8,
                        121u8,
                        205u8,
                        79u8,
                        185u8,
                        149u8,
                        210u8,
                        165u8,
                        21u8,
                        156u8,
                    ],
                    [
                        198u8,
                        106u8,
                        63u8,
                        223u8,
                        7u8,
                        35u8,
                        44u8,
                        221u8,
                        24u8,
                        95u8,
                        235u8,
                        204u8,
                        101u8,
                        121u8,
                        212u8,
                        8u8,
                        194u8,
                        65u8,
                        180u8,
                        122u8,
                        226u8,
                        249u8,
                        144u8,
                        125u8,
                        132u8,
                        190u8,
                        101u8,
                        81u8,
                        65u8,
                        238u8,
                        174u8,
                        204u8,
                    ],
                ];
            }
            #[automatically_derived]
            impl alloy_sol_types::SolEventInterface for UniswapV3FactoryEvents {
                const NAME: &'static str = "UniswapV3FactoryEvents";
                const COUNT: usize = 3usize;
                fn decode_raw_log(
                    topics: &[alloy_sol_types::Word],
                    data: &[u8],
                    validate: bool,
                ) -> alloy_sol_types::Result<Self> {
                    match topics.first().copied() {
                        Some(
                            <FeeAmountEnabled as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                        ) => {
                            <FeeAmountEnabled as alloy_sol_types::SolEvent>::decode_raw_log(
                                    topics,
                                    data,
                                    validate,
                                )
                                .map(Self::FeeAmountEnabled)
                        }
                        Some(
                            <OwnerChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                        ) => {
                            <OwnerChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                                    topics,
                                    data,
                                    validate,
                                )
                                .map(Self::OwnerChanged)
                        }
                        Some(
                            <PoolCreated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                        ) => {
                            <PoolCreated as alloy_sol_types::SolEvent>::decode_raw_log(
                                    topics,
                                    data,
                                    validate,
                                )
                                .map(Self::PoolCreated)
                        }
                        _ => {
                            alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                                name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                                log: alloy_sol_types::private::Box::new(
                                    alloy_sol_types::private::LogData::new_unchecked(
                                        topics.to_vec(),
                                        data.to_vec().into(),
                                    ),
                                ),
                            })
                        }
                    }
                }
            }
            #[automatically_derived]
            impl alloy_sol_types::private::IntoLogData for UniswapV3FactoryEvents {
                fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                    match self {
                        Self::FeeAmountEnabled(inner) => {
                            alloy_sol_types::private::IntoLogData::to_log_data(inner)
                        }
                        Self::OwnerChanged(inner) => {
                            alloy_sol_types::private::IntoLogData::to_log_data(inner)
                        }
                        Self::PoolCreated(inner) => {
                            alloy_sol_types::private::IntoLogData::to_log_data(inner)
                        }
                    }
                }
                fn into_log_data(self) -> alloy_sol_types::private::LogData {
                    match self {
                        Self::FeeAmountEnabled(inner) => {
                            alloy_sol_types::private::IntoLogData::into_log_data(inner)
                        }
                        Self::OwnerChanged(inner) => {
                            alloy_sol_types::private::IntoLogData::into_log_data(inner)
                        }
                        Self::PoolCreated(inner) => {
                            alloy_sol_types::private::IntoLogData::into_log_data(inner)
                        }
                    }
                }
            }
            use ::alloy::contract as alloy_contract;
            /**Creates a new wrapper around an on-chain [`UniswapV3Factory`](self) contract instance.

See the [wrapper's documentation](`UniswapV3FactoryInstance`) for more details.*/
            #[inline]
            pub const fn new<
                T: alloy_contract::private::Transport + ::core::clone::Clone,
                P: alloy_contract::private::Provider<T, N>,
                N: alloy_contract::private::Network,
            >(
                address: alloy_sol_types::private::Address,
                provider: P,
            ) -> UniswapV3FactoryInstance<T, P, N> {
                UniswapV3FactoryInstance::<T, P, N>::new(address, provider)
            }
            /**A [`UniswapV3Factory`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`UniswapV3Factory`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
            pub struct UniswapV3FactoryInstance<
                T,
                P,
                N = alloy_contract::private::Ethereum,
            > {
                address: alloy_sol_types::private::Address,
                provider: P,
                _network_transport: ::core::marker::PhantomData<(N, T)>,
            }
            #[automatically_derived]
            impl<
                T: ::core::clone::Clone,
                P: ::core::clone::Clone,
                N: ::core::clone::Clone,
            > ::core::clone::Clone for UniswapV3FactoryInstance<T, P, N> {
                #[inline]
                fn clone(&self) -> UniswapV3FactoryInstance<T, P, N> {
                    UniswapV3FactoryInstance {
                        address: ::core::clone::Clone::clone(&self.address),
                        provider: ::core::clone::Clone::clone(&self.provider),
                        _network_transport: ::core::clone::Clone::clone(
                            &self._network_transport,
                        ),
                    }
                }
            }
            #[automatically_derived]
            impl<T, P, N> ::core::fmt::Debug for UniswapV3FactoryInstance<T, P, N> {
                #[inline]
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_tuple("UniswapV3FactoryInstance")
                        .field(&self.address)
                        .finish()
                }
            }
            /// Instantiation and getters/setters.
            #[automatically_derived]
            impl<
                T: alloy_contract::private::Transport + ::core::clone::Clone,
                P: alloy_contract::private::Provider<T, N>,
                N: alloy_contract::private::Network,
            > UniswapV3FactoryInstance<T, P, N> {
                /**Creates a new wrapper around an on-chain [`UniswapV3Factory`](self) contract instance.

See the [wrapper's documentation](`UniswapV3FactoryInstance`) for more details.*/
                #[inline]
                pub const fn new(
                    address: alloy_sol_types::private::Address,
                    provider: P,
                ) -> Self {
                    Self {
                        address,
                        provider,
                        _network_transport: ::core::marker::PhantomData,
                    }
                }
                /// Returns a reference to the address.
                #[inline]
                pub const fn address(&self) -> &alloy_sol_types::private::Address {
                    &self.address
                }
                /// Sets the address.
                #[inline]
                pub fn set_address(
                    &mut self,
                    address: alloy_sol_types::private::Address,
                ) {
                    self.address = address;
                }
                /// Sets the address and returns `self`.
                pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
                    self.set_address(address);
                    self
                }
                /// Returns a reference to the provider.
                #[inline]
                pub const fn provider(&self) -> &P {
                    &self.provider
                }
            }
            impl<T, P: ::core::clone::Clone, N> UniswapV3FactoryInstance<T, &P, N> {
                /// Clones the provider and returns a new instance with the cloned provider.
                #[inline]
                pub fn with_cloned_provider(self) -> UniswapV3FactoryInstance<T, P, N> {
                    UniswapV3FactoryInstance {
                        address: self.address,
                        provider: ::core::clone::Clone::clone(&self.provider),
                        _network_transport: ::core::marker::PhantomData,
                    }
                }
            }
            /// Function calls.
            #[automatically_derived]
            impl<
                T: alloy_contract::private::Transport + ::core::clone::Clone,
                P: alloy_contract::private::Provider<T, N>,
                N: alloy_contract::private::Network,
            > UniswapV3FactoryInstance<T, P, N> {
                /// Creates a new call builder using this contract instance's provider and address.
                ///
                /// Note that the call can be any function call, not just those defined in this
                /// contract. Prefer using the other methods for building type-safe contract calls.
                pub fn call_builder<C: alloy_sol_types::SolCall>(
                    &self,
                    call: &C,
                ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
                    alloy_contract::SolCallBuilder::new_sol(
                        &self.provider,
                        &self.address,
                        call,
                    )
                }
                ///Creates a new call builder for the [`createPool`] function.
                pub fn createPool(
                    &self,
                    tokenA: ::alloy::sol_types::private::Address,
                    tokenB: ::alloy::sol_types::private::Address,
                    fee: <::alloy::sol_types::sol_data::Uint<
                        24,
                    > as ::alloy::sol_types::SolType>::RustType,
                ) -> alloy_contract::SolCallBuilder<T, &P, createPoolCall, N> {
                    self.call_builder(
                        &createPoolCall {
                            tokenA,
                            tokenB,
                            fee,
                        },
                    )
                }
                ///Creates a new call builder for the [`enableFeeAmount`] function.
                pub fn enableFeeAmount(
                    &self,
                    fee: <::alloy::sol_types::sol_data::Uint<
                        24,
                    > as ::alloy::sol_types::SolType>::RustType,
                    tickSpacing: <::alloy::sol_types::sol_data::Int<
                        24,
                    > as ::alloy::sol_types::SolType>::RustType,
                ) -> alloy_contract::SolCallBuilder<T, &P, enableFeeAmountCall, N> {
                    self.call_builder(
                        &enableFeeAmountCall {
                            fee,
                            tickSpacing,
                        },
                    )
                }
                ///Creates a new call builder for the [`feeAmountTickSpacing`] function.
                pub fn feeAmountTickSpacing(
                    &self,
                    _0: <::alloy::sol_types::sol_data::Uint<
                        24,
                    > as ::alloy::sol_types::SolType>::RustType,
                ) -> alloy_contract::SolCallBuilder<T, &P, feeAmountTickSpacingCall, N> {
                    self.call_builder(&feeAmountTickSpacingCall { _0 })
                }
                ///Creates a new call builder for the [`getPool`] function.
                pub fn getPool(
                    &self,
                    _0: ::alloy::sol_types::private::Address,
                    _1: ::alloy::sol_types::private::Address,
                    _2: <::alloy::sol_types::sol_data::Uint<
                        24,
                    > as ::alloy::sol_types::SolType>::RustType,
                ) -> alloy_contract::SolCallBuilder<T, &P, getPoolCall, N> {
                    self.call_builder(&getPoolCall { _0, _1, _2 })
                }
                ///Creates a new call builder for the [`owner`] function.
                pub fn owner(
                    &self,
                ) -> alloy_contract::SolCallBuilder<T, &P, ownerCall, N> {
                    self.call_builder(&ownerCall {})
                }
                ///Creates a new call builder for the [`parameters`] function.
                pub fn parameters(
                    &self,
                ) -> alloy_contract::SolCallBuilder<T, &P, parametersCall, N> {
                    self.call_builder(&parametersCall {})
                }
                ///Creates a new call builder for the [`setOwner`] function.
                pub fn setOwner(
                    &self,
                    _owner: ::alloy::sol_types::private::Address,
                ) -> alloy_contract::SolCallBuilder<T, &P, setOwnerCall, N> {
                    self.call_builder(&setOwnerCall { _owner })
                }
            }
            /// Event filters.
            #[automatically_derived]
            impl<
                T: alloy_contract::private::Transport + ::core::clone::Clone,
                P: alloy_contract::private::Provider<T, N>,
                N: alloy_contract::private::Network,
            > UniswapV3FactoryInstance<T, P, N> {
                /// Creates a new event filter using this contract instance's provider and address.
                ///
                /// Note that the type can be any event, not just those defined in this contract.
                /// Prefer using the other methods for building type-safe event filters.
                pub fn event_filter<E: alloy_sol_types::SolEvent>(
                    &self,
                ) -> alloy_contract::Event<T, &P, E, N> {
                    alloy_contract::Event::new_sol(&self.provider, &self.address)
                }
                ///Creates a new event filter for the [`FeeAmountEnabled`] event.
                pub fn FeeAmountEnabled_filter(
                    &self,
                ) -> alloy_contract::Event<T, &P, FeeAmountEnabled, N> {
                    self.event_filter::<FeeAmountEnabled>()
                }
                ///Creates a new event filter for the [`OwnerChanged`] event.
                pub fn OwnerChanged_filter(
                    &self,
                ) -> alloy_contract::Event<T, &P, OwnerChanged, N> {
                    self.event_filter::<OwnerChanged>()
                }
                ///Creates a new event filter for the [`PoolCreated`] event.
                pub fn PoolCreated_filter(
                    &self,
                ) -> alloy_contract::Event<T, &P, PoolCreated, N> {
                    self.event_filter::<PoolCreated>()
                }
            }
        }
        const _: &'static [u8] = b"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeToSetter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"PairCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allPairs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allPairsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"createPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeTo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeToSetter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pairCodeHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeTo\",\"type\":\"address\"}],\"name\":\"setFeeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeToSetter\",\"type\":\"address\"}],\"name\":\"setFeeToSetter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_migrator\",\"type\":\"address\"}],\"name\":\"setMigrator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]";
        /**

Generated by the following Solidity interface...
```solidity
interface SushiSwapV2Factory {
    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);

    constructor(address _feeToSetter);

    function allPairs(uint256) external view returns (address);
    function allPairsLength() external view returns (uint256);
    function createPair(address tokenA, address tokenB) external returns (address pair);
    function feeTo() external view returns (address);
    function feeToSetter() external view returns (address);
    function getPair(address, address) external view returns (address);
    function migrator() external view returns (address);
    function pairCodeHash() external pure returns (bytes32);
    function setFeeTo(address _feeTo) external;
    function setFeeToSetter(address _feeToSetter) external;
    function setMigrator(address _migrator) external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "_feeToSetter",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "allPairs",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "allPairsLength",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "createPair",
    "inputs": [
      {
        "name": "tokenA",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "tokenB",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "pair",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "feeTo",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "feeToSetter",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getPair",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "migrator",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "pairCodeHash",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "setFeeTo",
    "inputs": [
      {
        "name": "_feeTo",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setFeeToSetter",
    "inputs": [
      {
        "name": "_feeToSetter",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setMigrator",
    "inputs": [
      {
        "name": "_migrator",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "PairCreated",
    "inputs": [
      {
        "name": "token0",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "token1",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "pair",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  }
]
```*/
        #[allow(non_camel_case_types, non_snake_case, clippy::style)]
        pub mod SushiSwapV2Factory {
            use super::*;
            use ::alloy::sol_types as alloy_sol_types;
            /**Event with signature `PairCreated(address,address,address,uint256)` and selector `0x0d3648bd0f6ba80134a33ba9275ac585d9d315f0ad8355cddefde31afa28d0e9`.
```solidity
event PairCreated(address indexed token0, address indexed token1, address pair, uint256);
```*/
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            pub struct PairCreated {
                #[allow(missing_docs)]
                pub token0: ::alloy::sol_types::private::Address,
                #[allow(missing_docs)]
                pub token1: ::alloy::sol_types::private::Address,
                #[allow(missing_docs)]
                pub pair: ::alloy::sol_types::private::Address,
                #[allow(missing_docs)]
                pub _3: ::alloy::sol_types::private::U256,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            impl ::core::clone::Clone for PairCreated {
                #[inline]
                fn clone(&self) -> PairCreated {
                    PairCreated {
                        token0: ::core::clone::Clone::clone(&self.token0),
                        token1: ::core::clone::Clone::clone(&self.token1),
                        pair: ::core::clone::Clone::clone(&self.pair),
                        _3: ::core::clone::Clone::clone(&self._3),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            impl ::core::fmt::Debug for PairCreated {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "PairCreated",
                        "token0",
                        &self.token0,
                        "token1",
                        &self.token1,
                        "pair",
                        &self.pair,
                        "_3",
                        &&self._3,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                #[automatically_derived]
                impl alloy_sol_types::SolEvent for PairCreated {
                    type DataTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Uint<256>,
                    );
                    type DataToken<'a> = <Self::DataTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type TopicList = (
                        alloy_sol_types::sol_data::FixedBytes<32>,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                    );
                    const SIGNATURE: &'static str = "PairCreated(address,address,address,uint256)";
                    const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                        13u8,
                        54u8,
                        72u8,
                        189u8,
                        15u8,
                        107u8,
                        168u8,
                        1u8,
                        52u8,
                        163u8,
                        59u8,
                        169u8,
                        39u8,
                        90u8,
                        197u8,
                        133u8,
                        217u8,
                        211u8,
                        21u8,
                        240u8,
                        173u8,
                        131u8,
                        85u8,
                        205u8,
                        222u8,
                        253u8,
                        227u8,
                        26u8,
                        250u8,
                        40u8,
                        208u8,
                        233u8,
                    ]);
                    const ANONYMOUS: bool = false;
                    #[allow(unused_variables)]
                    #[inline]
                    fn new(
                        topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                        data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        Self {
                            token0: topics.1,
                            token1: topics.2,
                            pair: data.0,
                            _3: data.1,
                        }
                    }
                    #[inline]
                    fn tokenize_body(&self) -> Self::DataToken<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self.pair,
                            ),
                            <::alloy::sol_types::sol_data::Uint<
                                256,
                            > as alloy_sol_types::SolType>::tokenize(&self._3),
                        )
                    }
                    #[inline]
                    fn topics(
                        &self,
                    ) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                        (
                            Self::SIGNATURE_HASH.into(),
                            self.token0.clone(),
                            self.token1.clone(),
                        )
                    }
                    #[inline]
                    fn encode_topics_raw(
                        &self,
                        out: &mut [alloy_sol_types::abi::token::WordToken],
                    ) -> alloy_sol_types::Result<()> {
                        if out.len()
                            < <Self::TopicList as alloy_sol_types::TopicList>::COUNT
                        {
                            return Err(alloy_sol_types::Error::Overrun);
                        }
                        out[0usize] = alloy_sol_types::abi::token::WordToken(
                            Self::SIGNATURE_HASH,
                        );
                        out[1usize] = <::alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                            &self.token0,
                        );
                        out[2usize] = <::alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                            &self.token1,
                        );
                        Ok(())
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::private::IntoLogData for PairCreated {
                    fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                        From::from(self)
                    }
                    fn into_log_data(self) -> alloy_sol_types::private::LogData {
                        From::from(&self)
                    }
                }
                #[automatically_derived]
                impl From<&PairCreated> for alloy_sol_types::private::LogData {
                    #[inline]
                    fn from(this: &PairCreated) -> alloy_sol_types::private::LogData {
                        alloy_sol_types::SolEvent::encode_log_data(this)
                    }
                }
            };
            /**Constructor`.
```solidity
constructor(address _feeToSetter);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct constructorCall {
                pub _feeToSetter: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for constructorCall {
                #[inline]
                fn clone(&self) -> constructorCall {
                    constructorCall {
                        _feeToSetter: ::core::clone::Clone::clone(&self._feeToSetter),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for constructorCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "constructorCall",
                        "_feeToSetter",
                        &&self._feeToSetter,
                    )
                }
            }
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<constructorCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: constructorCall) -> Self {
                            (value._feeToSetter,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for constructorCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _feeToSetter: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolConstructor for constructorCall {
                    type Parameters<'a> = (::alloy::sol_types::sol_data::Address,);
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self._feeToSetter,
                            ),
                        )
                    }
                }
            };
            /**Function with signature `allPairs(uint256)` and selector `0x1e3dd18b`.
```solidity
function allPairs(uint256) external view returns (address);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct allPairsCall {
                pub _0: ::alloy::sol_types::private::U256,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for allPairsCall {
                #[inline]
                fn clone(&self) -> allPairsCall {
                    allPairsCall {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for allPairsCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "allPairsCall",
                        "_0",
                        &&self._0,
                    )
                }
            }
            ///Container type for the return parameters of the [`allPairs(uint256)`](allPairsCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct allPairsReturn {
                pub _0: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for allPairsReturn {
                #[inline]
                fn clone(&self) -> allPairsReturn {
                    allPairsReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for allPairsReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "allPairsReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Uint<256>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (::alloy::sol_types::private::U256,);
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<allPairsCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: allPairsCall) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for allPairsCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<allPairsReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: allPairsReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for allPairsReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for allPairsCall {
                    type Parameters<'a> = (::alloy::sol_types::sol_data::Uint<256>,);
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = allPairsReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Address,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "allPairs(uint256)";
                    const SELECTOR: [u8; 4] = [30u8, 61u8, 209u8, 139u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Uint<
                                256,
                            > as alloy_sol_types::SolType>::tokenize(&self._0),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `allPairsLength()` and selector `0x574f2ba3`.
```solidity
function allPairsLength() external view returns (uint256);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct allPairsLengthCall {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for allPairsLengthCall {
                #[inline]
                fn clone(&self) -> allPairsLengthCall {
                    allPairsLengthCall {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for allPairsLengthCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "allPairsLengthCall")
                }
            }
            ///Container type for the return parameters of the [`allPairsLength()`](allPairsLengthCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct allPairsLengthReturn {
                pub _0: ::alloy::sol_types::private::U256,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for allPairsLengthReturn {
                #[inline]
                fn clone(&self) -> allPairsLengthReturn {
                    allPairsLengthReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for allPairsLengthReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "allPairsLengthReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<allPairsLengthCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: allPairsLengthCall) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for allPairsLengthCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Uint<256>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (::alloy::sol_types::private::U256,);
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<allPairsLengthReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: allPairsLengthReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for allPairsLengthReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for allPairsLengthCall {
                    type Parameters<'a> = ();
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = allPairsLengthReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Uint<256>,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "allPairsLength()";
                    const SELECTOR: [u8; 4] = [87u8, 79u8, 43u8, 163u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `createPair(address,address)` and selector `0xc9c65396`.
```solidity
function createPair(address tokenA, address tokenB) external returns (address pair);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct createPairCall {
                pub tokenA: ::alloy::sol_types::private::Address,
                pub tokenB: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for createPairCall {
                #[inline]
                fn clone(&self) -> createPairCall {
                    createPairCall {
                        tokenA: ::core::clone::Clone::clone(&self.tokenA),
                        tokenB: ::core::clone::Clone::clone(&self.tokenB),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for createPairCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "createPairCall",
                        "tokenA",
                        &self.tokenA,
                        "tokenB",
                        &&self.tokenB,
                    )
                }
            }
            ///Container type for the return parameters of the [`createPair(address,address)`](createPairCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct createPairReturn {
                pub pair: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for createPairReturn {
                #[inline]
                fn clone(&self) -> createPairReturn {
                    createPairReturn {
                        pair: ::core::clone::Clone::clone(&self.pair),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for createPairReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "createPairReturn",
                        "pair",
                        &&self.pair,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<createPairCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: createPairCall) -> Self {
                            (value.tokenA, value.tokenB)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for createPairCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {
                                tokenA: tuple.0,
                                tokenB: tuple.1,
                            }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<createPairReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: createPairReturn) -> Self {
                            (value.pair,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for createPairReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { pair: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for createPairCall {
                    type Parameters<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                    );
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = createPairReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Address,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "createPair(address,address)";
                    const SELECTOR: [u8; 4] = [201u8, 198u8, 83u8, 150u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self.tokenA,
                            ),
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self.tokenB,
                            ),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `feeTo()` and selector `0x017e7e58`.
```solidity
function feeTo() external view returns (address);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct feeToCall {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for feeToCall {
                #[inline]
                fn clone(&self) -> feeToCall {
                    feeToCall {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for feeToCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "feeToCall")
                }
            }
            ///Container type for the return parameters of the [`feeTo()`](feeToCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct feeToReturn {
                pub _0: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for feeToReturn {
                #[inline]
                fn clone(&self) -> feeToReturn {
                    feeToReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for feeToReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "feeToReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<feeToCall> for UnderlyingRustTuple<'_> {
                        fn from(value: feeToCall) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>> for feeToCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<feeToReturn> for UnderlyingRustTuple<'_> {
                        fn from(value: feeToReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>> for feeToReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for feeToCall {
                    type Parameters<'a> = ();
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = feeToReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Address,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "feeTo()";
                    const SELECTOR: [u8; 4] = [1u8, 126u8, 126u8, 88u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `feeToSetter()` and selector `0x094b7415`.
```solidity
function feeToSetter() external view returns (address);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct feeToSetterCall {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for feeToSetterCall {
                #[inline]
                fn clone(&self) -> feeToSetterCall {
                    feeToSetterCall {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for feeToSetterCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "feeToSetterCall")
                }
            }
            ///Container type for the return parameters of the [`feeToSetter()`](feeToSetterCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct feeToSetterReturn {
                pub _0: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for feeToSetterReturn {
                #[inline]
                fn clone(&self) -> feeToSetterReturn {
                    feeToSetterReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for feeToSetterReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "feeToSetterReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<feeToSetterCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: feeToSetterCall) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for feeToSetterCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<feeToSetterReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: feeToSetterReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for feeToSetterReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for feeToSetterCall {
                    type Parameters<'a> = ();
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = feeToSetterReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Address,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "feeToSetter()";
                    const SELECTOR: [u8; 4] = [9u8, 75u8, 116u8, 21u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `getPair(address,address)` and selector `0xe6a43905`.
```solidity
function getPair(address, address) external view returns (address);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct getPairCall {
                pub _0: ::alloy::sol_types::private::Address,
                pub _1: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for getPairCall {
                #[inline]
                fn clone(&self) -> getPairCall {
                    getPairCall {
                        _0: ::core::clone::Clone::clone(&self._0),
                        _1: ::core::clone::Clone::clone(&self._1),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for getPairCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "getPairCall",
                        "_0",
                        &self._0,
                        "_1",
                        &&self._1,
                    )
                }
            }
            ///Container type for the return parameters of the [`getPair(address,address)`](getPairCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct getPairReturn {
                pub _0: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for getPairReturn {
                #[inline]
                fn clone(&self) -> getPairReturn {
                    getPairReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for getPairReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "getPairReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<getPairCall> for UnderlyingRustTuple<'_> {
                        fn from(value: getPairCall) -> Self {
                            (value._0, value._1)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>> for getPairCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0, _1: tuple.1 }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<getPairReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: getPairReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for getPairReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for getPairCall {
                    type Parameters<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                    );
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = getPairReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Address,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "getPair(address,address)";
                    const SELECTOR: [u8; 4] = [230u8, 164u8, 57u8, 5u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self._0,
                            ),
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self._1,
                            ),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `migrator()` and selector `0x7cd07e47`.
```solidity
function migrator() external view returns (address);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct migratorCall {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for migratorCall {
                #[inline]
                fn clone(&self) -> migratorCall {
                    migratorCall {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for migratorCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "migratorCall")
                }
            }
            ///Container type for the return parameters of the [`migrator()`](migratorCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct migratorReturn {
                pub _0: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for migratorReturn {
                #[inline]
                fn clone(&self) -> migratorReturn {
                    migratorReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for migratorReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "migratorReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<migratorCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: migratorCall) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for migratorCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<migratorReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: migratorReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for migratorReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for migratorCall {
                    type Parameters<'a> = ();
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = migratorReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Address,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "migrator()";
                    const SELECTOR: [u8; 4] = [124u8, 208u8, 126u8, 71u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `pairCodeHash()` and selector `0x9aab9248`.
```solidity
function pairCodeHash() external pure returns (bytes32);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct pairCodeHashCall {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for pairCodeHashCall {
                #[inline]
                fn clone(&self) -> pairCodeHashCall {
                    pairCodeHashCall {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for pairCodeHashCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "pairCodeHashCall")
                }
            }
            ///Container type for the return parameters of the [`pairCodeHash()`](pairCodeHashCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct pairCodeHashReturn {
                pub _0: ::alloy::sol_types::private::FixedBytes<32>,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for pairCodeHashReturn {
                #[inline]
                fn clone(&self) -> pairCodeHashReturn {
                    pairCodeHashReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for pairCodeHashReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "pairCodeHashReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<pairCodeHashCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: pairCodeHashCall) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for pairCodeHashCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::FixedBytes<32>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::FixedBytes<32>,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<pairCodeHashReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: pairCodeHashReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for pairCodeHashReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for pairCodeHashCall {
                    type Parameters<'a> = ();
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = pairCodeHashReturn;
                    type ReturnTuple<'a> = (
                        ::alloy::sol_types::sol_data::FixedBytes<32>,
                    );
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "pairCodeHash()";
                    const SELECTOR: [u8; 4] = [154u8, 171u8, 146u8, 72u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `setFeeTo(address)` and selector `0xf46901ed`.
```solidity
function setFeeTo(address _feeTo) external;
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct setFeeToCall {
                pub _feeTo: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for setFeeToCall {
                #[inline]
                fn clone(&self) -> setFeeToCall {
                    setFeeToCall {
                        _feeTo: ::core::clone::Clone::clone(&self._feeTo),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for setFeeToCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "setFeeToCall",
                        "_feeTo",
                        &&self._feeTo,
                    )
                }
            }
            ///Container type for the return parameters of the [`setFeeTo(address)`](setFeeToCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct setFeeToReturn {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for setFeeToReturn {
                #[inline]
                fn clone(&self) -> setFeeToReturn {
                    setFeeToReturn {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for setFeeToReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "setFeeToReturn")
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<setFeeToCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: setFeeToCall) -> Self {
                            (value._feeTo,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for setFeeToCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _feeTo: tuple.0 }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<setFeeToReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: setFeeToReturn) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for setFeeToReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for setFeeToCall {
                    type Parameters<'a> = (::alloy::sol_types::sol_data::Address,);
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = setFeeToReturn;
                    type ReturnTuple<'a> = ();
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "setFeeTo(address)";
                    const SELECTOR: [u8; 4] = [244u8, 105u8, 1u8, 237u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self._feeTo,
                            ),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `setFeeToSetter(address)` and selector `0xa2e74af6`.
```solidity
function setFeeToSetter(address _feeToSetter) external;
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct setFeeToSetterCall {
                pub _feeToSetter: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for setFeeToSetterCall {
                #[inline]
                fn clone(&self) -> setFeeToSetterCall {
                    setFeeToSetterCall {
                        _feeToSetter: ::core::clone::Clone::clone(&self._feeToSetter),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for setFeeToSetterCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "setFeeToSetterCall",
                        "_feeToSetter",
                        &&self._feeToSetter,
                    )
                }
            }
            ///Container type for the return parameters of the [`setFeeToSetter(address)`](setFeeToSetterCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct setFeeToSetterReturn {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for setFeeToSetterReturn {
                #[inline]
                fn clone(&self) -> setFeeToSetterReturn {
                    setFeeToSetterReturn {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for setFeeToSetterReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "setFeeToSetterReturn")
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<setFeeToSetterCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: setFeeToSetterCall) -> Self {
                            (value._feeToSetter,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for setFeeToSetterCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _feeToSetter: tuple.0 }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<setFeeToSetterReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: setFeeToSetterReturn) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for setFeeToSetterReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for setFeeToSetterCall {
                    type Parameters<'a> = (::alloy::sol_types::sol_data::Address,);
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = setFeeToSetterReturn;
                    type ReturnTuple<'a> = ();
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "setFeeToSetter(address)";
                    const SELECTOR: [u8; 4] = [162u8, 231u8, 74u8, 246u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self._feeToSetter,
                            ),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `setMigrator(address)` and selector `0x23cf3118`.
```solidity
function setMigrator(address _migrator) external;
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct setMigratorCall {
                pub _migrator: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for setMigratorCall {
                #[inline]
                fn clone(&self) -> setMigratorCall {
                    setMigratorCall {
                        _migrator: ::core::clone::Clone::clone(&self._migrator),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for setMigratorCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "setMigratorCall",
                        "_migrator",
                        &&self._migrator,
                    )
                }
            }
            ///Container type for the return parameters of the [`setMigrator(address)`](setMigratorCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct setMigratorReturn {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for setMigratorReturn {
                #[inline]
                fn clone(&self) -> setMigratorReturn {
                    setMigratorReturn {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for setMigratorReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "setMigratorReturn")
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<setMigratorCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: setMigratorCall) -> Self {
                            (value._migrator,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for setMigratorCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _migrator: tuple.0 }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<setMigratorReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: setMigratorReturn) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for setMigratorReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for setMigratorCall {
                    type Parameters<'a> = (::alloy::sol_types::sol_data::Address,);
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = setMigratorReturn;
                    type ReturnTuple<'a> = ();
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "setMigrator(address)";
                    const SELECTOR: [u8; 4] = [35u8, 207u8, 49u8, 24u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self._migrator,
                            ),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            ///Container for all the [`SushiSwapV2Factory`](self) function calls.
            pub enum SushiSwapV2FactoryCalls {
                allPairs(allPairsCall),
                allPairsLength(allPairsLengthCall),
                createPair(createPairCall),
                feeTo(feeToCall),
                feeToSetter(feeToSetterCall),
                getPair(getPairCall),
                migrator(migratorCall),
                pairCodeHash(pairCodeHashCall),
                setFeeTo(setFeeToCall),
                setFeeToSetter(setFeeToSetterCall),
                setMigrator(setMigratorCall),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for SushiSwapV2FactoryCalls {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        SushiSwapV2FactoryCalls::allPairs(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "allPairs",
                                &__self_0,
                            )
                        }
                        SushiSwapV2FactoryCalls::allPairsLength(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "allPairsLength",
                                &__self_0,
                            )
                        }
                        SushiSwapV2FactoryCalls::createPair(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "createPair",
                                &__self_0,
                            )
                        }
                        SushiSwapV2FactoryCalls::feeTo(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "feeTo",
                                &__self_0,
                            )
                        }
                        SushiSwapV2FactoryCalls::feeToSetter(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "feeToSetter",
                                &__self_0,
                            )
                        }
                        SushiSwapV2FactoryCalls::getPair(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "getPair",
                                &__self_0,
                            )
                        }
                        SushiSwapV2FactoryCalls::migrator(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "migrator",
                                &__self_0,
                            )
                        }
                        SushiSwapV2FactoryCalls::pairCodeHash(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "pairCodeHash",
                                &__self_0,
                            )
                        }
                        SushiSwapV2FactoryCalls::setFeeTo(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "setFeeTo",
                                &__self_0,
                            )
                        }
                        SushiSwapV2FactoryCalls::setFeeToSetter(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "setFeeToSetter",
                                &__self_0,
                            )
                        }
                        SushiSwapV2FactoryCalls::setMigrator(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "setMigrator",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl SushiSwapV2FactoryCalls {
                /// All the selectors of this enum.
                ///
                /// Note that the selectors might not be in the same order as the variants.
                /// No guarantees are made about the order of the selectors.
                ///
                /// Prefer using `SolInterface` methods instead.
                pub const SELECTORS: &'static [[u8; 4usize]] = &[
                    [1u8, 126u8, 126u8, 88u8],
                    [9u8, 75u8, 116u8, 21u8],
                    [30u8, 61u8, 209u8, 139u8],
                    [35u8, 207u8, 49u8, 24u8],
                    [87u8, 79u8, 43u8, 163u8],
                    [124u8, 208u8, 126u8, 71u8],
                    [154u8, 171u8, 146u8, 72u8],
                    [162u8, 231u8, 74u8, 246u8],
                    [201u8, 198u8, 83u8, 150u8],
                    [230u8, 164u8, 57u8, 5u8],
                    [244u8, 105u8, 1u8, 237u8],
                ];
            }
            #[automatically_derived]
            impl alloy_sol_types::SolInterface for SushiSwapV2FactoryCalls {
                const NAME: &'static str = "SushiSwapV2FactoryCalls";
                const MIN_DATA_LENGTH: usize = 0usize;
                const COUNT: usize = 11usize;
                #[inline]
                fn selector(&self) -> [u8; 4] {
                    match self {
                        Self::allPairs(_) => {
                            <allPairsCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::allPairsLength(_) => {
                            <allPairsLengthCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::createPair(_) => {
                            <createPairCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::feeTo(_) => {
                            <feeToCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::feeToSetter(_) => {
                            <feeToSetterCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::getPair(_) => {
                            <getPairCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::migrator(_) => {
                            <migratorCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::pairCodeHash(_) => {
                            <pairCodeHashCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::setFeeTo(_) => {
                            <setFeeToCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::setFeeToSetter(_) => {
                            <setFeeToSetterCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::setMigrator(_) => {
                            <setMigratorCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                    }
                }
                #[inline]
                fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
                    Self::SELECTORS.get(i).copied()
                }
                #[inline]
                fn valid_selector(selector: [u8; 4]) -> bool {
                    Self::SELECTORS.binary_search(&selector).is_ok()
                }
                #[inline]
                #[allow(unsafe_code, non_snake_case)]
                fn abi_decode_raw(
                    selector: [u8; 4],
                    data: &[u8],
                    validate: bool,
                ) -> alloy_sol_types::Result<Self> {
                    static DECODE_SHIMS: &[fn(
                        &[u8],
                        bool,
                    ) -> alloy_sol_types::Result<SushiSwapV2FactoryCalls>] = &[
                        {
                            fn feeTo(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<SushiSwapV2FactoryCalls> {
                                <feeToCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(SushiSwapV2FactoryCalls::feeTo)
                            }
                            feeTo
                        },
                        {
                            fn feeToSetter(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<SushiSwapV2FactoryCalls> {
                                <feeToSetterCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(SushiSwapV2FactoryCalls::feeToSetter)
                            }
                            feeToSetter
                        },
                        {
                            fn allPairs(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<SushiSwapV2FactoryCalls> {
                                <allPairsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(SushiSwapV2FactoryCalls::allPairs)
                            }
                            allPairs
                        },
                        {
                            fn setMigrator(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<SushiSwapV2FactoryCalls> {
                                <setMigratorCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(SushiSwapV2FactoryCalls::setMigrator)
                            }
                            setMigrator
                        },
                        {
                            fn allPairsLength(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<SushiSwapV2FactoryCalls> {
                                <allPairsLengthCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(SushiSwapV2FactoryCalls::allPairsLength)
                            }
                            allPairsLength
                        },
                        {
                            fn migrator(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<SushiSwapV2FactoryCalls> {
                                <migratorCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(SushiSwapV2FactoryCalls::migrator)
                            }
                            migrator
                        },
                        {
                            fn pairCodeHash(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<SushiSwapV2FactoryCalls> {
                                <pairCodeHashCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(SushiSwapV2FactoryCalls::pairCodeHash)
                            }
                            pairCodeHash
                        },
                        {
                            fn setFeeToSetter(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<SushiSwapV2FactoryCalls> {
                                <setFeeToSetterCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(SushiSwapV2FactoryCalls::setFeeToSetter)
                            }
                            setFeeToSetter
                        },
                        {
                            fn createPair(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<SushiSwapV2FactoryCalls> {
                                <createPairCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(SushiSwapV2FactoryCalls::createPair)
                            }
                            createPair
                        },
                        {
                            fn getPair(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<SushiSwapV2FactoryCalls> {
                                <getPairCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(SushiSwapV2FactoryCalls::getPair)
                            }
                            getPair
                        },
                        {
                            fn setFeeTo(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<SushiSwapV2FactoryCalls> {
                                <setFeeToCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(SushiSwapV2FactoryCalls::setFeeTo)
                            }
                            setFeeTo
                        },
                    ];
                    let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                        return Err(
                            alloy_sol_types::Error::unknown_selector(
                                <Self as alloy_sol_types::SolInterface>::NAME,
                                selector,
                            ),
                        );
                    };
                    (unsafe { DECODE_SHIMS.get_unchecked(idx) })(data, validate)
                }
                #[inline]
                fn abi_encoded_size(&self) -> usize {
                    match self {
                        Self::allPairs(inner) => {
                            <allPairsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::allPairsLength(inner) => {
                            <allPairsLengthCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::createPair(inner) => {
                            <createPairCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::feeTo(inner) => {
                            <feeToCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::feeToSetter(inner) => {
                            <feeToSetterCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::getPair(inner) => {
                            <getPairCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::migrator(inner) => {
                            <migratorCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::pairCodeHash(inner) => {
                            <pairCodeHashCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::setFeeTo(inner) => {
                            <setFeeToCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::setFeeToSetter(inner) => {
                            <setFeeToSetterCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::setMigrator(inner) => {
                            <setMigratorCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                    }
                }
                #[inline]
                fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                    match self {
                        Self::allPairs(inner) => {
                            <allPairsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::allPairsLength(inner) => {
                            <allPairsLengthCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::createPair(inner) => {
                            <createPairCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::feeTo(inner) => {
                            <feeToCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::feeToSetter(inner) => {
                            <feeToSetterCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::getPair(inner) => {
                            <getPairCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::migrator(inner) => {
                            <migratorCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::pairCodeHash(inner) => {
                            <pairCodeHashCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::setFeeTo(inner) => {
                            <setFeeToCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::setFeeToSetter(inner) => {
                            <setFeeToSetterCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::setMigrator(inner) => {
                            <setMigratorCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                    }
                }
            }
            ///Container for all the [`SushiSwapV2Factory`](self) events.
            pub enum SushiSwapV2FactoryEvents {
                PairCreated(PairCreated),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for SushiSwapV2FactoryEvents {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        SushiSwapV2FactoryEvents::PairCreated(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "PairCreated",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl SushiSwapV2FactoryEvents {
                /// All the selectors of this enum.
                ///
                /// Note that the selectors might not be in the same order as the variants.
                /// No guarantees are made about the order of the selectors.
                ///
                /// Prefer using `SolInterface` methods instead.
                pub const SELECTORS: &'static [[u8; 32usize]] = &[
                    [
                        13u8,
                        54u8,
                        72u8,
                        189u8,
                        15u8,
                        107u8,
                        168u8,
                        1u8,
                        52u8,
                        163u8,
                        59u8,
                        169u8,
                        39u8,
                        90u8,
                        197u8,
                        133u8,
                        217u8,
                        211u8,
                        21u8,
                        240u8,
                        173u8,
                        131u8,
                        85u8,
                        205u8,
                        222u8,
                        253u8,
                        227u8,
                        26u8,
                        250u8,
                        40u8,
                        208u8,
                        233u8,
                    ],
                ];
            }
            #[automatically_derived]
            impl alloy_sol_types::SolEventInterface for SushiSwapV2FactoryEvents {
                const NAME: &'static str = "SushiSwapV2FactoryEvents";
                const COUNT: usize = 1usize;
                fn decode_raw_log(
                    topics: &[alloy_sol_types::Word],
                    data: &[u8],
                    validate: bool,
                ) -> alloy_sol_types::Result<Self> {
                    match topics.first().copied() {
                        Some(
                            <PairCreated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                        ) => {
                            <PairCreated as alloy_sol_types::SolEvent>::decode_raw_log(
                                    topics,
                                    data,
                                    validate,
                                )
                                .map(Self::PairCreated)
                        }
                        _ => {
                            alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                                name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                                log: alloy_sol_types::private::Box::new(
                                    alloy_sol_types::private::LogData::new_unchecked(
                                        topics.to_vec(),
                                        data.to_vec().into(),
                                    ),
                                ),
                            })
                        }
                    }
                }
            }
            #[automatically_derived]
            impl alloy_sol_types::private::IntoLogData for SushiSwapV2FactoryEvents {
                fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                    match self {
                        Self::PairCreated(inner) => {
                            alloy_sol_types::private::IntoLogData::to_log_data(inner)
                        }
                    }
                }
                fn into_log_data(self) -> alloy_sol_types::private::LogData {
                    match self {
                        Self::PairCreated(inner) => {
                            alloy_sol_types::private::IntoLogData::into_log_data(inner)
                        }
                    }
                }
            }
            use ::alloy::contract as alloy_contract;
            /**Creates a new wrapper around an on-chain [`SushiSwapV2Factory`](self) contract instance.

See the [wrapper's documentation](`SushiSwapV2FactoryInstance`) for more details.*/
            #[inline]
            pub const fn new<
                T: alloy_contract::private::Transport + ::core::clone::Clone,
                P: alloy_contract::private::Provider<T, N>,
                N: alloy_contract::private::Network,
            >(
                address: alloy_sol_types::private::Address,
                provider: P,
            ) -> SushiSwapV2FactoryInstance<T, P, N> {
                SushiSwapV2FactoryInstance::<T, P, N>::new(address, provider)
            }
            /**A [`SushiSwapV2Factory`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`SushiSwapV2Factory`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
            pub struct SushiSwapV2FactoryInstance<
                T,
                P,
                N = alloy_contract::private::Ethereum,
            > {
                address: alloy_sol_types::private::Address,
                provider: P,
                _network_transport: ::core::marker::PhantomData<(N, T)>,
            }
            #[automatically_derived]
            impl<
                T: ::core::clone::Clone,
                P: ::core::clone::Clone,
                N: ::core::clone::Clone,
            > ::core::clone::Clone for SushiSwapV2FactoryInstance<T, P, N> {
                #[inline]
                fn clone(&self) -> SushiSwapV2FactoryInstance<T, P, N> {
                    SushiSwapV2FactoryInstance {
                        address: ::core::clone::Clone::clone(&self.address),
                        provider: ::core::clone::Clone::clone(&self.provider),
                        _network_transport: ::core::clone::Clone::clone(
                            &self._network_transport,
                        ),
                    }
                }
            }
            #[automatically_derived]
            impl<T, P, N> ::core::fmt::Debug for SushiSwapV2FactoryInstance<T, P, N> {
                #[inline]
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_tuple("SushiSwapV2FactoryInstance")
                        .field(&self.address)
                        .finish()
                }
            }
            /// Instantiation and getters/setters.
            #[automatically_derived]
            impl<
                T: alloy_contract::private::Transport + ::core::clone::Clone,
                P: alloy_contract::private::Provider<T, N>,
                N: alloy_contract::private::Network,
            > SushiSwapV2FactoryInstance<T, P, N> {
                /**Creates a new wrapper around an on-chain [`SushiSwapV2Factory`](self) contract instance.

See the [wrapper's documentation](`SushiSwapV2FactoryInstance`) for more details.*/
                #[inline]
                pub const fn new(
                    address: alloy_sol_types::private::Address,
                    provider: P,
                ) -> Self {
                    Self {
                        address,
                        provider,
                        _network_transport: ::core::marker::PhantomData,
                    }
                }
                /// Returns a reference to the address.
                #[inline]
                pub const fn address(&self) -> &alloy_sol_types::private::Address {
                    &self.address
                }
                /// Sets the address.
                #[inline]
                pub fn set_address(
                    &mut self,
                    address: alloy_sol_types::private::Address,
                ) {
                    self.address = address;
                }
                /// Sets the address and returns `self`.
                pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
                    self.set_address(address);
                    self
                }
                /// Returns a reference to the provider.
                #[inline]
                pub const fn provider(&self) -> &P {
                    &self.provider
                }
            }
            impl<T, P: ::core::clone::Clone, N> SushiSwapV2FactoryInstance<T, &P, N> {
                /// Clones the provider and returns a new instance with the cloned provider.
                #[inline]
                pub fn with_cloned_provider(
                    self,
                ) -> SushiSwapV2FactoryInstance<T, P, N> {
                    SushiSwapV2FactoryInstance {
                        address: self.address,
                        provider: ::core::clone::Clone::clone(&self.provider),
                        _network_transport: ::core::marker::PhantomData,
                    }
                }
            }
            /// Function calls.
            #[automatically_derived]
            impl<
                T: alloy_contract::private::Transport + ::core::clone::Clone,
                P: alloy_contract::private::Provider<T, N>,
                N: alloy_contract::private::Network,
            > SushiSwapV2FactoryInstance<T, P, N> {
                /// Creates a new call builder using this contract instance's provider and address.
                ///
                /// Note that the call can be any function call, not just those defined in this
                /// contract. Prefer using the other methods for building type-safe contract calls.
                pub fn call_builder<C: alloy_sol_types::SolCall>(
                    &self,
                    call: &C,
                ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
                    alloy_contract::SolCallBuilder::new_sol(
                        &self.provider,
                        &self.address,
                        call,
                    )
                }
                ///Creates a new call builder for the [`allPairs`] function.
                pub fn allPairs(
                    &self,
                    _0: ::alloy::sol_types::private::U256,
                ) -> alloy_contract::SolCallBuilder<T, &P, allPairsCall, N> {
                    self.call_builder(&allPairsCall { _0 })
                }
                ///Creates a new call builder for the [`allPairsLength`] function.
                pub fn allPairsLength(
                    &self,
                ) -> alloy_contract::SolCallBuilder<T, &P, allPairsLengthCall, N> {
                    self.call_builder(&allPairsLengthCall {})
                }
                ///Creates a new call builder for the [`createPair`] function.
                pub fn createPair(
                    &self,
                    tokenA: ::alloy::sol_types::private::Address,
                    tokenB: ::alloy::sol_types::private::Address,
                ) -> alloy_contract::SolCallBuilder<T, &P, createPairCall, N> {
                    self.call_builder(&createPairCall { tokenA, tokenB })
                }
                ///Creates a new call builder for the [`feeTo`] function.
                pub fn feeTo(
                    &self,
                ) -> alloy_contract::SolCallBuilder<T, &P, feeToCall, N> {
                    self.call_builder(&feeToCall {})
                }
                ///Creates a new call builder for the [`feeToSetter`] function.
                pub fn feeToSetter(
                    &self,
                ) -> alloy_contract::SolCallBuilder<T, &P, feeToSetterCall, N> {
                    self.call_builder(&feeToSetterCall {})
                }
                ///Creates a new call builder for the [`getPair`] function.
                pub fn getPair(
                    &self,
                    _0: ::alloy::sol_types::private::Address,
                    _1: ::alloy::sol_types::private::Address,
                ) -> alloy_contract::SolCallBuilder<T, &P, getPairCall, N> {
                    self.call_builder(&getPairCall { _0, _1 })
                }
                ///Creates a new call builder for the [`migrator`] function.
                pub fn migrator(
                    &self,
                ) -> alloy_contract::SolCallBuilder<T, &P, migratorCall, N> {
                    self.call_builder(&migratorCall {})
                }
                ///Creates a new call builder for the [`pairCodeHash`] function.
                pub fn pairCodeHash(
                    &self,
                ) -> alloy_contract::SolCallBuilder<T, &P, pairCodeHashCall, N> {
                    self.call_builder(&pairCodeHashCall {})
                }
                ///Creates a new call builder for the [`setFeeTo`] function.
                pub fn setFeeTo(
                    &self,
                    _feeTo: ::alloy::sol_types::private::Address,
                ) -> alloy_contract::SolCallBuilder<T, &P, setFeeToCall, N> {
                    self.call_builder(&setFeeToCall { _feeTo })
                }
                ///Creates a new call builder for the [`setFeeToSetter`] function.
                pub fn setFeeToSetter(
                    &self,
                    _feeToSetter: ::alloy::sol_types::private::Address,
                ) -> alloy_contract::SolCallBuilder<T, &P, setFeeToSetterCall, N> {
                    self.call_builder(&setFeeToSetterCall { _feeToSetter })
                }
                ///Creates a new call builder for the [`setMigrator`] function.
                pub fn setMigrator(
                    &self,
                    _migrator: ::alloy::sol_types::private::Address,
                ) -> alloy_contract::SolCallBuilder<T, &P, setMigratorCall, N> {
                    self.call_builder(&setMigratorCall { _migrator })
                }
            }
            /// Event filters.
            #[automatically_derived]
            impl<
                T: alloy_contract::private::Transport + ::core::clone::Clone,
                P: alloy_contract::private::Provider<T, N>,
                N: alloy_contract::private::Network,
            > SushiSwapV2FactoryInstance<T, P, N> {
                /// Creates a new event filter using this contract instance's provider and address.
                ///
                /// Note that the type can be any event, not just those defined in this contract.
                /// Prefer using the other methods for building type-safe event filters.
                pub fn event_filter<E: alloy_sol_types::SolEvent>(
                    &self,
                ) -> alloy_contract::Event<T, &P, E, N> {
                    alloy_contract::Event::new_sol(&self.provider, &self.address)
                }
                ///Creates a new event filter for the [`PairCreated`] event.
                pub fn PairCreated_filter(
                    &self,
                ) -> alloy_contract::Event<T, &P, PairCreated, N> {
                    self.event_filter::<PairCreated>()
                }
            }
        }
        const _: &'static [u8] = b"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"indexed\":true,\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"}],\"name\":\"FeeAmountEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"PoolCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"}],\"name\":\"createPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"}],\"name\":\"enableFeeAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"name\":\"feeAmountTickSpacing\",\"outputs\":[{\"internalType\":\"int24\",\"name\":\"\",\"type\":\"int24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"name\":\"getPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"parameters\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]";
        /**

Generated by the following Solidity interface...
```solidity
interface SushiSwapV3Factory {
    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);
    event OwnerChanged(address indexed oldOwner, address indexed newOwner);
    event PoolCreated(address indexed token0, address indexed token1, uint24 indexed fee, int24 tickSpacing, address pool);

    constructor();

    function createPool(address tokenA, address tokenB, uint24 fee) external returns (address pool);
    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;
    function feeAmountTickSpacing(uint24) external view returns (int24);
    function getPool(address, address, uint24) external view returns (address);
    function owner() external view returns (address);
    function parameters() external view returns (address factory, address token0, address token1, uint24 fee, int24 tickSpacing);
    function setOwner(address _owner) external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "createPool",
    "inputs": [
      {
        "name": "tokenA",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "tokenB",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "fee",
        "type": "uint24",
        "internalType": "uint24"
      }
    ],
    "outputs": [
      {
        "name": "pool",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "enableFeeAmount",
    "inputs": [
      {
        "name": "fee",
        "type": "uint24",
        "internalType": "uint24"
      },
      {
        "name": "tickSpacing",
        "type": "int24",
        "internalType": "int24"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "feeAmountTickSpacing",
    "inputs": [
      {
        "name": "",
        "type": "uint24",
        "internalType": "uint24"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "int24",
        "internalType": "int24"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getPool",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "",
        "type": "uint24",
        "internalType": "uint24"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "owner",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "parameters",
    "inputs": [],
    "outputs": [
      {
        "name": "factory",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "token0",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "token1",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "fee",
        "type": "uint24",
        "internalType": "uint24"
      },
      {
        "name": "tickSpacing",
        "type": "int24",
        "internalType": "int24"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "setOwner",
    "inputs": [
      {
        "name": "_owner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "FeeAmountEnabled",
    "inputs": [
      {
        "name": "fee",
        "type": "uint24",
        "indexed": true,
        "internalType": "uint24"
      },
      {
        "name": "tickSpacing",
        "type": "int24",
        "indexed": true,
        "internalType": "int24"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OwnerChanged",
    "inputs": [
      {
        "name": "oldOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "PoolCreated",
    "inputs": [
      {
        "name": "token0",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "token1",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "fee",
        "type": "uint24",
        "indexed": true,
        "internalType": "uint24"
      },
      {
        "name": "tickSpacing",
        "type": "int24",
        "indexed": false,
        "internalType": "int24"
      },
      {
        "name": "pool",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  }
]
```*/
        #[allow(non_camel_case_types, non_snake_case, clippy::style)]
        pub mod SushiSwapV3Factory {
            use super::*;
            use ::alloy::sol_types as alloy_sol_types;
            /**Event with signature `FeeAmountEnabled(uint24,int24)` and selector `0xc66a3fdf07232cdd185febcc6579d408c241b47ae2f9907d84be655141eeaecc`.
```solidity
event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);
```*/
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            pub struct FeeAmountEnabled {
                #[allow(missing_docs)]
                pub fee: <::alloy::sol_types::sol_data::Uint<
                    24,
                > as ::alloy::sol_types::SolType>::RustType,
                #[allow(missing_docs)]
                pub tickSpacing: <::alloy::sol_types::sol_data::Int<
                    24,
                > as ::alloy::sol_types::SolType>::RustType,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            impl ::core::clone::Clone for FeeAmountEnabled {
                #[inline]
                fn clone(&self) -> FeeAmountEnabled {
                    FeeAmountEnabled {
                        fee: ::core::clone::Clone::clone(&self.fee),
                        tickSpacing: ::core::clone::Clone::clone(&self.tickSpacing),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            impl ::core::fmt::Debug for FeeAmountEnabled {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "FeeAmountEnabled",
                        "fee",
                        &self.fee,
                        "tickSpacing",
                        &&self.tickSpacing,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                #[automatically_derived]
                impl alloy_sol_types::SolEvent for FeeAmountEnabled {
                    type DataTuple<'a> = ();
                    type DataToken<'a> = <Self::DataTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type TopicList = (
                        alloy_sol_types::sol_data::FixedBytes<32>,
                        ::alloy::sol_types::sol_data::Uint<24>,
                        ::alloy::sol_types::sol_data::Int<24>,
                    );
                    const SIGNATURE: &'static str = "FeeAmountEnabled(uint24,int24)";
                    const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                        198u8,
                        106u8,
                        63u8,
                        223u8,
                        7u8,
                        35u8,
                        44u8,
                        221u8,
                        24u8,
                        95u8,
                        235u8,
                        204u8,
                        101u8,
                        121u8,
                        212u8,
                        8u8,
                        194u8,
                        65u8,
                        180u8,
                        122u8,
                        226u8,
                        249u8,
                        144u8,
                        125u8,
                        132u8,
                        190u8,
                        101u8,
                        81u8,
                        65u8,
                        238u8,
                        174u8,
                        204u8,
                    ]);
                    const ANONYMOUS: bool = false;
                    #[allow(unused_variables)]
                    #[inline]
                    fn new(
                        topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                        data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        Self {
                            fee: topics.1,
                            tickSpacing: topics.2,
                        }
                    }
                    #[inline]
                    fn tokenize_body(&self) -> Self::DataToken<'_> {
                        ()
                    }
                    #[inline]
                    fn topics(
                        &self,
                    ) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                        (
                            Self::SIGNATURE_HASH.into(),
                            self.fee.clone(),
                            self.tickSpacing.clone(),
                        )
                    }
                    #[inline]
                    fn encode_topics_raw(
                        &self,
                        out: &mut [alloy_sol_types::abi::token::WordToken],
                    ) -> alloy_sol_types::Result<()> {
                        if out.len()
                            < <Self::TopicList as alloy_sol_types::TopicList>::COUNT
                        {
                            return Err(alloy_sol_types::Error::Overrun);
                        }
                        out[0usize] = alloy_sol_types::abi::token::WordToken(
                            Self::SIGNATURE_HASH,
                        );
                        out[1usize] = <::alloy::sol_types::sol_data::Uint<
                            24,
                        > as alloy_sol_types::EventTopic>::encode_topic(&self.fee);
                        out[2usize] = <::alloy::sol_types::sol_data::Int<
                            24,
                        > as alloy_sol_types::EventTopic>::encode_topic(
                            &self.tickSpacing,
                        );
                        Ok(())
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::private::IntoLogData for FeeAmountEnabled {
                    fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                        From::from(self)
                    }
                    fn into_log_data(self) -> alloy_sol_types::private::LogData {
                        From::from(&self)
                    }
                }
                #[automatically_derived]
                impl From<&FeeAmountEnabled> for alloy_sol_types::private::LogData {
                    #[inline]
                    fn from(
                        this: &FeeAmountEnabled,
                    ) -> alloy_sol_types::private::LogData {
                        alloy_sol_types::SolEvent::encode_log_data(this)
                    }
                }
            };
            /**Event with signature `OwnerChanged(address,address)` and selector `0xb532073b38c83145e3e5135377a08bf9aab55bc0fd7c1179cd4fb995d2a5159c`.
```solidity
event OwnerChanged(address indexed oldOwner, address indexed newOwner);
```*/
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            pub struct OwnerChanged {
                #[allow(missing_docs)]
                pub oldOwner: ::alloy::sol_types::private::Address,
                #[allow(missing_docs)]
                pub newOwner: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            impl ::core::clone::Clone for OwnerChanged {
                #[inline]
                fn clone(&self) -> OwnerChanged {
                    OwnerChanged {
                        oldOwner: ::core::clone::Clone::clone(&self.oldOwner),
                        newOwner: ::core::clone::Clone::clone(&self.newOwner),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            impl ::core::fmt::Debug for OwnerChanged {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "OwnerChanged",
                        "oldOwner",
                        &self.oldOwner,
                        "newOwner",
                        &&self.newOwner,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                #[automatically_derived]
                impl alloy_sol_types::SolEvent for OwnerChanged {
                    type DataTuple<'a> = ();
                    type DataToken<'a> = <Self::DataTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type TopicList = (
                        alloy_sol_types::sol_data::FixedBytes<32>,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                    );
                    const SIGNATURE: &'static str = "OwnerChanged(address,address)";
                    const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                        181u8,
                        50u8,
                        7u8,
                        59u8,
                        56u8,
                        200u8,
                        49u8,
                        69u8,
                        227u8,
                        229u8,
                        19u8,
                        83u8,
                        119u8,
                        160u8,
                        139u8,
                        249u8,
                        170u8,
                        181u8,
                        91u8,
                        192u8,
                        253u8,
                        124u8,
                        17u8,
                        121u8,
                        205u8,
                        79u8,
                        185u8,
                        149u8,
                        210u8,
                        165u8,
                        21u8,
                        156u8,
                    ]);
                    const ANONYMOUS: bool = false;
                    #[allow(unused_variables)]
                    #[inline]
                    fn new(
                        topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                        data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        Self {
                            oldOwner: topics.1,
                            newOwner: topics.2,
                        }
                    }
                    #[inline]
                    fn tokenize_body(&self) -> Self::DataToken<'_> {
                        ()
                    }
                    #[inline]
                    fn topics(
                        &self,
                    ) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                        (
                            Self::SIGNATURE_HASH.into(),
                            self.oldOwner.clone(),
                            self.newOwner.clone(),
                        )
                    }
                    #[inline]
                    fn encode_topics_raw(
                        &self,
                        out: &mut [alloy_sol_types::abi::token::WordToken],
                    ) -> alloy_sol_types::Result<()> {
                        if out.len()
                            < <Self::TopicList as alloy_sol_types::TopicList>::COUNT
                        {
                            return Err(alloy_sol_types::Error::Overrun);
                        }
                        out[0usize] = alloy_sol_types::abi::token::WordToken(
                            Self::SIGNATURE_HASH,
                        );
                        out[1usize] = <::alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                            &self.oldOwner,
                        );
                        out[2usize] = <::alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                            &self.newOwner,
                        );
                        Ok(())
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::private::IntoLogData for OwnerChanged {
                    fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                        From::from(self)
                    }
                    fn into_log_data(self) -> alloy_sol_types::private::LogData {
                        From::from(&self)
                    }
                }
                #[automatically_derived]
                impl From<&OwnerChanged> for alloy_sol_types::private::LogData {
                    #[inline]
                    fn from(this: &OwnerChanged) -> alloy_sol_types::private::LogData {
                        alloy_sol_types::SolEvent::encode_log_data(this)
                    }
                }
            };
            /**Event with signature `PoolCreated(address,address,uint24,int24,address)` and selector `0x783cca1c0412dd0d695e784568c96da2e9c22ff989357a2e8b1d9b2b4e6b7118`.
```solidity
event PoolCreated(address indexed token0, address indexed token1, uint24 indexed fee, int24 tickSpacing, address pool);
```*/
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            pub struct PoolCreated {
                #[allow(missing_docs)]
                pub token0: ::alloy::sol_types::private::Address,
                #[allow(missing_docs)]
                pub token1: ::alloy::sol_types::private::Address,
                #[allow(missing_docs)]
                pub fee: <::alloy::sol_types::sol_data::Uint<
                    24,
                > as ::alloy::sol_types::SolType>::RustType,
                #[allow(missing_docs)]
                pub tickSpacing: <::alloy::sol_types::sol_data::Int<
                    24,
                > as ::alloy::sol_types::SolType>::RustType,
                #[allow(missing_docs)]
                pub pool: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            impl ::core::clone::Clone for PoolCreated {
                #[inline]
                fn clone(&self) -> PoolCreated {
                    PoolCreated {
                        token0: ::core::clone::Clone::clone(&self.token0),
                        token1: ::core::clone::Clone::clone(&self.token1),
                        fee: ::core::clone::Clone::clone(&self.fee),
                        tickSpacing: ::core::clone::Clone::clone(&self.tickSpacing),
                        pool: ::core::clone::Clone::clone(&self.pool),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            impl ::core::fmt::Debug for PoolCreated {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "PoolCreated",
                        "token0",
                        &self.token0,
                        "token1",
                        &self.token1,
                        "fee",
                        &self.fee,
                        "tickSpacing",
                        &self.tickSpacing,
                        "pool",
                        &&self.pool,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                #[automatically_derived]
                impl alloy_sol_types::SolEvent for PoolCreated {
                    type DataTuple<'a> = (
                        ::alloy::sol_types::sol_data::Int<24>,
                        ::alloy::sol_types::sol_data::Address,
                    );
                    type DataToken<'a> = <Self::DataTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type TopicList = (
                        alloy_sol_types::sol_data::FixedBytes<32>,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Uint<24>,
                    );
                    const SIGNATURE: &'static str = "PoolCreated(address,address,uint24,int24,address)";
                    const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                        120u8,
                        60u8,
                        202u8,
                        28u8,
                        4u8,
                        18u8,
                        221u8,
                        13u8,
                        105u8,
                        94u8,
                        120u8,
                        69u8,
                        104u8,
                        201u8,
                        109u8,
                        162u8,
                        233u8,
                        194u8,
                        47u8,
                        249u8,
                        137u8,
                        53u8,
                        122u8,
                        46u8,
                        139u8,
                        29u8,
                        155u8,
                        43u8,
                        78u8,
                        107u8,
                        113u8,
                        24u8,
                    ]);
                    const ANONYMOUS: bool = false;
                    #[allow(unused_variables)]
                    #[inline]
                    fn new(
                        topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                        data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        Self {
                            token0: topics.1,
                            token1: topics.2,
                            fee: topics.3,
                            tickSpacing: data.0,
                            pool: data.1,
                        }
                    }
                    #[inline]
                    fn tokenize_body(&self) -> Self::DataToken<'_> {
                        (
                            <::alloy::sol_types::sol_data::Int<
                                24,
                            > as alloy_sol_types::SolType>::tokenize(&self.tickSpacing),
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self.pool,
                            ),
                        )
                    }
                    #[inline]
                    fn topics(
                        &self,
                    ) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                        (
                            Self::SIGNATURE_HASH.into(),
                            self.token0.clone(),
                            self.token1.clone(),
                            self.fee.clone(),
                        )
                    }
                    #[inline]
                    fn encode_topics_raw(
                        &self,
                        out: &mut [alloy_sol_types::abi::token::WordToken],
                    ) -> alloy_sol_types::Result<()> {
                        if out.len()
                            < <Self::TopicList as alloy_sol_types::TopicList>::COUNT
                        {
                            return Err(alloy_sol_types::Error::Overrun);
                        }
                        out[0usize] = alloy_sol_types::abi::token::WordToken(
                            Self::SIGNATURE_HASH,
                        );
                        out[1usize] = <::alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                            &self.token0,
                        );
                        out[2usize] = <::alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                            &self.token1,
                        );
                        out[3usize] = <::alloy::sol_types::sol_data::Uint<
                            24,
                        > as alloy_sol_types::EventTopic>::encode_topic(&self.fee);
                        Ok(())
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::private::IntoLogData for PoolCreated {
                    fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                        From::from(self)
                    }
                    fn into_log_data(self) -> alloy_sol_types::private::LogData {
                        From::from(&self)
                    }
                }
                #[automatically_derived]
                impl From<&PoolCreated> for alloy_sol_types::private::LogData {
                    #[inline]
                    fn from(this: &PoolCreated) -> alloy_sol_types::private::LogData {
                        alloy_sol_types::SolEvent::encode_log_data(this)
                    }
                }
            };
            /**Constructor`.
```solidity
constructor();
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct constructorCall {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for constructorCall {
                #[inline]
                fn clone(&self) -> constructorCall {
                    constructorCall {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for constructorCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "constructorCall")
                }
            }
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<constructorCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: constructorCall) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for constructorCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolConstructor for constructorCall {
                    type Parameters<'a> = ();
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                }
            };
            /**Function with signature `createPool(address,address,uint24)` and selector `0xa1671295`.
```solidity
function createPool(address tokenA, address tokenB, uint24 fee) external returns (address pool);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct createPoolCall {
                pub tokenA: ::alloy::sol_types::private::Address,
                pub tokenB: ::alloy::sol_types::private::Address,
                pub fee: <::alloy::sol_types::sol_data::Uint<
                    24,
                > as ::alloy::sol_types::SolType>::RustType,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for createPoolCall {
                #[inline]
                fn clone(&self) -> createPoolCall {
                    createPoolCall {
                        tokenA: ::core::clone::Clone::clone(&self.tokenA),
                        tokenB: ::core::clone::Clone::clone(&self.tokenB),
                        fee: ::core::clone::Clone::clone(&self.fee),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for createPoolCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "createPoolCall",
                        "tokenA",
                        &self.tokenA,
                        "tokenB",
                        &self.tokenB,
                        "fee",
                        &&self.fee,
                    )
                }
            }
            ///Container type for the return parameters of the [`createPool(address,address,uint24)`](createPoolCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct createPoolReturn {
                pub pool: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for createPoolReturn {
                #[inline]
                fn clone(&self) -> createPoolReturn {
                    createPoolReturn {
                        pool: ::core::clone::Clone::clone(&self.pool),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for createPoolReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "createPoolReturn",
                        "pool",
                        &&self.pool,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Uint<24>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                        ::alloy::sol_types::private::Address,
                        <::alloy::sol_types::sol_data::Uint<
                            24,
                        > as ::alloy::sol_types::SolType>::RustType,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<createPoolCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: createPoolCall) -> Self {
                            (value.tokenA, value.tokenB, value.fee)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for createPoolCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {
                                tokenA: tuple.0,
                                tokenB: tuple.1,
                                fee: tuple.2,
                            }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<createPoolReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: createPoolReturn) -> Self {
                            (value.pool,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for createPoolReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { pool: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for createPoolCall {
                    type Parameters<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Uint<24>,
                    );
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = createPoolReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Address,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "createPool(address,address,uint24)";
                    const SELECTOR: [u8; 4] = [161u8, 103u8, 18u8, 149u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self.tokenA,
                            ),
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self.tokenB,
                            ),
                            <::alloy::sol_types::sol_data::Uint<
                                24,
                            > as alloy_sol_types::SolType>::tokenize(&self.fee),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `enableFeeAmount(uint24,int24)` and selector `0x8a7c195f`.
```solidity
function enableFeeAmount(uint24 fee, int24 tickSpacing) external;
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct enableFeeAmountCall {
                pub fee: <::alloy::sol_types::sol_data::Uint<
                    24,
                > as ::alloy::sol_types::SolType>::RustType,
                pub tickSpacing: <::alloy::sol_types::sol_data::Int<
                    24,
                > as ::alloy::sol_types::SolType>::RustType,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for enableFeeAmountCall {
                #[inline]
                fn clone(&self) -> enableFeeAmountCall {
                    enableFeeAmountCall {
                        fee: ::core::clone::Clone::clone(&self.fee),
                        tickSpacing: ::core::clone::Clone::clone(&self.tickSpacing),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for enableFeeAmountCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "enableFeeAmountCall",
                        "fee",
                        &self.fee,
                        "tickSpacing",
                        &&self.tickSpacing,
                    )
                }
            }
            ///Container type for the return parameters of the [`enableFeeAmount(uint24,int24)`](enableFeeAmountCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct enableFeeAmountReturn {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for enableFeeAmountReturn {
                #[inline]
                fn clone(&self) -> enableFeeAmountReturn {
                    enableFeeAmountReturn {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for enableFeeAmountReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "enableFeeAmountReturn")
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Uint<24>,
                        ::alloy::sol_types::sol_data::Int<24>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        <::alloy::sol_types::sol_data::Uint<
                            24,
                        > as ::alloy::sol_types::SolType>::RustType,
                        <::alloy::sol_types::sol_data::Int<
                            24,
                        > as ::alloy::sol_types::SolType>::RustType,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<enableFeeAmountCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: enableFeeAmountCall) -> Self {
                            (value.fee, value.tickSpacing)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for enableFeeAmountCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {
                                fee: tuple.0,
                                tickSpacing: tuple.1,
                            }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<enableFeeAmountReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: enableFeeAmountReturn) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for enableFeeAmountReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for enableFeeAmountCall {
                    type Parameters<'a> = (
                        ::alloy::sol_types::sol_data::Uint<24>,
                        ::alloy::sol_types::sol_data::Int<24>,
                    );
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = enableFeeAmountReturn;
                    type ReturnTuple<'a> = ();
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "enableFeeAmount(uint24,int24)";
                    const SELECTOR: [u8; 4] = [138u8, 124u8, 25u8, 95u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Uint<
                                24,
                            > as alloy_sol_types::SolType>::tokenize(&self.fee),
                            <::alloy::sol_types::sol_data::Int<
                                24,
                            > as alloy_sol_types::SolType>::tokenize(&self.tickSpacing),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `feeAmountTickSpacing(uint24)` and selector `0x22afcccb`.
```solidity
function feeAmountTickSpacing(uint24) external view returns (int24);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct feeAmountTickSpacingCall {
                pub _0: <::alloy::sol_types::sol_data::Uint<
                    24,
                > as ::alloy::sol_types::SolType>::RustType,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for feeAmountTickSpacingCall {
                #[inline]
                fn clone(&self) -> feeAmountTickSpacingCall {
                    feeAmountTickSpacingCall {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for feeAmountTickSpacingCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "feeAmountTickSpacingCall",
                        "_0",
                        &&self._0,
                    )
                }
            }
            ///Container type for the return parameters of the [`feeAmountTickSpacing(uint24)`](feeAmountTickSpacingCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct feeAmountTickSpacingReturn {
                pub _0: <::alloy::sol_types::sol_data::Int<
                    24,
                > as ::alloy::sol_types::SolType>::RustType,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for feeAmountTickSpacingReturn {
                #[inline]
                fn clone(&self) -> feeAmountTickSpacingReturn {
                    feeAmountTickSpacingReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for feeAmountTickSpacingReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "feeAmountTickSpacingReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Uint<24>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        <::alloy::sol_types::sol_data::Uint<
                            24,
                        > as ::alloy::sol_types::SolType>::RustType,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<feeAmountTickSpacingCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: feeAmountTickSpacingCall) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for feeAmountTickSpacingCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Int<24>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        <::alloy::sol_types::sol_data::Int<
                            24,
                        > as ::alloy::sol_types::SolType>::RustType,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<feeAmountTickSpacingReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: feeAmountTickSpacingReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for feeAmountTickSpacingReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for feeAmountTickSpacingCall {
                    type Parameters<'a> = (::alloy::sol_types::sol_data::Uint<24>,);
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = feeAmountTickSpacingReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Int<24>,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "feeAmountTickSpacing(uint24)";
                    const SELECTOR: [u8; 4] = [34u8, 175u8, 204u8, 203u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Uint<
                                24,
                            > as alloy_sol_types::SolType>::tokenize(&self._0),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `getPool(address,address,uint24)` and selector `0x1698ee82`.
```solidity
function getPool(address, address, uint24) external view returns (address);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct getPoolCall {
                pub _0: ::alloy::sol_types::private::Address,
                pub _1: ::alloy::sol_types::private::Address,
                pub _2: <::alloy::sol_types::sol_data::Uint<
                    24,
                > as ::alloy::sol_types::SolType>::RustType,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for getPoolCall {
                #[inline]
                fn clone(&self) -> getPoolCall {
                    getPoolCall {
                        _0: ::core::clone::Clone::clone(&self._0),
                        _1: ::core::clone::Clone::clone(&self._1),
                        _2: ::core::clone::Clone::clone(&self._2),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for getPoolCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "getPoolCall",
                        "_0",
                        &self._0,
                        "_1",
                        &self._1,
                        "_2",
                        &&self._2,
                    )
                }
            }
            ///Container type for the return parameters of the [`getPool(address,address,uint24)`](getPoolCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct getPoolReturn {
                pub _0: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for getPoolReturn {
                #[inline]
                fn clone(&self) -> getPoolReturn {
                    getPoolReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for getPoolReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "getPoolReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Uint<24>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                        ::alloy::sol_types::private::Address,
                        <::alloy::sol_types::sol_data::Uint<
                            24,
                        > as ::alloy::sol_types::SolType>::RustType,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<getPoolCall> for UnderlyingRustTuple<'_> {
                        fn from(value: getPoolCall) -> Self {
                            (value._0, value._1, value._2)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>> for getPoolCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {
                                _0: tuple.0,
                                _1: tuple.1,
                                _2: tuple.2,
                            }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<getPoolReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: getPoolReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for getPoolReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for getPoolCall {
                    type Parameters<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Uint<24>,
                    );
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = getPoolReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Address,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "getPool(address,address,uint24)";
                    const SELECTOR: [u8; 4] = [22u8, 152u8, 238u8, 130u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self._0,
                            ),
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self._1,
                            ),
                            <::alloy::sol_types::sol_data::Uint<
                                24,
                            > as alloy_sol_types::SolType>::tokenize(&self._2),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `owner()` and selector `0x8da5cb5b`.
```solidity
function owner() external view returns (address);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct ownerCall {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for ownerCall {
                #[inline]
                fn clone(&self) -> ownerCall {
                    ownerCall {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for ownerCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "ownerCall")
                }
            }
            ///Container type for the return parameters of the [`owner()`](ownerCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct ownerReturn {
                pub _0: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for ownerReturn {
                #[inline]
                fn clone(&self) -> ownerReturn {
                    ownerReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for ownerReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "ownerReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<ownerCall> for UnderlyingRustTuple<'_> {
                        fn from(value: ownerCall) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<ownerReturn> for UnderlyingRustTuple<'_> {
                        fn from(value: ownerReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for ownerCall {
                    type Parameters<'a> = ();
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = ownerReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Address,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "owner()";
                    const SELECTOR: [u8; 4] = [141u8, 165u8, 203u8, 91u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `parameters()` and selector `0x89035730`.
```solidity
function parameters() external view returns (address factory, address token0, address token1, uint24 fee, int24 tickSpacing);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct parametersCall {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for parametersCall {
                #[inline]
                fn clone(&self) -> parametersCall {
                    parametersCall {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for parametersCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "parametersCall")
                }
            }
            ///Container type for the return parameters of the [`parameters()`](parametersCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct parametersReturn {
                pub factory: ::alloy::sol_types::private::Address,
                pub token0: ::alloy::sol_types::private::Address,
                pub token1: ::alloy::sol_types::private::Address,
                pub fee: <::alloy::sol_types::sol_data::Uint<
                    24,
                > as ::alloy::sol_types::SolType>::RustType,
                pub tickSpacing: <::alloy::sol_types::sol_data::Int<
                    24,
                > as ::alloy::sol_types::SolType>::RustType,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for parametersReturn {
                #[inline]
                fn clone(&self) -> parametersReturn {
                    parametersReturn {
                        factory: ::core::clone::Clone::clone(&self.factory),
                        token0: ::core::clone::Clone::clone(&self.token0),
                        token1: ::core::clone::Clone::clone(&self.token1),
                        fee: ::core::clone::Clone::clone(&self.fee),
                        tickSpacing: ::core::clone::Clone::clone(&self.tickSpacing),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for parametersReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "parametersReturn",
                        "factory",
                        &self.factory,
                        "token0",
                        &self.token0,
                        "token1",
                        &self.token1,
                        "fee",
                        &self.fee,
                        "tickSpacing",
                        &&self.tickSpacing,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<parametersCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: parametersCall) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for parametersCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Uint<24>,
                        ::alloy::sol_types::sol_data::Int<24>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                        ::alloy::sol_types::private::Address,
                        ::alloy::sol_types::private::Address,
                        <::alloy::sol_types::sol_data::Uint<
                            24,
                        > as ::alloy::sol_types::SolType>::RustType,
                        <::alloy::sol_types::sol_data::Int<
                            24,
                        > as ::alloy::sol_types::SolType>::RustType,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<parametersReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: parametersReturn) -> Self {
                            (
                                value.factory,
                                value.token0,
                                value.token1,
                                value.fee,
                                value.tickSpacing,
                            )
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for parametersReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {
                                factory: tuple.0,
                                token0: tuple.1,
                                token1: tuple.2,
                                fee: tuple.3,
                                tickSpacing: tuple.4,
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for parametersCall {
                    type Parameters<'a> = ();
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = parametersReturn;
                    type ReturnTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Uint<24>,
                        ::alloy::sol_types::sol_data::Int<24>,
                    );
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "parameters()";
                    const SELECTOR: [u8; 4] = [137u8, 3u8, 87u8, 48u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `setOwner(address)` and selector `0x13af4035`.
```solidity
function setOwner(address _owner) external;
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct setOwnerCall {
                pub _owner: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for setOwnerCall {
                #[inline]
                fn clone(&self) -> setOwnerCall {
                    setOwnerCall {
                        _owner: ::core::clone::Clone::clone(&self._owner),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for setOwnerCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "setOwnerCall",
                        "_owner",
                        &&self._owner,
                    )
                }
            }
            ///Container type for the return parameters of the [`setOwner(address)`](setOwnerCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct setOwnerReturn {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for setOwnerReturn {
                #[inline]
                fn clone(&self) -> setOwnerReturn {
                    setOwnerReturn {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for setOwnerReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "setOwnerReturn")
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<setOwnerCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: setOwnerCall) -> Self {
                            (value._owner,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for setOwnerCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _owner: tuple.0 }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<setOwnerReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: setOwnerReturn) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for setOwnerReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for setOwnerCall {
                    type Parameters<'a> = (::alloy::sol_types::sol_data::Address,);
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = setOwnerReturn;
                    type ReturnTuple<'a> = ();
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "setOwner(address)";
                    const SELECTOR: [u8; 4] = [19u8, 175u8, 64u8, 53u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self._owner,
                            ),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            ///Container for all the [`SushiSwapV3Factory`](self) function calls.
            pub enum SushiSwapV3FactoryCalls {
                createPool(createPoolCall),
                enableFeeAmount(enableFeeAmountCall),
                feeAmountTickSpacing(feeAmountTickSpacingCall),
                getPool(getPoolCall),
                owner(ownerCall),
                parameters(parametersCall),
                setOwner(setOwnerCall),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for SushiSwapV3FactoryCalls {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        SushiSwapV3FactoryCalls::createPool(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "createPool",
                                &__self_0,
                            )
                        }
                        SushiSwapV3FactoryCalls::enableFeeAmount(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "enableFeeAmount",
                                &__self_0,
                            )
                        }
                        SushiSwapV3FactoryCalls::feeAmountTickSpacing(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "feeAmountTickSpacing",
                                &__self_0,
                            )
                        }
                        SushiSwapV3FactoryCalls::getPool(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "getPool",
                                &__self_0,
                            )
                        }
                        SushiSwapV3FactoryCalls::owner(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "owner",
                                &__self_0,
                            )
                        }
                        SushiSwapV3FactoryCalls::parameters(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "parameters",
                                &__self_0,
                            )
                        }
                        SushiSwapV3FactoryCalls::setOwner(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "setOwner",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl SushiSwapV3FactoryCalls {
                /// All the selectors of this enum.
                ///
                /// Note that the selectors might not be in the same order as the variants.
                /// No guarantees are made about the order of the selectors.
                ///
                /// Prefer using `SolInterface` methods instead.
                pub const SELECTORS: &'static [[u8; 4usize]] = &[
                    [19u8, 175u8, 64u8, 53u8],
                    [22u8, 152u8, 238u8, 130u8],
                    [34u8, 175u8, 204u8, 203u8],
                    [137u8, 3u8, 87u8, 48u8],
                    [138u8, 124u8, 25u8, 95u8],
                    [141u8, 165u8, 203u8, 91u8],
                    [161u8, 103u8, 18u8, 149u8],
                ];
            }
            #[automatically_derived]
            impl alloy_sol_types::SolInterface for SushiSwapV3FactoryCalls {
                const NAME: &'static str = "SushiSwapV3FactoryCalls";
                const MIN_DATA_LENGTH: usize = 0usize;
                const COUNT: usize = 7usize;
                #[inline]
                fn selector(&self) -> [u8; 4] {
                    match self {
                        Self::createPool(_) => {
                            <createPoolCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::enableFeeAmount(_) => {
                            <enableFeeAmountCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::feeAmountTickSpacing(_) => {
                            <feeAmountTickSpacingCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::getPool(_) => {
                            <getPoolCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::owner(_) => {
                            <ownerCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::parameters(_) => {
                            <parametersCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::setOwner(_) => {
                            <setOwnerCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                    }
                }
                #[inline]
                fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
                    Self::SELECTORS.get(i).copied()
                }
                #[inline]
                fn valid_selector(selector: [u8; 4]) -> bool {
                    Self::SELECTORS.binary_search(&selector).is_ok()
                }
                #[inline]
                #[allow(unsafe_code, non_snake_case)]
                fn abi_decode_raw(
                    selector: [u8; 4],
                    data: &[u8],
                    validate: bool,
                ) -> alloy_sol_types::Result<Self> {
                    static DECODE_SHIMS: &[fn(
                        &[u8],
                        bool,
                    ) -> alloy_sol_types::Result<SushiSwapV3FactoryCalls>] = &[
                        {
                            fn setOwner(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<SushiSwapV3FactoryCalls> {
                                <setOwnerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(SushiSwapV3FactoryCalls::setOwner)
                            }
                            setOwner
                        },
                        {
                            fn getPool(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<SushiSwapV3FactoryCalls> {
                                <getPoolCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(SushiSwapV3FactoryCalls::getPool)
                            }
                            getPool
                        },
                        {
                            fn feeAmountTickSpacing(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<SushiSwapV3FactoryCalls> {
                                <feeAmountTickSpacingCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(SushiSwapV3FactoryCalls::feeAmountTickSpacing)
                            }
                            feeAmountTickSpacing
                        },
                        {
                            fn parameters(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<SushiSwapV3FactoryCalls> {
                                <parametersCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(SushiSwapV3FactoryCalls::parameters)
                            }
                            parameters
                        },
                        {
                            fn enableFeeAmount(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<SushiSwapV3FactoryCalls> {
                                <enableFeeAmountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(SushiSwapV3FactoryCalls::enableFeeAmount)
                            }
                            enableFeeAmount
                        },
                        {
                            fn owner(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<SushiSwapV3FactoryCalls> {
                                <ownerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(SushiSwapV3FactoryCalls::owner)
                            }
                            owner
                        },
                        {
                            fn createPool(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<SushiSwapV3FactoryCalls> {
                                <createPoolCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(SushiSwapV3FactoryCalls::createPool)
                            }
                            createPool
                        },
                    ];
                    let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                        return Err(
                            alloy_sol_types::Error::unknown_selector(
                                <Self as alloy_sol_types::SolInterface>::NAME,
                                selector,
                            ),
                        );
                    };
                    (unsafe { DECODE_SHIMS.get_unchecked(idx) })(data, validate)
                }
                #[inline]
                fn abi_encoded_size(&self) -> usize {
                    match self {
                        Self::createPool(inner) => {
                            <createPoolCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::enableFeeAmount(inner) => {
                            <enableFeeAmountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::feeAmountTickSpacing(inner) => {
                            <feeAmountTickSpacingCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::getPool(inner) => {
                            <getPoolCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::owner(inner) => {
                            <ownerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::parameters(inner) => {
                            <parametersCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::setOwner(inner) => {
                            <setOwnerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                    }
                }
                #[inline]
                fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                    match self {
                        Self::createPool(inner) => {
                            <createPoolCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::enableFeeAmount(inner) => {
                            <enableFeeAmountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::feeAmountTickSpacing(inner) => {
                            <feeAmountTickSpacingCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::getPool(inner) => {
                            <getPoolCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::owner(inner) => {
                            <ownerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::parameters(inner) => {
                            <parametersCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::setOwner(inner) => {
                            <setOwnerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                    }
                }
            }
            ///Container for all the [`SushiSwapV3Factory`](self) events.
            pub enum SushiSwapV3FactoryEvents {
                FeeAmountEnabled(FeeAmountEnabled),
                OwnerChanged(OwnerChanged),
                PoolCreated(PoolCreated),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for SushiSwapV3FactoryEvents {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        SushiSwapV3FactoryEvents::FeeAmountEnabled(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "FeeAmountEnabled",
                                &__self_0,
                            )
                        }
                        SushiSwapV3FactoryEvents::OwnerChanged(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "OwnerChanged",
                                &__self_0,
                            )
                        }
                        SushiSwapV3FactoryEvents::PoolCreated(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "PoolCreated",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl SushiSwapV3FactoryEvents {
                /// All the selectors of this enum.
                ///
                /// Note that the selectors might not be in the same order as the variants.
                /// No guarantees are made about the order of the selectors.
                ///
                /// Prefer using `SolInterface` methods instead.
                pub const SELECTORS: &'static [[u8; 32usize]] = &[
                    [
                        120u8,
                        60u8,
                        202u8,
                        28u8,
                        4u8,
                        18u8,
                        221u8,
                        13u8,
                        105u8,
                        94u8,
                        120u8,
                        69u8,
                        104u8,
                        201u8,
                        109u8,
                        162u8,
                        233u8,
                        194u8,
                        47u8,
                        249u8,
                        137u8,
                        53u8,
                        122u8,
                        46u8,
                        139u8,
                        29u8,
                        155u8,
                        43u8,
                        78u8,
                        107u8,
                        113u8,
                        24u8,
                    ],
                    [
                        181u8,
                        50u8,
                        7u8,
                        59u8,
                        56u8,
                        200u8,
                        49u8,
                        69u8,
                        227u8,
                        229u8,
                        19u8,
                        83u8,
                        119u8,
                        160u8,
                        139u8,
                        249u8,
                        170u8,
                        181u8,
                        91u8,
                        192u8,
                        253u8,
                        124u8,
                        17u8,
                        121u8,
                        205u8,
                        79u8,
                        185u8,
                        149u8,
                        210u8,
                        165u8,
                        21u8,
                        156u8,
                    ],
                    [
                        198u8,
                        106u8,
                        63u8,
                        223u8,
                        7u8,
                        35u8,
                        44u8,
                        221u8,
                        24u8,
                        95u8,
                        235u8,
                        204u8,
                        101u8,
                        121u8,
                        212u8,
                        8u8,
                        194u8,
                        65u8,
                        180u8,
                        122u8,
                        226u8,
                        249u8,
                        144u8,
                        125u8,
                        132u8,
                        190u8,
                        101u8,
                        81u8,
                        65u8,
                        238u8,
                        174u8,
                        204u8,
                    ],
                ];
            }
            #[automatically_derived]
            impl alloy_sol_types::SolEventInterface for SushiSwapV3FactoryEvents {
                const NAME: &'static str = "SushiSwapV3FactoryEvents";
                const COUNT: usize = 3usize;
                fn decode_raw_log(
                    topics: &[alloy_sol_types::Word],
                    data: &[u8],
                    validate: bool,
                ) -> alloy_sol_types::Result<Self> {
                    match topics.first().copied() {
                        Some(
                            <FeeAmountEnabled as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                        ) => {
                            <FeeAmountEnabled as alloy_sol_types::SolEvent>::decode_raw_log(
                                    topics,
                                    data,
                                    validate,
                                )
                                .map(Self::FeeAmountEnabled)
                        }
                        Some(
                            <OwnerChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                        ) => {
                            <OwnerChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                                    topics,
                                    data,
                                    validate,
                                )
                                .map(Self::OwnerChanged)
                        }
                        Some(
                            <PoolCreated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                        ) => {
                            <PoolCreated as alloy_sol_types::SolEvent>::decode_raw_log(
                                    topics,
                                    data,
                                    validate,
                                )
                                .map(Self::PoolCreated)
                        }
                        _ => {
                            alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                                name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                                log: alloy_sol_types::private::Box::new(
                                    alloy_sol_types::private::LogData::new_unchecked(
                                        topics.to_vec(),
                                        data.to_vec().into(),
                                    ),
                                ),
                            })
                        }
                    }
                }
            }
            #[automatically_derived]
            impl alloy_sol_types::private::IntoLogData for SushiSwapV3FactoryEvents {
                fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                    match self {
                        Self::FeeAmountEnabled(inner) => {
                            alloy_sol_types::private::IntoLogData::to_log_data(inner)
                        }
                        Self::OwnerChanged(inner) => {
                            alloy_sol_types::private::IntoLogData::to_log_data(inner)
                        }
                        Self::PoolCreated(inner) => {
                            alloy_sol_types::private::IntoLogData::to_log_data(inner)
                        }
                    }
                }
                fn into_log_data(self) -> alloy_sol_types::private::LogData {
                    match self {
                        Self::FeeAmountEnabled(inner) => {
                            alloy_sol_types::private::IntoLogData::into_log_data(inner)
                        }
                        Self::OwnerChanged(inner) => {
                            alloy_sol_types::private::IntoLogData::into_log_data(inner)
                        }
                        Self::PoolCreated(inner) => {
                            alloy_sol_types::private::IntoLogData::into_log_data(inner)
                        }
                    }
                }
            }
            use ::alloy::contract as alloy_contract;
            /**Creates a new wrapper around an on-chain [`SushiSwapV3Factory`](self) contract instance.

See the [wrapper's documentation](`SushiSwapV3FactoryInstance`) for more details.*/
            #[inline]
            pub const fn new<
                T: alloy_contract::private::Transport + ::core::clone::Clone,
                P: alloy_contract::private::Provider<T, N>,
                N: alloy_contract::private::Network,
            >(
                address: alloy_sol_types::private::Address,
                provider: P,
            ) -> SushiSwapV3FactoryInstance<T, P, N> {
                SushiSwapV3FactoryInstance::<T, P, N>::new(address, provider)
            }
            /**A [`SushiSwapV3Factory`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`SushiSwapV3Factory`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
            pub struct SushiSwapV3FactoryInstance<
                T,
                P,
                N = alloy_contract::private::Ethereum,
            > {
                address: alloy_sol_types::private::Address,
                provider: P,
                _network_transport: ::core::marker::PhantomData<(N, T)>,
            }
            #[automatically_derived]
            impl<
                T: ::core::clone::Clone,
                P: ::core::clone::Clone,
                N: ::core::clone::Clone,
            > ::core::clone::Clone for SushiSwapV3FactoryInstance<T, P, N> {
                #[inline]
                fn clone(&self) -> SushiSwapV3FactoryInstance<T, P, N> {
                    SushiSwapV3FactoryInstance {
                        address: ::core::clone::Clone::clone(&self.address),
                        provider: ::core::clone::Clone::clone(&self.provider),
                        _network_transport: ::core::clone::Clone::clone(
                            &self._network_transport,
                        ),
                    }
                }
            }
            #[automatically_derived]
            impl<T, P, N> ::core::fmt::Debug for SushiSwapV3FactoryInstance<T, P, N> {
                #[inline]
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_tuple("SushiSwapV3FactoryInstance")
                        .field(&self.address)
                        .finish()
                }
            }
            /// Instantiation and getters/setters.
            #[automatically_derived]
            impl<
                T: alloy_contract::private::Transport + ::core::clone::Clone,
                P: alloy_contract::private::Provider<T, N>,
                N: alloy_contract::private::Network,
            > SushiSwapV3FactoryInstance<T, P, N> {
                /**Creates a new wrapper around an on-chain [`SushiSwapV3Factory`](self) contract instance.

See the [wrapper's documentation](`SushiSwapV3FactoryInstance`) for more details.*/
                #[inline]
                pub const fn new(
                    address: alloy_sol_types::private::Address,
                    provider: P,
                ) -> Self {
                    Self {
                        address,
                        provider,
                        _network_transport: ::core::marker::PhantomData,
                    }
                }
                /// Returns a reference to the address.
                #[inline]
                pub const fn address(&self) -> &alloy_sol_types::private::Address {
                    &self.address
                }
                /// Sets the address.
                #[inline]
                pub fn set_address(
                    &mut self,
                    address: alloy_sol_types::private::Address,
                ) {
                    self.address = address;
                }
                /// Sets the address and returns `self`.
                pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
                    self.set_address(address);
                    self
                }
                /// Returns a reference to the provider.
                #[inline]
                pub const fn provider(&self) -> &P {
                    &self.provider
                }
            }
            impl<T, P: ::core::clone::Clone, N> SushiSwapV3FactoryInstance<T, &P, N> {
                /// Clones the provider and returns a new instance with the cloned provider.
                #[inline]
                pub fn with_cloned_provider(
                    self,
                ) -> SushiSwapV3FactoryInstance<T, P, N> {
                    SushiSwapV3FactoryInstance {
                        address: self.address,
                        provider: ::core::clone::Clone::clone(&self.provider),
                        _network_transport: ::core::marker::PhantomData,
                    }
                }
            }
            /// Function calls.
            #[automatically_derived]
            impl<
                T: alloy_contract::private::Transport + ::core::clone::Clone,
                P: alloy_contract::private::Provider<T, N>,
                N: alloy_contract::private::Network,
            > SushiSwapV3FactoryInstance<T, P, N> {
                /// Creates a new call builder using this contract instance's provider and address.
                ///
                /// Note that the call can be any function call, not just those defined in this
                /// contract. Prefer using the other methods for building type-safe contract calls.
                pub fn call_builder<C: alloy_sol_types::SolCall>(
                    &self,
                    call: &C,
                ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
                    alloy_contract::SolCallBuilder::new_sol(
                        &self.provider,
                        &self.address,
                        call,
                    )
                }
                ///Creates a new call builder for the [`createPool`] function.
                pub fn createPool(
                    &self,
                    tokenA: ::alloy::sol_types::private::Address,
                    tokenB: ::alloy::sol_types::private::Address,
                    fee: <::alloy::sol_types::sol_data::Uint<
                        24,
                    > as ::alloy::sol_types::SolType>::RustType,
                ) -> alloy_contract::SolCallBuilder<T, &P, createPoolCall, N> {
                    self.call_builder(
                        &createPoolCall {
                            tokenA,
                            tokenB,
                            fee,
                        },
                    )
                }
                ///Creates a new call builder for the [`enableFeeAmount`] function.
                pub fn enableFeeAmount(
                    &self,
                    fee: <::alloy::sol_types::sol_data::Uint<
                        24,
                    > as ::alloy::sol_types::SolType>::RustType,
                    tickSpacing: <::alloy::sol_types::sol_data::Int<
                        24,
                    > as ::alloy::sol_types::SolType>::RustType,
                ) -> alloy_contract::SolCallBuilder<T, &P, enableFeeAmountCall, N> {
                    self.call_builder(
                        &enableFeeAmountCall {
                            fee,
                            tickSpacing,
                        },
                    )
                }
                ///Creates a new call builder for the [`feeAmountTickSpacing`] function.
                pub fn feeAmountTickSpacing(
                    &self,
                    _0: <::alloy::sol_types::sol_data::Uint<
                        24,
                    > as ::alloy::sol_types::SolType>::RustType,
                ) -> alloy_contract::SolCallBuilder<T, &P, feeAmountTickSpacingCall, N> {
                    self.call_builder(&feeAmountTickSpacingCall { _0 })
                }
                ///Creates a new call builder for the [`getPool`] function.
                pub fn getPool(
                    &self,
                    _0: ::alloy::sol_types::private::Address,
                    _1: ::alloy::sol_types::private::Address,
                    _2: <::alloy::sol_types::sol_data::Uint<
                        24,
                    > as ::alloy::sol_types::SolType>::RustType,
                ) -> alloy_contract::SolCallBuilder<T, &P, getPoolCall, N> {
                    self.call_builder(&getPoolCall { _0, _1, _2 })
                }
                ///Creates a new call builder for the [`owner`] function.
                pub fn owner(
                    &self,
                ) -> alloy_contract::SolCallBuilder<T, &P, ownerCall, N> {
                    self.call_builder(&ownerCall {})
                }
                ///Creates a new call builder for the [`parameters`] function.
                pub fn parameters(
                    &self,
                ) -> alloy_contract::SolCallBuilder<T, &P, parametersCall, N> {
                    self.call_builder(&parametersCall {})
                }
                ///Creates a new call builder for the [`setOwner`] function.
                pub fn setOwner(
                    &self,
                    _owner: ::alloy::sol_types::private::Address,
                ) -> alloy_contract::SolCallBuilder<T, &P, setOwnerCall, N> {
                    self.call_builder(&setOwnerCall { _owner })
                }
            }
            /// Event filters.
            #[automatically_derived]
            impl<
                T: alloy_contract::private::Transport + ::core::clone::Clone,
                P: alloy_contract::private::Provider<T, N>,
                N: alloy_contract::private::Network,
            > SushiSwapV3FactoryInstance<T, P, N> {
                /// Creates a new event filter using this contract instance's provider and address.
                ///
                /// Note that the type can be any event, not just those defined in this contract.
                /// Prefer using the other methods for building type-safe event filters.
                pub fn event_filter<E: alloy_sol_types::SolEvent>(
                    &self,
                ) -> alloy_contract::Event<T, &P, E, N> {
                    alloy_contract::Event::new_sol(&self.provider, &self.address)
                }
                ///Creates a new event filter for the [`FeeAmountEnabled`] event.
                pub fn FeeAmountEnabled_filter(
                    &self,
                ) -> alloy_contract::Event<T, &P, FeeAmountEnabled, N> {
                    self.event_filter::<FeeAmountEnabled>()
                }
                ///Creates a new event filter for the [`OwnerChanged`] event.
                pub fn OwnerChanged_filter(
                    &self,
                ) -> alloy_contract::Event<T, &P, OwnerChanged, N> {
                    self.event_filter::<OwnerChanged>()
                }
                ///Creates a new event filter for the [`PoolCreated`] event.
                pub fn PoolCreated_filter(
                    &self,
                ) -> alloy_contract::Event<T, &P, PoolCreated, N> {
                    self.event_filter::<PoolCreated>()
                }
            }
        }
        const _: &'static [u8] = b"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeToSetter\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"PairCreated\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"INIT_CODE_PAIR_HASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allPairs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allPairsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"createPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeTo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeToSetter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeTo\",\"type\":\"address\"}],\"name\":\"setFeeTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeToSetter\",\"type\":\"address\"}],\"name\":\"setFeeToSetter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]";
        /**

Generated by the following Solidity interface...
```solidity
interface PancakeSwapV2Factory {
    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);

    constructor(address _feeToSetter);

    function INIT_CODE_PAIR_HASH() external view returns (bytes32);
    function allPairs(uint256) external view returns (address);
    function allPairsLength() external view returns (uint256);
    function createPair(address tokenA, address tokenB) external returns (address pair);
    function feeTo() external view returns (address);
    function feeToSetter() external view returns (address);
    function getPair(address, address) external view returns (address);
    function setFeeTo(address _feeTo) external;
    function setFeeToSetter(address _feeToSetter) external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "_feeToSetter",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "INIT_CODE_PAIR_HASH",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "allPairs",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "allPairsLength",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "createPair",
    "inputs": [
      {
        "name": "tokenA",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "tokenB",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "pair",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "feeTo",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "feeToSetter",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getPair",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "setFeeTo",
    "inputs": [
      {
        "name": "_feeTo",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setFeeToSetter",
    "inputs": [
      {
        "name": "_feeToSetter",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "PairCreated",
    "inputs": [
      {
        "name": "token0",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "token1",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "pair",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  }
]
```*/
        #[allow(non_camel_case_types, non_snake_case, clippy::style)]
        pub mod PancakeSwapV2Factory {
            use super::*;
            use ::alloy::sol_types as alloy_sol_types;
            /**Event with signature `PairCreated(address,address,address,uint256)` and selector `0x0d3648bd0f6ba80134a33ba9275ac585d9d315f0ad8355cddefde31afa28d0e9`.
```solidity
event PairCreated(address indexed token0, address indexed token1, address pair, uint256);
```*/
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            pub struct PairCreated {
                #[allow(missing_docs)]
                pub token0: ::alloy::sol_types::private::Address,
                #[allow(missing_docs)]
                pub token1: ::alloy::sol_types::private::Address,
                #[allow(missing_docs)]
                pub pair: ::alloy::sol_types::private::Address,
                #[allow(missing_docs)]
                pub _3: ::alloy::sol_types::private::U256,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            impl ::core::clone::Clone for PairCreated {
                #[inline]
                fn clone(&self) -> PairCreated {
                    PairCreated {
                        token0: ::core::clone::Clone::clone(&self.token0),
                        token1: ::core::clone::Clone::clone(&self.token1),
                        pair: ::core::clone::Clone::clone(&self.pair),
                        _3: ::core::clone::Clone::clone(&self._3),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            impl ::core::fmt::Debug for PairCreated {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "PairCreated",
                        "token0",
                        &self.token0,
                        "token1",
                        &self.token1,
                        "pair",
                        &self.pair,
                        "_3",
                        &&self._3,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                #[automatically_derived]
                impl alloy_sol_types::SolEvent for PairCreated {
                    type DataTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Uint<256>,
                    );
                    type DataToken<'a> = <Self::DataTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type TopicList = (
                        alloy_sol_types::sol_data::FixedBytes<32>,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                    );
                    const SIGNATURE: &'static str = "PairCreated(address,address,address,uint256)";
                    const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                        13u8,
                        54u8,
                        72u8,
                        189u8,
                        15u8,
                        107u8,
                        168u8,
                        1u8,
                        52u8,
                        163u8,
                        59u8,
                        169u8,
                        39u8,
                        90u8,
                        197u8,
                        133u8,
                        217u8,
                        211u8,
                        21u8,
                        240u8,
                        173u8,
                        131u8,
                        85u8,
                        205u8,
                        222u8,
                        253u8,
                        227u8,
                        26u8,
                        250u8,
                        40u8,
                        208u8,
                        233u8,
                    ]);
                    const ANONYMOUS: bool = false;
                    #[allow(unused_variables)]
                    #[inline]
                    fn new(
                        topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                        data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        Self {
                            token0: topics.1,
                            token1: topics.2,
                            pair: data.0,
                            _3: data.1,
                        }
                    }
                    #[inline]
                    fn tokenize_body(&self) -> Self::DataToken<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self.pair,
                            ),
                            <::alloy::sol_types::sol_data::Uint<
                                256,
                            > as alloy_sol_types::SolType>::tokenize(&self._3),
                        )
                    }
                    #[inline]
                    fn topics(
                        &self,
                    ) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                        (
                            Self::SIGNATURE_HASH.into(),
                            self.token0.clone(),
                            self.token1.clone(),
                        )
                    }
                    #[inline]
                    fn encode_topics_raw(
                        &self,
                        out: &mut [alloy_sol_types::abi::token::WordToken],
                    ) -> alloy_sol_types::Result<()> {
                        if out.len()
                            < <Self::TopicList as alloy_sol_types::TopicList>::COUNT
                        {
                            return Err(alloy_sol_types::Error::Overrun);
                        }
                        out[0usize] = alloy_sol_types::abi::token::WordToken(
                            Self::SIGNATURE_HASH,
                        );
                        out[1usize] = <::alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                            &self.token0,
                        );
                        out[2usize] = <::alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                            &self.token1,
                        );
                        Ok(())
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::private::IntoLogData for PairCreated {
                    fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                        From::from(self)
                    }
                    fn into_log_data(self) -> alloy_sol_types::private::LogData {
                        From::from(&self)
                    }
                }
                #[automatically_derived]
                impl From<&PairCreated> for alloy_sol_types::private::LogData {
                    #[inline]
                    fn from(this: &PairCreated) -> alloy_sol_types::private::LogData {
                        alloy_sol_types::SolEvent::encode_log_data(this)
                    }
                }
            };
            /**Constructor`.
```solidity
constructor(address _feeToSetter);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct constructorCall {
                pub _feeToSetter: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for constructorCall {
                #[inline]
                fn clone(&self) -> constructorCall {
                    constructorCall {
                        _feeToSetter: ::core::clone::Clone::clone(&self._feeToSetter),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for constructorCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "constructorCall",
                        "_feeToSetter",
                        &&self._feeToSetter,
                    )
                }
            }
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<constructorCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: constructorCall) -> Self {
                            (value._feeToSetter,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for constructorCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _feeToSetter: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolConstructor for constructorCall {
                    type Parameters<'a> = (::alloy::sol_types::sol_data::Address,);
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self._feeToSetter,
                            ),
                        )
                    }
                }
            };
            /**Function with signature `INIT_CODE_PAIR_HASH()` and selector `0x5855a25a`.
```solidity
function INIT_CODE_PAIR_HASH() external view returns (bytes32);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct INIT_CODE_PAIR_HASHCall {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for INIT_CODE_PAIR_HASHCall {
                #[inline]
                fn clone(&self) -> INIT_CODE_PAIR_HASHCall {
                    INIT_CODE_PAIR_HASHCall {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for INIT_CODE_PAIR_HASHCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "INIT_CODE_PAIR_HASHCall")
                }
            }
            ///Container type for the return parameters of the [`INIT_CODE_PAIR_HASH()`](INIT_CODE_PAIR_HASHCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct INIT_CODE_PAIR_HASHReturn {
                pub _0: ::alloy::sol_types::private::FixedBytes<32>,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for INIT_CODE_PAIR_HASHReturn {
                #[inline]
                fn clone(&self) -> INIT_CODE_PAIR_HASHReturn {
                    INIT_CODE_PAIR_HASHReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for INIT_CODE_PAIR_HASHReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "INIT_CODE_PAIR_HASHReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<INIT_CODE_PAIR_HASHCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: INIT_CODE_PAIR_HASHCall) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for INIT_CODE_PAIR_HASHCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::FixedBytes<32>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::FixedBytes<32>,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<INIT_CODE_PAIR_HASHReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: INIT_CODE_PAIR_HASHReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for INIT_CODE_PAIR_HASHReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for INIT_CODE_PAIR_HASHCall {
                    type Parameters<'a> = ();
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = INIT_CODE_PAIR_HASHReturn;
                    type ReturnTuple<'a> = (
                        ::alloy::sol_types::sol_data::FixedBytes<32>,
                    );
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "INIT_CODE_PAIR_HASH()";
                    const SELECTOR: [u8; 4] = [88u8, 85u8, 162u8, 90u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `allPairs(uint256)` and selector `0x1e3dd18b`.
```solidity
function allPairs(uint256) external view returns (address);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct allPairsCall {
                pub _0: ::alloy::sol_types::private::U256,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for allPairsCall {
                #[inline]
                fn clone(&self) -> allPairsCall {
                    allPairsCall {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for allPairsCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "allPairsCall",
                        "_0",
                        &&self._0,
                    )
                }
            }
            ///Container type for the return parameters of the [`allPairs(uint256)`](allPairsCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct allPairsReturn {
                pub _0: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for allPairsReturn {
                #[inline]
                fn clone(&self) -> allPairsReturn {
                    allPairsReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for allPairsReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "allPairsReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Uint<256>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (::alloy::sol_types::private::U256,);
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<allPairsCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: allPairsCall) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for allPairsCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<allPairsReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: allPairsReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for allPairsReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for allPairsCall {
                    type Parameters<'a> = (::alloy::sol_types::sol_data::Uint<256>,);
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = allPairsReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Address,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "allPairs(uint256)";
                    const SELECTOR: [u8; 4] = [30u8, 61u8, 209u8, 139u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Uint<
                                256,
                            > as alloy_sol_types::SolType>::tokenize(&self._0),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `allPairsLength()` and selector `0x574f2ba3`.
```solidity
function allPairsLength() external view returns (uint256);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct allPairsLengthCall {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for allPairsLengthCall {
                #[inline]
                fn clone(&self) -> allPairsLengthCall {
                    allPairsLengthCall {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for allPairsLengthCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "allPairsLengthCall")
                }
            }
            ///Container type for the return parameters of the [`allPairsLength()`](allPairsLengthCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct allPairsLengthReturn {
                pub _0: ::alloy::sol_types::private::U256,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for allPairsLengthReturn {
                #[inline]
                fn clone(&self) -> allPairsLengthReturn {
                    allPairsLengthReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for allPairsLengthReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "allPairsLengthReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<allPairsLengthCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: allPairsLengthCall) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for allPairsLengthCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Uint<256>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (::alloy::sol_types::private::U256,);
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<allPairsLengthReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: allPairsLengthReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for allPairsLengthReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for allPairsLengthCall {
                    type Parameters<'a> = ();
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = allPairsLengthReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Uint<256>,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "allPairsLength()";
                    const SELECTOR: [u8; 4] = [87u8, 79u8, 43u8, 163u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `createPair(address,address)` and selector `0xc9c65396`.
```solidity
function createPair(address tokenA, address tokenB) external returns (address pair);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct createPairCall {
                pub tokenA: ::alloy::sol_types::private::Address,
                pub tokenB: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for createPairCall {
                #[inline]
                fn clone(&self) -> createPairCall {
                    createPairCall {
                        tokenA: ::core::clone::Clone::clone(&self.tokenA),
                        tokenB: ::core::clone::Clone::clone(&self.tokenB),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for createPairCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "createPairCall",
                        "tokenA",
                        &self.tokenA,
                        "tokenB",
                        &&self.tokenB,
                    )
                }
            }
            ///Container type for the return parameters of the [`createPair(address,address)`](createPairCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct createPairReturn {
                pub pair: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for createPairReturn {
                #[inline]
                fn clone(&self) -> createPairReturn {
                    createPairReturn {
                        pair: ::core::clone::Clone::clone(&self.pair),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for createPairReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "createPairReturn",
                        "pair",
                        &&self.pair,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<createPairCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: createPairCall) -> Self {
                            (value.tokenA, value.tokenB)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for createPairCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {
                                tokenA: tuple.0,
                                tokenB: tuple.1,
                            }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<createPairReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: createPairReturn) -> Self {
                            (value.pair,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for createPairReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { pair: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for createPairCall {
                    type Parameters<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                    );
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = createPairReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Address,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "createPair(address,address)";
                    const SELECTOR: [u8; 4] = [201u8, 198u8, 83u8, 150u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self.tokenA,
                            ),
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self.tokenB,
                            ),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `feeTo()` and selector `0x017e7e58`.
```solidity
function feeTo() external view returns (address);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct feeToCall {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for feeToCall {
                #[inline]
                fn clone(&self) -> feeToCall {
                    feeToCall {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for feeToCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "feeToCall")
                }
            }
            ///Container type for the return parameters of the [`feeTo()`](feeToCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct feeToReturn {
                pub _0: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for feeToReturn {
                #[inline]
                fn clone(&self) -> feeToReturn {
                    feeToReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for feeToReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "feeToReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<feeToCall> for UnderlyingRustTuple<'_> {
                        fn from(value: feeToCall) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>> for feeToCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<feeToReturn> for UnderlyingRustTuple<'_> {
                        fn from(value: feeToReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>> for feeToReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for feeToCall {
                    type Parameters<'a> = ();
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = feeToReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Address,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "feeTo()";
                    const SELECTOR: [u8; 4] = [1u8, 126u8, 126u8, 88u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `feeToSetter()` and selector `0x094b7415`.
```solidity
function feeToSetter() external view returns (address);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct feeToSetterCall {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for feeToSetterCall {
                #[inline]
                fn clone(&self) -> feeToSetterCall {
                    feeToSetterCall {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for feeToSetterCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "feeToSetterCall")
                }
            }
            ///Container type for the return parameters of the [`feeToSetter()`](feeToSetterCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct feeToSetterReturn {
                pub _0: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for feeToSetterReturn {
                #[inline]
                fn clone(&self) -> feeToSetterReturn {
                    feeToSetterReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for feeToSetterReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "feeToSetterReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<feeToSetterCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: feeToSetterCall) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for feeToSetterCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<feeToSetterReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: feeToSetterReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for feeToSetterReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for feeToSetterCall {
                    type Parameters<'a> = ();
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = feeToSetterReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Address,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "feeToSetter()";
                    const SELECTOR: [u8; 4] = [9u8, 75u8, 116u8, 21u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `getPair(address,address)` and selector `0xe6a43905`.
```solidity
function getPair(address, address) external view returns (address);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct getPairCall {
                pub _0: ::alloy::sol_types::private::Address,
                pub _1: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for getPairCall {
                #[inline]
                fn clone(&self) -> getPairCall {
                    getPairCall {
                        _0: ::core::clone::Clone::clone(&self._0),
                        _1: ::core::clone::Clone::clone(&self._1),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for getPairCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "getPairCall",
                        "_0",
                        &self._0,
                        "_1",
                        &&self._1,
                    )
                }
            }
            ///Container type for the return parameters of the [`getPair(address,address)`](getPairCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct getPairReturn {
                pub _0: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for getPairReturn {
                #[inline]
                fn clone(&self) -> getPairReturn {
                    getPairReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for getPairReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "getPairReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<getPairCall> for UnderlyingRustTuple<'_> {
                        fn from(value: getPairCall) -> Self {
                            (value._0, value._1)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>> for getPairCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0, _1: tuple.1 }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<getPairReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: getPairReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for getPairReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for getPairCall {
                    type Parameters<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                    );
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = getPairReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Address,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "getPair(address,address)";
                    const SELECTOR: [u8; 4] = [230u8, 164u8, 57u8, 5u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self._0,
                            ),
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self._1,
                            ),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `setFeeTo(address)` and selector `0xf46901ed`.
```solidity
function setFeeTo(address _feeTo) external;
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct setFeeToCall {
                pub _feeTo: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for setFeeToCall {
                #[inline]
                fn clone(&self) -> setFeeToCall {
                    setFeeToCall {
                        _feeTo: ::core::clone::Clone::clone(&self._feeTo),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for setFeeToCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "setFeeToCall",
                        "_feeTo",
                        &&self._feeTo,
                    )
                }
            }
            ///Container type for the return parameters of the [`setFeeTo(address)`](setFeeToCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct setFeeToReturn {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for setFeeToReturn {
                #[inline]
                fn clone(&self) -> setFeeToReturn {
                    setFeeToReturn {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for setFeeToReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "setFeeToReturn")
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<setFeeToCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: setFeeToCall) -> Self {
                            (value._feeTo,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for setFeeToCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _feeTo: tuple.0 }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<setFeeToReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: setFeeToReturn) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for setFeeToReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for setFeeToCall {
                    type Parameters<'a> = (::alloy::sol_types::sol_data::Address,);
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = setFeeToReturn;
                    type ReturnTuple<'a> = ();
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "setFeeTo(address)";
                    const SELECTOR: [u8; 4] = [244u8, 105u8, 1u8, 237u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self._feeTo,
                            ),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `setFeeToSetter(address)` and selector `0xa2e74af6`.
```solidity
function setFeeToSetter(address _feeToSetter) external;
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct setFeeToSetterCall {
                pub _feeToSetter: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for setFeeToSetterCall {
                #[inline]
                fn clone(&self) -> setFeeToSetterCall {
                    setFeeToSetterCall {
                        _feeToSetter: ::core::clone::Clone::clone(&self._feeToSetter),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for setFeeToSetterCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "setFeeToSetterCall",
                        "_feeToSetter",
                        &&self._feeToSetter,
                    )
                }
            }
            ///Container type for the return parameters of the [`setFeeToSetter(address)`](setFeeToSetterCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct setFeeToSetterReturn {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for setFeeToSetterReturn {
                #[inline]
                fn clone(&self) -> setFeeToSetterReturn {
                    setFeeToSetterReturn {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for setFeeToSetterReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "setFeeToSetterReturn")
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<setFeeToSetterCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: setFeeToSetterCall) -> Self {
                            (value._feeToSetter,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for setFeeToSetterCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _feeToSetter: tuple.0 }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<setFeeToSetterReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: setFeeToSetterReturn) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for setFeeToSetterReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for setFeeToSetterCall {
                    type Parameters<'a> = (::alloy::sol_types::sol_data::Address,);
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = setFeeToSetterReturn;
                    type ReturnTuple<'a> = ();
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "setFeeToSetter(address)";
                    const SELECTOR: [u8; 4] = [162u8, 231u8, 74u8, 246u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self._feeToSetter,
                            ),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            ///Container for all the [`PancakeSwapV2Factory`](self) function calls.
            pub enum PancakeSwapV2FactoryCalls {
                INIT_CODE_PAIR_HASH(INIT_CODE_PAIR_HASHCall),
                allPairs(allPairsCall),
                allPairsLength(allPairsLengthCall),
                createPair(createPairCall),
                feeTo(feeToCall),
                feeToSetter(feeToSetterCall),
                getPair(getPairCall),
                setFeeTo(setFeeToCall),
                setFeeToSetter(setFeeToSetterCall),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for PancakeSwapV2FactoryCalls {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        PancakeSwapV2FactoryCalls::INIT_CODE_PAIR_HASH(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "INIT_CODE_PAIR_HASH",
                                &__self_0,
                            )
                        }
                        PancakeSwapV2FactoryCalls::allPairs(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "allPairs",
                                &__self_0,
                            )
                        }
                        PancakeSwapV2FactoryCalls::allPairsLength(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "allPairsLength",
                                &__self_0,
                            )
                        }
                        PancakeSwapV2FactoryCalls::createPair(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "createPair",
                                &__self_0,
                            )
                        }
                        PancakeSwapV2FactoryCalls::feeTo(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "feeTo",
                                &__self_0,
                            )
                        }
                        PancakeSwapV2FactoryCalls::feeToSetter(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "feeToSetter",
                                &__self_0,
                            )
                        }
                        PancakeSwapV2FactoryCalls::getPair(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "getPair",
                                &__self_0,
                            )
                        }
                        PancakeSwapV2FactoryCalls::setFeeTo(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "setFeeTo",
                                &__self_0,
                            )
                        }
                        PancakeSwapV2FactoryCalls::setFeeToSetter(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "setFeeToSetter",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl PancakeSwapV2FactoryCalls {
                /// All the selectors of this enum.
                ///
                /// Note that the selectors might not be in the same order as the variants.
                /// No guarantees are made about the order of the selectors.
                ///
                /// Prefer using `SolInterface` methods instead.
                pub const SELECTORS: &'static [[u8; 4usize]] = &[
                    [1u8, 126u8, 126u8, 88u8],
                    [9u8, 75u8, 116u8, 21u8],
                    [30u8, 61u8, 209u8, 139u8],
                    [87u8, 79u8, 43u8, 163u8],
                    [88u8, 85u8, 162u8, 90u8],
                    [162u8, 231u8, 74u8, 246u8],
                    [201u8, 198u8, 83u8, 150u8],
                    [230u8, 164u8, 57u8, 5u8],
                    [244u8, 105u8, 1u8, 237u8],
                ];
            }
            #[automatically_derived]
            impl alloy_sol_types::SolInterface for PancakeSwapV2FactoryCalls {
                const NAME: &'static str = "PancakeSwapV2FactoryCalls";
                const MIN_DATA_LENGTH: usize = 0usize;
                const COUNT: usize = 9usize;
                #[inline]
                fn selector(&self) -> [u8; 4] {
                    match self {
                        Self::INIT_CODE_PAIR_HASH(_) => {
                            <INIT_CODE_PAIR_HASHCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::allPairs(_) => {
                            <allPairsCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::allPairsLength(_) => {
                            <allPairsLengthCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::createPair(_) => {
                            <createPairCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::feeTo(_) => {
                            <feeToCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::feeToSetter(_) => {
                            <feeToSetterCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::getPair(_) => {
                            <getPairCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::setFeeTo(_) => {
                            <setFeeToCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::setFeeToSetter(_) => {
                            <setFeeToSetterCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                    }
                }
                #[inline]
                fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
                    Self::SELECTORS.get(i).copied()
                }
                #[inline]
                fn valid_selector(selector: [u8; 4]) -> bool {
                    Self::SELECTORS.binary_search(&selector).is_ok()
                }
                #[inline]
                #[allow(unsafe_code, non_snake_case)]
                fn abi_decode_raw(
                    selector: [u8; 4],
                    data: &[u8],
                    validate: bool,
                ) -> alloy_sol_types::Result<Self> {
                    static DECODE_SHIMS: &[fn(
                        &[u8],
                        bool,
                    ) -> alloy_sol_types::Result<PancakeSwapV2FactoryCalls>] = &[
                        {
                            fn feeTo(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<PancakeSwapV2FactoryCalls> {
                                <feeToCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(PancakeSwapV2FactoryCalls::feeTo)
                            }
                            feeTo
                        },
                        {
                            fn feeToSetter(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<PancakeSwapV2FactoryCalls> {
                                <feeToSetterCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(PancakeSwapV2FactoryCalls::feeToSetter)
                            }
                            feeToSetter
                        },
                        {
                            fn allPairs(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<PancakeSwapV2FactoryCalls> {
                                <allPairsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(PancakeSwapV2FactoryCalls::allPairs)
                            }
                            allPairs
                        },
                        {
                            fn allPairsLength(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<PancakeSwapV2FactoryCalls> {
                                <allPairsLengthCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(PancakeSwapV2FactoryCalls::allPairsLength)
                            }
                            allPairsLength
                        },
                        {
                            fn INIT_CODE_PAIR_HASH(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<PancakeSwapV2FactoryCalls> {
                                <INIT_CODE_PAIR_HASHCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(PancakeSwapV2FactoryCalls::INIT_CODE_PAIR_HASH)
                            }
                            INIT_CODE_PAIR_HASH
                        },
                        {
                            fn setFeeToSetter(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<PancakeSwapV2FactoryCalls> {
                                <setFeeToSetterCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(PancakeSwapV2FactoryCalls::setFeeToSetter)
                            }
                            setFeeToSetter
                        },
                        {
                            fn createPair(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<PancakeSwapV2FactoryCalls> {
                                <createPairCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(PancakeSwapV2FactoryCalls::createPair)
                            }
                            createPair
                        },
                        {
                            fn getPair(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<PancakeSwapV2FactoryCalls> {
                                <getPairCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(PancakeSwapV2FactoryCalls::getPair)
                            }
                            getPair
                        },
                        {
                            fn setFeeTo(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<PancakeSwapV2FactoryCalls> {
                                <setFeeToCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(PancakeSwapV2FactoryCalls::setFeeTo)
                            }
                            setFeeTo
                        },
                    ];
                    let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                        return Err(
                            alloy_sol_types::Error::unknown_selector(
                                <Self as alloy_sol_types::SolInterface>::NAME,
                                selector,
                            ),
                        );
                    };
                    (unsafe { DECODE_SHIMS.get_unchecked(idx) })(data, validate)
                }
                #[inline]
                fn abi_encoded_size(&self) -> usize {
                    match self {
                        Self::INIT_CODE_PAIR_HASH(inner) => {
                            <INIT_CODE_PAIR_HASHCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::allPairs(inner) => {
                            <allPairsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::allPairsLength(inner) => {
                            <allPairsLengthCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::createPair(inner) => {
                            <createPairCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::feeTo(inner) => {
                            <feeToCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::feeToSetter(inner) => {
                            <feeToSetterCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::getPair(inner) => {
                            <getPairCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::setFeeTo(inner) => {
                            <setFeeToCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::setFeeToSetter(inner) => {
                            <setFeeToSetterCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                    }
                }
                #[inline]
                fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                    match self {
                        Self::INIT_CODE_PAIR_HASH(inner) => {
                            <INIT_CODE_PAIR_HASHCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::allPairs(inner) => {
                            <allPairsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::allPairsLength(inner) => {
                            <allPairsLengthCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::createPair(inner) => {
                            <createPairCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::feeTo(inner) => {
                            <feeToCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::feeToSetter(inner) => {
                            <feeToSetterCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::getPair(inner) => {
                            <getPairCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::setFeeTo(inner) => {
                            <setFeeToCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::setFeeToSetter(inner) => {
                            <setFeeToSetterCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                    }
                }
            }
            ///Container for all the [`PancakeSwapV2Factory`](self) events.
            pub enum PancakeSwapV2FactoryEvents {
                PairCreated(PairCreated),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for PancakeSwapV2FactoryEvents {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        PancakeSwapV2FactoryEvents::PairCreated(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "PairCreated",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl PancakeSwapV2FactoryEvents {
                /// All the selectors of this enum.
                ///
                /// Note that the selectors might not be in the same order as the variants.
                /// No guarantees are made about the order of the selectors.
                ///
                /// Prefer using `SolInterface` methods instead.
                pub const SELECTORS: &'static [[u8; 32usize]] = &[
                    [
                        13u8,
                        54u8,
                        72u8,
                        189u8,
                        15u8,
                        107u8,
                        168u8,
                        1u8,
                        52u8,
                        163u8,
                        59u8,
                        169u8,
                        39u8,
                        90u8,
                        197u8,
                        133u8,
                        217u8,
                        211u8,
                        21u8,
                        240u8,
                        173u8,
                        131u8,
                        85u8,
                        205u8,
                        222u8,
                        253u8,
                        227u8,
                        26u8,
                        250u8,
                        40u8,
                        208u8,
                        233u8,
                    ],
                ];
            }
            #[automatically_derived]
            impl alloy_sol_types::SolEventInterface for PancakeSwapV2FactoryEvents {
                const NAME: &'static str = "PancakeSwapV2FactoryEvents";
                const COUNT: usize = 1usize;
                fn decode_raw_log(
                    topics: &[alloy_sol_types::Word],
                    data: &[u8],
                    validate: bool,
                ) -> alloy_sol_types::Result<Self> {
                    match topics.first().copied() {
                        Some(
                            <PairCreated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                        ) => {
                            <PairCreated as alloy_sol_types::SolEvent>::decode_raw_log(
                                    topics,
                                    data,
                                    validate,
                                )
                                .map(Self::PairCreated)
                        }
                        _ => {
                            alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                                name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                                log: alloy_sol_types::private::Box::new(
                                    alloy_sol_types::private::LogData::new_unchecked(
                                        topics.to_vec(),
                                        data.to_vec().into(),
                                    ),
                                ),
                            })
                        }
                    }
                }
            }
            #[automatically_derived]
            impl alloy_sol_types::private::IntoLogData for PancakeSwapV2FactoryEvents {
                fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                    match self {
                        Self::PairCreated(inner) => {
                            alloy_sol_types::private::IntoLogData::to_log_data(inner)
                        }
                    }
                }
                fn into_log_data(self) -> alloy_sol_types::private::LogData {
                    match self {
                        Self::PairCreated(inner) => {
                            alloy_sol_types::private::IntoLogData::into_log_data(inner)
                        }
                    }
                }
            }
            use ::alloy::contract as alloy_contract;
            /**Creates a new wrapper around an on-chain [`PancakeSwapV2Factory`](self) contract instance.

See the [wrapper's documentation](`PancakeSwapV2FactoryInstance`) for more details.*/
            #[inline]
            pub const fn new<
                T: alloy_contract::private::Transport + ::core::clone::Clone,
                P: alloy_contract::private::Provider<T, N>,
                N: alloy_contract::private::Network,
            >(
                address: alloy_sol_types::private::Address,
                provider: P,
            ) -> PancakeSwapV2FactoryInstance<T, P, N> {
                PancakeSwapV2FactoryInstance::<T, P, N>::new(address, provider)
            }
            /**A [`PancakeSwapV2Factory`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`PancakeSwapV2Factory`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
            pub struct PancakeSwapV2FactoryInstance<
                T,
                P,
                N = alloy_contract::private::Ethereum,
            > {
                address: alloy_sol_types::private::Address,
                provider: P,
                _network_transport: ::core::marker::PhantomData<(N, T)>,
            }
            #[automatically_derived]
            impl<
                T: ::core::clone::Clone,
                P: ::core::clone::Clone,
                N: ::core::clone::Clone,
            > ::core::clone::Clone for PancakeSwapV2FactoryInstance<T, P, N> {
                #[inline]
                fn clone(&self) -> PancakeSwapV2FactoryInstance<T, P, N> {
                    PancakeSwapV2FactoryInstance {
                        address: ::core::clone::Clone::clone(&self.address),
                        provider: ::core::clone::Clone::clone(&self.provider),
                        _network_transport: ::core::clone::Clone::clone(
                            &self._network_transport,
                        ),
                    }
                }
            }
            #[automatically_derived]
            impl<T, P, N> ::core::fmt::Debug for PancakeSwapV2FactoryInstance<T, P, N> {
                #[inline]
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_tuple("PancakeSwapV2FactoryInstance")
                        .field(&self.address)
                        .finish()
                }
            }
            /// Instantiation and getters/setters.
            #[automatically_derived]
            impl<
                T: alloy_contract::private::Transport + ::core::clone::Clone,
                P: alloy_contract::private::Provider<T, N>,
                N: alloy_contract::private::Network,
            > PancakeSwapV2FactoryInstance<T, P, N> {
                /**Creates a new wrapper around an on-chain [`PancakeSwapV2Factory`](self) contract instance.

See the [wrapper's documentation](`PancakeSwapV2FactoryInstance`) for more details.*/
                #[inline]
                pub const fn new(
                    address: alloy_sol_types::private::Address,
                    provider: P,
                ) -> Self {
                    Self {
                        address,
                        provider,
                        _network_transport: ::core::marker::PhantomData,
                    }
                }
                /// Returns a reference to the address.
                #[inline]
                pub const fn address(&self) -> &alloy_sol_types::private::Address {
                    &self.address
                }
                /// Sets the address.
                #[inline]
                pub fn set_address(
                    &mut self,
                    address: alloy_sol_types::private::Address,
                ) {
                    self.address = address;
                }
                /// Sets the address and returns `self`.
                pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
                    self.set_address(address);
                    self
                }
                /// Returns a reference to the provider.
                #[inline]
                pub const fn provider(&self) -> &P {
                    &self.provider
                }
            }
            impl<T, P: ::core::clone::Clone, N> PancakeSwapV2FactoryInstance<T, &P, N> {
                /// Clones the provider and returns a new instance with the cloned provider.
                #[inline]
                pub fn with_cloned_provider(
                    self,
                ) -> PancakeSwapV2FactoryInstance<T, P, N> {
                    PancakeSwapV2FactoryInstance {
                        address: self.address,
                        provider: ::core::clone::Clone::clone(&self.provider),
                        _network_transport: ::core::marker::PhantomData,
                    }
                }
            }
            /// Function calls.
            #[automatically_derived]
            impl<
                T: alloy_contract::private::Transport + ::core::clone::Clone,
                P: alloy_contract::private::Provider<T, N>,
                N: alloy_contract::private::Network,
            > PancakeSwapV2FactoryInstance<T, P, N> {
                /// Creates a new call builder using this contract instance's provider and address.
                ///
                /// Note that the call can be any function call, not just those defined in this
                /// contract. Prefer using the other methods for building type-safe contract calls.
                pub fn call_builder<C: alloy_sol_types::SolCall>(
                    &self,
                    call: &C,
                ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
                    alloy_contract::SolCallBuilder::new_sol(
                        &self.provider,
                        &self.address,
                        call,
                    )
                }
                ///Creates a new call builder for the [`INIT_CODE_PAIR_HASH`] function.
                pub fn INIT_CODE_PAIR_HASH(
                    &self,
                ) -> alloy_contract::SolCallBuilder<T, &P, INIT_CODE_PAIR_HASHCall, N> {
                    self.call_builder(&INIT_CODE_PAIR_HASHCall {})
                }
                ///Creates a new call builder for the [`allPairs`] function.
                pub fn allPairs(
                    &self,
                    _0: ::alloy::sol_types::private::U256,
                ) -> alloy_contract::SolCallBuilder<T, &P, allPairsCall, N> {
                    self.call_builder(&allPairsCall { _0 })
                }
                ///Creates a new call builder for the [`allPairsLength`] function.
                pub fn allPairsLength(
                    &self,
                ) -> alloy_contract::SolCallBuilder<T, &P, allPairsLengthCall, N> {
                    self.call_builder(&allPairsLengthCall {})
                }
                ///Creates a new call builder for the [`createPair`] function.
                pub fn createPair(
                    &self,
                    tokenA: ::alloy::sol_types::private::Address,
                    tokenB: ::alloy::sol_types::private::Address,
                ) -> alloy_contract::SolCallBuilder<T, &P, createPairCall, N> {
                    self.call_builder(&createPairCall { tokenA, tokenB })
                }
                ///Creates a new call builder for the [`feeTo`] function.
                pub fn feeTo(
                    &self,
                ) -> alloy_contract::SolCallBuilder<T, &P, feeToCall, N> {
                    self.call_builder(&feeToCall {})
                }
                ///Creates a new call builder for the [`feeToSetter`] function.
                pub fn feeToSetter(
                    &self,
                ) -> alloy_contract::SolCallBuilder<T, &P, feeToSetterCall, N> {
                    self.call_builder(&feeToSetterCall {})
                }
                ///Creates a new call builder for the [`getPair`] function.
                pub fn getPair(
                    &self,
                    _0: ::alloy::sol_types::private::Address,
                    _1: ::alloy::sol_types::private::Address,
                ) -> alloy_contract::SolCallBuilder<T, &P, getPairCall, N> {
                    self.call_builder(&getPairCall { _0, _1 })
                }
                ///Creates a new call builder for the [`setFeeTo`] function.
                pub fn setFeeTo(
                    &self,
                    _feeTo: ::alloy::sol_types::private::Address,
                ) -> alloy_contract::SolCallBuilder<T, &P, setFeeToCall, N> {
                    self.call_builder(&setFeeToCall { _feeTo })
                }
                ///Creates a new call builder for the [`setFeeToSetter`] function.
                pub fn setFeeToSetter(
                    &self,
                    _feeToSetter: ::alloy::sol_types::private::Address,
                ) -> alloy_contract::SolCallBuilder<T, &P, setFeeToSetterCall, N> {
                    self.call_builder(&setFeeToSetterCall { _feeToSetter })
                }
            }
            /// Event filters.
            #[automatically_derived]
            impl<
                T: alloy_contract::private::Transport + ::core::clone::Clone,
                P: alloy_contract::private::Provider<T, N>,
                N: alloy_contract::private::Network,
            > PancakeSwapV2FactoryInstance<T, P, N> {
                /// Creates a new event filter using this contract instance's provider and address.
                ///
                /// Note that the type can be any event, not just those defined in this contract.
                /// Prefer using the other methods for building type-safe event filters.
                pub fn event_filter<E: alloy_sol_types::SolEvent>(
                    &self,
                ) -> alloy_contract::Event<T, &P, E, N> {
                    alloy_contract::Event::new_sol(&self.provider, &self.address)
                }
                ///Creates a new event filter for the [`PairCreated`] event.
                pub fn PairCreated_filter(
                    &self,
                ) -> alloy_contract::Event<T, &P, PairCreated, N> {
                    self.event_filter::<PairCreated>()
                }
            }
        }
        const _: &'static [u8] = b"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolDeployer\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"indexed\":true,\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"}],\"name\":\"FeeAmountEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"whitelistRequested\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"FeeAmountExtraInfoUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"PoolCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lmPoolDeployer\",\"type\":\"address\"}],\"name\":\"SetLmPoolDeployer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"verified\",\"type\":\"bool\"}],\"name\":\"WhiteListAdded\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"amount0Requested\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"amount1Requested\",\"type\":\"uint128\"}],\"name\":\"collectProtocol\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"amount0\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"amount1\",\"type\":\"uint128\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"}],\"name\":\"createPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"}],\"name\":\"enableFeeAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"name\":\"feeAmountTickSpacing\",\"outputs\":[{\"internalType\":\"int24\",\"name\":\"\",\"type\":\"int24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"name\":\"feeAmountTickSpacingExtraInfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"whitelistRequested\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"name\":\"getPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lmPoolDeployer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolDeployer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"bool\",\"name\":\"whitelistRequested\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setFeeAmountExtraInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"feeProtocol0\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"feeProtocol1\",\"type\":\"uint32\"}],\"name\":\"setFeeProtocol\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lmPool\",\"type\":\"address\"}],\"name\":\"setLmPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lmPoolDeployer\",\"type\":\"address\"}],\"name\":\"setLmPoolDeployer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"verified\",\"type\":\"bool\"}],\"name\":\"setWhiteListAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]";
        /**

Generated by the following Solidity interface...
```solidity
interface PancakeSwapV3Factory {
    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);
    event FeeAmountExtraInfoUpdated(uint24 indexed fee, bool whitelistRequested, bool enabled);
    event OwnerChanged(address indexed oldOwner, address indexed newOwner);
    event PoolCreated(address indexed token0, address indexed token1, uint24 indexed fee, int24 tickSpacing, address pool);
    event SetLmPoolDeployer(address indexed lmPoolDeployer);
    event WhiteListAdded(address indexed user, bool verified);

    constructor(address _poolDeployer);

    function collectProtocol(address pool, address recipient, uint128 amount0Requested, uint128 amount1Requested) external returns (uint128 amount0, uint128 amount1);
    function createPool(address tokenA, address tokenB, uint24 fee) external returns (address pool);
    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;
    function feeAmountTickSpacing(uint24) external view returns (int24);
    function feeAmountTickSpacingExtraInfo(uint24) external view returns (bool whitelistRequested, bool enabled);
    function getPool(address, address, uint24) external view returns (address);
    function lmPoolDeployer() external view returns (address);
    function owner() external view returns (address);
    function poolDeployer() external view returns (address);
    function setFeeAmountExtraInfo(uint24 fee, bool whitelistRequested, bool enabled) external;
    function setFeeProtocol(address pool, uint32 feeProtocol0, uint32 feeProtocol1) external;
    function setLmPool(address pool, address lmPool) external;
    function setLmPoolDeployer(address _lmPoolDeployer) external;
    function setOwner(address _owner) external;
    function setWhiteListAddress(address user, bool verified) external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "_poolDeployer",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "collectProtocol",
    "inputs": [
      {
        "name": "pool",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "recipient",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount0Requested",
        "type": "uint128",
        "internalType": "uint128"
      },
      {
        "name": "amount1Requested",
        "type": "uint128",
        "internalType": "uint128"
      }
    ],
    "outputs": [
      {
        "name": "amount0",
        "type": "uint128",
        "internalType": "uint128"
      },
      {
        "name": "amount1",
        "type": "uint128",
        "internalType": "uint128"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "createPool",
    "inputs": [
      {
        "name": "tokenA",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "tokenB",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "fee",
        "type": "uint24",
        "internalType": "uint24"
      }
    ],
    "outputs": [
      {
        "name": "pool",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "enableFeeAmount",
    "inputs": [
      {
        "name": "fee",
        "type": "uint24",
        "internalType": "uint24"
      },
      {
        "name": "tickSpacing",
        "type": "int24",
        "internalType": "int24"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "feeAmountTickSpacing",
    "inputs": [
      {
        "name": "",
        "type": "uint24",
        "internalType": "uint24"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "int24",
        "internalType": "int24"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "feeAmountTickSpacingExtraInfo",
    "inputs": [
      {
        "name": "",
        "type": "uint24",
        "internalType": "uint24"
      }
    ],
    "outputs": [
      {
        "name": "whitelistRequested",
        "type": "bool",
        "internalType": "bool"
      },
      {
        "name": "enabled",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getPool",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "",
        "type": "uint24",
        "internalType": "uint24"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "lmPoolDeployer",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "owner",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "poolDeployer",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "setFeeAmountExtraInfo",
    "inputs": [
      {
        "name": "fee",
        "type": "uint24",
        "internalType": "uint24"
      },
      {
        "name": "whitelistRequested",
        "type": "bool",
        "internalType": "bool"
      },
      {
        "name": "enabled",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setFeeProtocol",
    "inputs": [
      {
        "name": "pool",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "feeProtocol0",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "feeProtocol1",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setLmPool",
    "inputs": [
      {
        "name": "pool",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "lmPool",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setLmPoolDeployer",
    "inputs": [
      {
        "name": "_lmPoolDeployer",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setOwner",
    "inputs": [
      {
        "name": "_owner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setWhiteListAddress",
    "inputs": [
      {
        "name": "user",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "verified",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "FeeAmountEnabled",
    "inputs": [
      {
        "name": "fee",
        "type": "uint24",
        "indexed": true,
        "internalType": "uint24"
      },
      {
        "name": "tickSpacing",
        "type": "int24",
        "indexed": true,
        "internalType": "int24"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "FeeAmountExtraInfoUpdated",
    "inputs": [
      {
        "name": "fee",
        "type": "uint24",
        "indexed": true,
        "internalType": "uint24"
      },
      {
        "name": "whitelistRequested",
        "type": "bool",
        "indexed": false,
        "internalType": "bool"
      },
      {
        "name": "enabled",
        "type": "bool",
        "indexed": false,
        "internalType": "bool"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OwnerChanged",
    "inputs": [
      {
        "name": "oldOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "PoolCreated",
    "inputs": [
      {
        "name": "token0",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "token1",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "fee",
        "type": "uint24",
        "indexed": true,
        "internalType": "uint24"
      },
      {
        "name": "tickSpacing",
        "type": "int24",
        "indexed": false,
        "internalType": "int24"
      },
      {
        "name": "pool",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "SetLmPoolDeployer",
    "inputs": [
      {
        "name": "lmPoolDeployer",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "WhiteListAdded",
    "inputs": [
      {
        "name": "user",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "verified",
        "type": "bool",
        "indexed": false,
        "internalType": "bool"
      }
    ],
    "anonymous": false
  }
]
```*/
        #[allow(non_camel_case_types, non_snake_case, clippy::style)]
        pub mod PancakeSwapV3Factory {
            use super::*;
            use ::alloy::sol_types as alloy_sol_types;
            /**Event with signature `FeeAmountEnabled(uint24,int24)` and selector `0xc66a3fdf07232cdd185febcc6579d408c241b47ae2f9907d84be655141eeaecc`.
```solidity
event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);
```*/
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            pub struct FeeAmountEnabled {
                #[allow(missing_docs)]
                pub fee: <::alloy::sol_types::sol_data::Uint<
                    24,
                > as ::alloy::sol_types::SolType>::RustType,
                #[allow(missing_docs)]
                pub tickSpacing: <::alloy::sol_types::sol_data::Int<
                    24,
                > as ::alloy::sol_types::SolType>::RustType,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            impl ::core::clone::Clone for FeeAmountEnabled {
                #[inline]
                fn clone(&self) -> FeeAmountEnabled {
                    FeeAmountEnabled {
                        fee: ::core::clone::Clone::clone(&self.fee),
                        tickSpacing: ::core::clone::Clone::clone(&self.tickSpacing),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            impl ::core::fmt::Debug for FeeAmountEnabled {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "FeeAmountEnabled",
                        "fee",
                        &self.fee,
                        "tickSpacing",
                        &&self.tickSpacing,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                #[automatically_derived]
                impl alloy_sol_types::SolEvent for FeeAmountEnabled {
                    type DataTuple<'a> = ();
                    type DataToken<'a> = <Self::DataTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type TopicList = (
                        alloy_sol_types::sol_data::FixedBytes<32>,
                        ::alloy::sol_types::sol_data::Uint<24>,
                        ::alloy::sol_types::sol_data::Int<24>,
                    );
                    const SIGNATURE: &'static str = "FeeAmountEnabled(uint24,int24)";
                    const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                        198u8,
                        106u8,
                        63u8,
                        223u8,
                        7u8,
                        35u8,
                        44u8,
                        221u8,
                        24u8,
                        95u8,
                        235u8,
                        204u8,
                        101u8,
                        121u8,
                        212u8,
                        8u8,
                        194u8,
                        65u8,
                        180u8,
                        122u8,
                        226u8,
                        249u8,
                        144u8,
                        125u8,
                        132u8,
                        190u8,
                        101u8,
                        81u8,
                        65u8,
                        238u8,
                        174u8,
                        204u8,
                    ]);
                    const ANONYMOUS: bool = false;
                    #[allow(unused_variables)]
                    #[inline]
                    fn new(
                        topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                        data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        Self {
                            fee: topics.1,
                            tickSpacing: topics.2,
                        }
                    }
                    #[inline]
                    fn tokenize_body(&self) -> Self::DataToken<'_> {
                        ()
                    }
                    #[inline]
                    fn topics(
                        &self,
                    ) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                        (
                            Self::SIGNATURE_HASH.into(),
                            self.fee.clone(),
                            self.tickSpacing.clone(),
                        )
                    }
                    #[inline]
                    fn encode_topics_raw(
                        &self,
                        out: &mut [alloy_sol_types::abi::token::WordToken],
                    ) -> alloy_sol_types::Result<()> {
                        if out.len()
                            < <Self::TopicList as alloy_sol_types::TopicList>::COUNT
                        {
                            return Err(alloy_sol_types::Error::Overrun);
                        }
                        out[0usize] = alloy_sol_types::abi::token::WordToken(
                            Self::SIGNATURE_HASH,
                        );
                        out[1usize] = <::alloy::sol_types::sol_data::Uint<
                            24,
                        > as alloy_sol_types::EventTopic>::encode_topic(&self.fee);
                        out[2usize] = <::alloy::sol_types::sol_data::Int<
                            24,
                        > as alloy_sol_types::EventTopic>::encode_topic(
                            &self.tickSpacing,
                        );
                        Ok(())
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::private::IntoLogData for FeeAmountEnabled {
                    fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                        From::from(self)
                    }
                    fn into_log_data(self) -> alloy_sol_types::private::LogData {
                        From::from(&self)
                    }
                }
                #[automatically_derived]
                impl From<&FeeAmountEnabled> for alloy_sol_types::private::LogData {
                    #[inline]
                    fn from(
                        this: &FeeAmountEnabled,
                    ) -> alloy_sol_types::private::LogData {
                        alloy_sol_types::SolEvent::encode_log_data(this)
                    }
                }
            };
            /**Event with signature `FeeAmountExtraInfoUpdated(uint24,bool,bool)` and selector `0xed85b616dbfbc54d0f1180a7bd0f6e3bb645b269b234e7a9edcc269ef1443d88`.
```solidity
event FeeAmountExtraInfoUpdated(uint24 indexed fee, bool whitelistRequested, bool enabled);
```*/
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            pub struct FeeAmountExtraInfoUpdated {
                #[allow(missing_docs)]
                pub fee: <::alloy::sol_types::sol_data::Uint<
                    24,
                > as ::alloy::sol_types::SolType>::RustType,
                #[allow(missing_docs)]
                pub whitelistRequested: bool,
                #[allow(missing_docs)]
                pub enabled: bool,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            impl ::core::clone::Clone for FeeAmountExtraInfoUpdated {
                #[inline]
                fn clone(&self) -> FeeAmountExtraInfoUpdated {
                    FeeAmountExtraInfoUpdated {
                        fee: ::core::clone::Clone::clone(&self.fee),
                        whitelistRequested: ::core::clone::Clone::clone(
                            &self.whitelistRequested,
                        ),
                        enabled: ::core::clone::Clone::clone(&self.enabled),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            impl ::core::fmt::Debug for FeeAmountExtraInfoUpdated {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "FeeAmountExtraInfoUpdated",
                        "fee",
                        &self.fee,
                        "whitelistRequested",
                        &self.whitelistRequested,
                        "enabled",
                        &&self.enabled,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                #[automatically_derived]
                impl alloy_sol_types::SolEvent for FeeAmountExtraInfoUpdated {
                    type DataTuple<'a> = (
                        ::alloy::sol_types::sol_data::Bool,
                        ::alloy::sol_types::sol_data::Bool,
                    );
                    type DataToken<'a> = <Self::DataTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type TopicList = (
                        alloy_sol_types::sol_data::FixedBytes<32>,
                        ::alloy::sol_types::sol_data::Uint<24>,
                    );
                    const SIGNATURE: &'static str = "FeeAmountExtraInfoUpdated(uint24,bool,bool)";
                    const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                        237u8,
                        133u8,
                        182u8,
                        22u8,
                        219u8,
                        251u8,
                        197u8,
                        77u8,
                        15u8,
                        17u8,
                        128u8,
                        167u8,
                        189u8,
                        15u8,
                        110u8,
                        59u8,
                        182u8,
                        69u8,
                        178u8,
                        105u8,
                        178u8,
                        52u8,
                        231u8,
                        169u8,
                        237u8,
                        204u8,
                        38u8,
                        158u8,
                        241u8,
                        68u8,
                        61u8,
                        136u8,
                    ]);
                    const ANONYMOUS: bool = false;
                    #[allow(unused_variables)]
                    #[inline]
                    fn new(
                        topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                        data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        Self {
                            fee: topics.1,
                            whitelistRequested: data.0,
                            enabled: data.1,
                        }
                    }
                    #[inline]
                    fn tokenize_body(&self) -> Self::DataToken<'_> {
                        (
                            <::alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                                &self.whitelistRequested,
                            ),
                            <::alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                                &self.enabled,
                            ),
                        )
                    }
                    #[inline]
                    fn topics(
                        &self,
                    ) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                        (Self::SIGNATURE_HASH.into(), self.fee.clone())
                    }
                    #[inline]
                    fn encode_topics_raw(
                        &self,
                        out: &mut [alloy_sol_types::abi::token::WordToken],
                    ) -> alloy_sol_types::Result<()> {
                        if out.len()
                            < <Self::TopicList as alloy_sol_types::TopicList>::COUNT
                        {
                            return Err(alloy_sol_types::Error::Overrun);
                        }
                        out[0usize] = alloy_sol_types::abi::token::WordToken(
                            Self::SIGNATURE_HASH,
                        );
                        out[1usize] = <::alloy::sol_types::sol_data::Uint<
                            24,
                        > as alloy_sol_types::EventTopic>::encode_topic(&self.fee);
                        Ok(())
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::private::IntoLogData
                for FeeAmountExtraInfoUpdated {
                    fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                        From::from(self)
                    }
                    fn into_log_data(self) -> alloy_sol_types::private::LogData {
                        From::from(&self)
                    }
                }
                #[automatically_derived]
                impl From<&FeeAmountExtraInfoUpdated>
                for alloy_sol_types::private::LogData {
                    #[inline]
                    fn from(
                        this: &FeeAmountExtraInfoUpdated,
                    ) -> alloy_sol_types::private::LogData {
                        alloy_sol_types::SolEvent::encode_log_data(this)
                    }
                }
            };
            /**Event with signature `OwnerChanged(address,address)` and selector `0xb532073b38c83145e3e5135377a08bf9aab55bc0fd7c1179cd4fb995d2a5159c`.
```solidity
event OwnerChanged(address indexed oldOwner, address indexed newOwner);
```*/
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            pub struct OwnerChanged {
                #[allow(missing_docs)]
                pub oldOwner: ::alloy::sol_types::private::Address,
                #[allow(missing_docs)]
                pub newOwner: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            impl ::core::clone::Clone for OwnerChanged {
                #[inline]
                fn clone(&self) -> OwnerChanged {
                    OwnerChanged {
                        oldOwner: ::core::clone::Clone::clone(&self.oldOwner),
                        newOwner: ::core::clone::Clone::clone(&self.newOwner),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            impl ::core::fmt::Debug for OwnerChanged {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "OwnerChanged",
                        "oldOwner",
                        &self.oldOwner,
                        "newOwner",
                        &&self.newOwner,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                #[automatically_derived]
                impl alloy_sol_types::SolEvent for OwnerChanged {
                    type DataTuple<'a> = ();
                    type DataToken<'a> = <Self::DataTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type TopicList = (
                        alloy_sol_types::sol_data::FixedBytes<32>,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                    );
                    const SIGNATURE: &'static str = "OwnerChanged(address,address)";
                    const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                        181u8,
                        50u8,
                        7u8,
                        59u8,
                        56u8,
                        200u8,
                        49u8,
                        69u8,
                        227u8,
                        229u8,
                        19u8,
                        83u8,
                        119u8,
                        160u8,
                        139u8,
                        249u8,
                        170u8,
                        181u8,
                        91u8,
                        192u8,
                        253u8,
                        124u8,
                        17u8,
                        121u8,
                        205u8,
                        79u8,
                        185u8,
                        149u8,
                        210u8,
                        165u8,
                        21u8,
                        156u8,
                    ]);
                    const ANONYMOUS: bool = false;
                    #[allow(unused_variables)]
                    #[inline]
                    fn new(
                        topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                        data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        Self {
                            oldOwner: topics.1,
                            newOwner: topics.2,
                        }
                    }
                    #[inline]
                    fn tokenize_body(&self) -> Self::DataToken<'_> {
                        ()
                    }
                    #[inline]
                    fn topics(
                        &self,
                    ) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                        (
                            Self::SIGNATURE_HASH.into(),
                            self.oldOwner.clone(),
                            self.newOwner.clone(),
                        )
                    }
                    #[inline]
                    fn encode_topics_raw(
                        &self,
                        out: &mut [alloy_sol_types::abi::token::WordToken],
                    ) -> alloy_sol_types::Result<()> {
                        if out.len()
                            < <Self::TopicList as alloy_sol_types::TopicList>::COUNT
                        {
                            return Err(alloy_sol_types::Error::Overrun);
                        }
                        out[0usize] = alloy_sol_types::abi::token::WordToken(
                            Self::SIGNATURE_HASH,
                        );
                        out[1usize] = <::alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                            &self.oldOwner,
                        );
                        out[2usize] = <::alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                            &self.newOwner,
                        );
                        Ok(())
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::private::IntoLogData for OwnerChanged {
                    fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                        From::from(self)
                    }
                    fn into_log_data(self) -> alloy_sol_types::private::LogData {
                        From::from(&self)
                    }
                }
                #[automatically_derived]
                impl From<&OwnerChanged> for alloy_sol_types::private::LogData {
                    #[inline]
                    fn from(this: &OwnerChanged) -> alloy_sol_types::private::LogData {
                        alloy_sol_types::SolEvent::encode_log_data(this)
                    }
                }
            };
            /**Event with signature `PoolCreated(address,address,uint24,int24,address)` and selector `0x783cca1c0412dd0d695e784568c96da2e9c22ff989357a2e8b1d9b2b4e6b7118`.
```solidity
event PoolCreated(address indexed token0, address indexed token1, uint24 indexed fee, int24 tickSpacing, address pool);
```*/
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            pub struct PoolCreated {
                #[allow(missing_docs)]
                pub token0: ::alloy::sol_types::private::Address,
                #[allow(missing_docs)]
                pub token1: ::alloy::sol_types::private::Address,
                #[allow(missing_docs)]
                pub fee: <::alloy::sol_types::sol_data::Uint<
                    24,
                > as ::alloy::sol_types::SolType>::RustType,
                #[allow(missing_docs)]
                pub tickSpacing: <::alloy::sol_types::sol_data::Int<
                    24,
                > as ::alloy::sol_types::SolType>::RustType,
                #[allow(missing_docs)]
                pub pool: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            impl ::core::clone::Clone for PoolCreated {
                #[inline]
                fn clone(&self) -> PoolCreated {
                    PoolCreated {
                        token0: ::core::clone::Clone::clone(&self.token0),
                        token1: ::core::clone::Clone::clone(&self.token1),
                        fee: ::core::clone::Clone::clone(&self.fee),
                        tickSpacing: ::core::clone::Clone::clone(&self.tickSpacing),
                        pool: ::core::clone::Clone::clone(&self.pool),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            impl ::core::fmt::Debug for PoolCreated {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "PoolCreated",
                        "token0",
                        &self.token0,
                        "token1",
                        &self.token1,
                        "fee",
                        &self.fee,
                        "tickSpacing",
                        &self.tickSpacing,
                        "pool",
                        &&self.pool,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                #[automatically_derived]
                impl alloy_sol_types::SolEvent for PoolCreated {
                    type DataTuple<'a> = (
                        ::alloy::sol_types::sol_data::Int<24>,
                        ::alloy::sol_types::sol_data::Address,
                    );
                    type DataToken<'a> = <Self::DataTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type TopicList = (
                        alloy_sol_types::sol_data::FixedBytes<32>,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Uint<24>,
                    );
                    const SIGNATURE: &'static str = "PoolCreated(address,address,uint24,int24,address)";
                    const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                        120u8,
                        60u8,
                        202u8,
                        28u8,
                        4u8,
                        18u8,
                        221u8,
                        13u8,
                        105u8,
                        94u8,
                        120u8,
                        69u8,
                        104u8,
                        201u8,
                        109u8,
                        162u8,
                        233u8,
                        194u8,
                        47u8,
                        249u8,
                        137u8,
                        53u8,
                        122u8,
                        46u8,
                        139u8,
                        29u8,
                        155u8,
                        43u8,
                        78u8,
                        107u8,
                        113u8,
                        24u8,
                    ]);
                    const ANONYMOUS: bool = false;
                    #[allow(unused_variables)]
                    #[inline]
                    fn new(
                        topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                        data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        Self {
                            token0: topics.1,
                            token1: topics.2,
                            fee: topics.3,
                            tickSpacing: data.0,
                            pool: data.1,
                        }
                    }
                    #[inline]
                    fn tokenize_body(&self) -> Self::DataToken<'_> {
                        (
                            <::alloy::sol_types::sol_data::Int<
                                24,
                            > as alloy_sol_types::SolType>::tokenize(&self.tickSpacing),
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self.pool,
                            ),
                        )
                    }
                    #[inline]
                    fn topics(
                        &self,
                    ) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                        (
                            Self::SIGNATURE_HASH.into(),
                            self.token0.clone(),
                            self.token1.clone(),
                            self.fee.clone(),
                        )
                    }
                    #[inline]
                    fn encode_topics_raw(
                        &self,
                        out: &mut [alloy_sol_types::abi::token::WordToken],
                    ) -> alloy_sol_types::Result<()> {
                        if out.len()
                            < <Self::TopicList as alloy_sol_types::TopicList>::COUNT
                        {
                            return Err(alloy_sol_types::Error::Overrun);
                        }
                        out[0usize] = alloy_sol_types::abi::token::WordToken(
                            Self::SIGNATURE_HASH,
                        );
                        out[1usize] = <::alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                            &self.token0,
                        );
                        out[2usize] = <::alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                            &self.token1,
                        );
                        out[3usize] = <::alloy::sol_types::sol_data::Uint<
                            24,
                        > as alloy_sol_types::EventTopic>::encode_topic(&self.fee);
                        Ok(())
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::private::IntoLogData for PoolCreated {
                    fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                        From::from(self)
                    }
                    fn into_log_data(self) -> alloy_sol_types::private::LogData {
                        From::from(&self)
                    }
                }
                #[automatically_derived]
                impl From<&PoolCreated> for alloy_sol_types::private::LogData {
                    #[inline]
                    fn from(this: &PoolCreated) -> alloy_sol_types::private::LogData {
                        alloy_sol_types::SolEvent::encode_log_data(this)
                    }
                }
            };
            /**Event with signature `SetLmPoolDeployer(address)` and selector `0x4c912280cda47bed324de14f601d3f125a98254671772f3f1f491e50fa0ca407`.
```solidity
event SetLmPoolDeployer(address indexed lmPoolDeployer);
```*/
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            pub struct SetLmPoolDeployer {
                #[allow(missing_docs)]
                pub lmPoolDeployer: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            impl ::core::clone::Clone for SetLmPoolDeployer {
                #[inline]
                fn clone(&self) -> SetLmPoolDeployer {
                    SetLmPoolDeployer {
                        lmPoolDeployer: ::core::clone::Clone::clone(&self.lmPoolDeployer),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            impl ::core::fmt::Debug for SetLmPoolDeployer {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "SetLmPoolDeployer",
                        "lmPoolDeployer",
                        &&self.lmPoolDeployer,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                #[automatically_derived]
                impl alloy_sol_types::SolEvent for SetLmPoolDeployer {
                    type DataTuple<'a> = ();
                    type DataToken<'a> = <Self::DataTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type TopicList = (
                        alloy_sol_types::sol_data::FixedBytes<32>,
                        ::alloy::sol_types::sol_data::Address,
                    );
                    const SIGNATURE: &'static str = "SetLmPoolDeployer(address)";
                    const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                        76u8,
                        145u8,
                        34u8,
                        128u8,
                        205u8,
                        164u8,
                        123u8,
                        237u8,
                        50u8,
                        77u8,
                        225u8,
                        79u8,
                        96u8,
                        29u8,
                        63u8,
                        18u8,
                        90u8,
                        152u8,
                        37u8,
                        70u8,
                        113u8,
                        119u8,
                        47u8,
                        63u8,
                        31u8,
                        73u8,
                        30u8,
                        80u8,
                        250u8,
                        12u8,
                        164u8,
                        7u8,
                    ]);
                    const ANONYMOUS: bool = false;
                    #[allow(unused_variables)]
                    #[inline]
                    fn new(
                        topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                        data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        Self { lmPoolDeployer: topics.1 }
                    }
                    #[inline]
                    fn tokenize_body(&self) -> Self::DataToken<'_> {
                        ()
                    }
                    #[inline]
                    fn topics(
                        &self,
                    ) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                        (Self::SIGNATURE_HASH.into(), self.lmPoolDeployer.clone())
                    }
                    #[inline]
                    fn encode_topics_raw(
                        &self,
                        out: &mut [alloy_sol_types::abi::token::WordToken],
                    ) -> alloy_sol_types::Result<()> {
                        if out.len()
                            < <Self::TopicList as alloy_sol_types::TopicList>::COUNT
                        {
                            return Err(alloy_sol_types::Error::Overrun);
                        }
                        out[0usize] = alloy_sol_types::abi::token::WordToken(
                            Self::SIGNATURE_HASH,
                        );
                        out[1usize] = <::alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                            &self.lmPoolDeployer,
                        );
                        Ok(())
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::private::IntoLogData for SetLmPoolDeployer {
                    fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                        From::from(self)
                    }
                    fn into_log_data(self) -> alloy_sol_types::private::LogData {
                        From::from(&self)
                    }
                }
                #[automatically_derived]
                impl From<&SetLmPoolDeployer> for alloy_sol_types::private::LogData {
                    #[inline]
                    fn from(
                        this: &SetLmPoolDeployer,
                    ) -> alloy_sol_types::private::LogData {
                        alloy_sol_types::SolEvent::encode_log_data(this)
                    }
                }
            };
            /**Event with signature `WhiteListAdded(address,bool)` and selector `0xaec42ac7f1bb8651906ae6522f50a19429e124e8ea678ef59fd27750759288a2`.
```solidity
event WhiteListAdded(address indexed user, bool verified);
```*/
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            pub struct WhiteListAdded {
                #[allow(missing_docs)]
                pub user: ::alloy::sol_types::private::Address,
                #[allow(missing_docs)]
                pub verified: bool,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            impl ::core::clone::Clone for WhiteListAdded {
                #[inline]
                fn clone(&self) -> WhiteListAdded {
                    WhiteListAdded {
                        user: ::core::clone::Clone::clone(&self.user),
                        verified: ::core::clone::Clone::clone(&self.verified),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            impl ::core::fmt::Debug for WhiteListAdded {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "WhiteListAdded",
                        "user",
                        &self.user,
                        "verified",
                        &&self.verified,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                #[automatically_derived]
                impl alloy_sol_types::SolEvent for WhiteListAdded {
                    type DataTuple<'a> = (::alloy::sol_types::sol_data::Bool,);
                    type DataToken<'a> = <Self::DataTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type TopicList = (
                        alloy_sol_types::sol_data::FixedBytes<32>,
                        ::alloy::sol_types::sol_data::Address,
                    );
                    const SIGNATURE: &'static str = "WhiteListAdded(address,bool)";
                    const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                        174u8,
                        196u8,
                        42u8,
                        199u8,
                        241u8,
                        187u8,
                        134u8,
                        81u8,
                        144u8,
                        106u8,
                        230u8,
                        82u8,
                        47u8,
                        80u8,
                        161u8,
                        148u8,
                        41u8,
                        225u8,
                        36u8,
                        232u8,
                        234u8,
                        103u8,
                        142u8,
                        245u8,
                        159u8,
                        210u8,
                        119u8,
                        80u8,
                        117u8,
                        146u8,
                        136u8,
                        162u8,
                    ]);
                    const ANONYMOUS: bool = false;
                    #[allow(unused_variables)]
                    #[inline]
                    fn new(
                        topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                        data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        Self {
                            user: topics.1,
                            verified: data.0,
                        }
                    }
                    #[inline]
                    fn tokenize_body(&self) -> Self::DataToken<'_> {
                        (
                            <::alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                                &self.verified,
                            ),
                        )
                    }
                    #[inline]
                    fn topics(
                        &self,
                    ) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                        (Self::SIGNATURE_HASH.into(), self.user.clone())
                    }
                    #[inline]
                    fn encode_topics_raw(
                        &self,
                        out: &mut [alloy_sol_types::abi::token::WordToken],
                    ) -> alloy_sol_types::Result<()> {
                        if out.len()
                            < <Self::TopicList as alloy_sol_types::TopicList>::COUNT
                        {
                            return Err(alloy_sol_types::Error::Overrun);
                        }
                        out[0usize] = alloy_sol_types::abi::token::WordToken(
                            Self::SIGNATURE_HASH,
                        );
                        out[1usize] = <::alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                            &self.user,
                        );
                        Ok(())
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::private::IntoLogData for WhiteListAdded {
                    fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                        From::from(self)
                    }
                    fn into_log_data(self) -> alloy_sol_types::private::LogData {
                        From::from(&self)
                    }
                }
                #[automatically_derived]
                impl From<&WhiteListAdded> for alloy_sol_types::private::LogData {
                    #[inline]
                    fn from(this: &WhiteListAdded) -> alloy_sol_types::private::LogData {
                        alloy_sol_types::SolEvent::encode_log_data(this)
                    }
                }
            };
            /**Constructor`.
```solidity
constructor(address _poolDeployer);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct constructorCall {
                pub _poolDeployer: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for constructorCall {
                #[inline]
                fn clone(&self) -> constructorCall {
                    constructorCall {
                        _poolDeployer: ::core::clone::Clone::clone(&self._poolDeployer),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for constructorCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "constructorCall",
                        "_poolDeployer",
                        &&self._poolDeployer,
                    )
                }
            }
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<constructorCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: constructorCall) -> Self {
                            (value._poolDeployer,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for constructorCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _poolDeployer: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolConstructor for constructorCall {
                    type Parameters<'a> = (::alloy::sol_types::sol_data::Address,);
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self._poolDeployer,
                            ),
                        )
                    }
                }
            };
            /**Function with signature `collectProtocol(address,address,uint128,uint128)` and selector `0x43db87da`.
```solidity
function collectProtocol(address pool, address recipient, uint128 amount0Requested, uint128 amount1Requested) external returns (uint128 amount0, uint128 amount1);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct collectProtocolCall {
                pub pool: ::alloy::sol_types::private::Address,
                pub recipient: ::alloy::sol_types::private::Address,
                pub amount0Requested: u128,
                pub amount1Requested: u128,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for collectProtocolCall {
                #[inline]
                fn clone(&self) -> collectProtocolCall {
                    collectProtocolCall {
                        pool: ::core::clone::Clone::clone(&self.pool),
                        recipient: ::core::clone::Clone::clone(&self.recipient),
                        amount0Requested: ::core::clone::Clone::clone(
                            &self.amount0Requested,
                        ),
                        amount1Requested: ::core::clone::Clone::clone(
                            &self.amount1Requested,
                        ),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for collectProtocolCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "collectProtocolCall",
                        "pool",
                        &self.pool,
                        "recipient",
                        &self.recipient,
                        "amount0Requested",
                        &self.amount0Requested,
                        "amount1Requested",
                        &&self.amount1Requested,
                    )
                }
            }
            ///Container type for the return parameters of the [`collectProtocol(address,address,uint128,uint128)`](collectProtocolCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct collectProtocolReturn {
                pub amount0: u128,
                pub amount1: u128,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for collectProtocolReturn {
                #[inline]
                fn clone(&self) -> collectProtocolReturn {
                    collectProtocolReturn {
                        amount0: ::core::clone::Clone::clone(&self.amount0),
                        amount1: ::core::clone::Clone::clone(&self.amount1),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for collectProtocolReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "collectProtocolReturn",
                        "amount0",
                        &self.amount0,
                        "amount1",
                        &&self.amount1,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Uint<128>,
                        ::alloy::sol_types::sol_data::Uint<128>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                        ::alloy::sol_types::private::Address,
                        u128,
                        u128,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<collectProtocolCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: collectProtocolCall) -> Self {
                            (
                                value.pool,
                                value.recipient,
                                value.amount0Requested,
                                value.amount1Requested,
                            )
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for collectProtocolCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {
                                pool: tuple.0,
                                recipient: tuple.1,
                                amount0Requested: tuple.2,
                                amount1Requested: tuple.3,
                            }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Uint<128>,
                        ::alloy::sol_types::sol_data::Uint<128>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (u128, u128);
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<collectProtocolReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: collectProtocolReturn) -> Self {
                            (value.amount0, value.amount1)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for collectProtocolReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {
                                amount0: tuple.0,
                                amount1: tuple.1,
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for collectProtocolCall {
                    type Parameters<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Uint<128>,
                        ::alloy::sol_types::sol_data::Uint<128>,
                    );
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = collectProtocolReturn;
                    type ReturnTuple<'a> = (
                        ::alloy::sol_types::sol_data::Uint<128>,
                        ::alloy::sol_types::sol_data::Uint<128>,
                    );
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "collectProtocol(address,address,uint128,uint128)";
                    const SELECTOR: [u8; 4] = [67u8, 219u8, 135u8, 218u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self.pool,
                            ),
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self.recipient,
                            ),
                            <::alloy::sol_types::sol_data::Uint<
                                128,
                            > as alloy_sol_types::SolType>::tokenize(
                                &self.amount0Requested,
                            ),
                            <::alloy::sol_types::sol_data::Uint<
                                128,
                            > as alloy_sol_types::SolType>::tokenize(
                                &self.amount1Requested,
                            ),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `createPool(address,address,uint24)` and selector `0xa1671295`.
```solidity
function createPool(address tokenA, address tokenB, uint24 fee) external returns (address pool);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct createPoolCall {
                pub tokenA: ::alloy::sol_types::private::Address,
                pub tokenB: ::alloy::sol_types::private::Address,
                pub fee: <::alloy::sol_types::sol_data::Uint<
                    24,
                > as ::alloy::sol_types::SolType>::RustType,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for createPoolCall {
                #[inline]
                fn clone(&self) -> createPoolCall {
                    createPoolCall {
                        tokenA: ::core::clone::Clone::clone(&self.tokenA),
                        tokenB: ::core::clone::Clone::clone(&self.tokenB),
                        fee: ::core::clone::Clone::clone(&self.fee),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for createPoolCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "createPoolCall",
                        "tokenA",
                        &self.tokenA,
                        "tokenB",
                        &self.tokenB,
                        "fee",
                        &&self.fee,
                    )
                }
            }
            ///Container type for the return parameters of the [`createPool(address,address,uint24)`](createPoolCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct createPoolReturn {
                pub pool: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for createPoolReturn {
                #[inline]
                fn clone(&self) -> createPoolReturn {
                    createPoolReturn {
                        pool: ::core::clone::Clone::clone(&self.pool),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for createPoolReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "createPoolReturn",
                        "pool",
                        &&self.pool,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Uint<24>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                        ::alloy::sol_types::private::Address,
                        <::alloy::sol_types::sol_data::Uint<
                            24,
                        > as ::alloy::sol_types::SolType>::RustType,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<createPoolCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: createPoolCall) -> Self {
                            (value.tokenA, value.tokenB, value.fee)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for createPoolCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {
                                tokenA: tuple.0,
                                tokenB: tuple.1,
                                fee: tuple.2,
                            }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<createPoolReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: createPoolReturn) -> Self {
                            (value.pool,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for createPoolReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { pool: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for createPoolCall {
                    type Parameters<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Uint<24>,
                    );
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = createPoolReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Address,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "createPool(address,address,uint24)";
                    const SELECTOR: [u8; 4] = [161u8, 103u8, 18u8, 149u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self.tokenA,
                            ),
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self.tokenB,
                            ),
                            <::alloy::sol_types::sol_data::Uint<
                                24,
                            > as alloy_sol_types::SolType>::tokenize(&self.fee),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `enableFeeAmount(uint24,int24)` and selector `0x8a7c195f`.
```solidity
function enableFeeAmount(uint24 fee, int24 tickSpacing) external;
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct enableFeeAmountCall {
                pub fee: <::alloy::sol_types::sol_data::Uint<
                    24,
                > as ::alloy::sol_types::SolType>::RustType,
                pub tickSpacing: <::alloy::sol_types::sol_data::Int<
                    24,
                > as ::alloy::sol_types::SolType>::RustType,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for enableFeeAmountCall {
                #[inline]
                fn clone(&self) -> enableFeeAmountCall {
                    enableFeeAmountCall {
                        fee: ::core::clone::Clone::clone(&self.fee),
                        tickSpacing: ::core::clone::Clone::clone(&self.tickSpacing),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for enableFeeAmountCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "enableFeeAmountCall",
                        "fee",
                        &self.fee,
                        "tickSpacing",
                        &&self.tickSpacing,
                    )
                }
            }
            ///Container type for the return parameters of the [`enableFeeAmount(uint24,int24)`](enableFeeAmountCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct enableFeeAmountReturn {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for enableFeeAmountReturn {
                #[inline]
                fn clone(&self) -> enableFeeAmountReturn {
                    enableFeeAmountReturn {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for enableFeeAmountReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "enableFeeAmountReturn")
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Uint<24>,
                        ::alloy::sol_types::sol_data::Int<24>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        <::alloy::sol_types::sol_data::Uint<
                            24,
                        > as ::alloy::sol_types::SolType>::RustType,
                        <::alloy::sol_types::sol_data::Int<
                            24,
                        > as ::alloy::sol_types::SolType>::RustType,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<enableFeeAmountCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: enableFeeAmountCall) -> Self {
                            (value.fee, value.tickSpacing)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for enableFeeAmountCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {
                                fee: tuple.0,
                                tickSpacing: tuple.1,
                            }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<enableFeeAmountReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: enableFeeAmountReturn) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for enableFeeAmountReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for enableFeeAmountCall {
                    type Parameters<'a> = (
                        ::alloy::sol_types::sol_data::Uint<24>,
                        ::alloy::sol_types::sol_data::Int<24>,
                    );
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = enableFeeAmountReturn;
                    type ReturnTuple<'a> = ();
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "enableFeeAmount(uint24,int24)";
                    const SELECTOR: [u8; 4] = [138u8, 124u8, 25u8, 95u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Uint<
                                24,
                            > as alloy_sol_types::SolType>::tokenize(&self.fee),
                            <::alloy::sol_types::sol_data::Int<
                                24,
                            > as alloy_sol_types::SolType>::tokenize(&self.tickSpacing),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `feeAmountTickSpacing(uint24)` and selector `0x22afcccb`.
```solidity
function feeAmountTickSpacing(uint24) external view returns (int24);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct feeAmountTickSpacingCall {
                pub _0: <::alloy::sol_types::sol_data::Uint<
                    24,
                > as ::alloy::sol_types::SolType>::RustType,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for feeAmountTickSpacingCall {
                #[inline]
                fn clone(&self) -> feeAmountTickSpacingCall {
                    feeAmountTickSpacingCall {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for feeAmountTickSpacingCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "feeAmountTickSpacingCall",
                        "_0",
                        &&self._0,
                    )
                }
            }
            ///Container type for the return parameters of the [`feeAmountTickSpacing(uint24)`](feeAmountTickSpacingCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct feeAmountTickSpacingReturn {
                pub _0: <::alloy::sol_types::sol_data::Int<
                    24,
                > as ::alloy::sol_types::SolType>::RustType,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for feeAmountTickSpacingReturn {
                #[inline]
                fn clone(&self) -> feeAmountTickSpacingReturn {
                    feeAmountTickSpacingReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for feeAmountTickSpacingReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "feeAmountTickSpacingReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Uint<24>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        <::alloy::sol_types::sol_data::Uint<
                            24,
                        > as ::alloy::sol_types::SolType>::RustType,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<feeAmountTickSpacingCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: feeAmountTickSpacingCall) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for feeAmountTickSpacingCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Int<24>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        <::alloy::sol_types::sol_data::Int<
                            24,
                        > as ::alloy::sol_types::SolType>::RustType,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<feeAmountTickSpacingReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: feeAmountTickSpacingReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for feeAmountTickSpacingReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for feeAmountTickSpacingCall {
                    type Parameters<'a> = (::alloy::sol_types::sol_data::Uint<24>,);
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = feeAmountTickSpacingReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Int<24>,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "feeAmountTickSpacing(uint24)";
                    const SELECTOR: [u8; 4] = [34u8, 175u8, 204u8, 203u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Uint<
                                24,
                            > as alloy_sol_types::SolType>::tokenize(&self._0),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `feeAmountTickSpacingExtraInfo(uint24)` and selector `0x88e8006d`.
```solidity
function feeAmountTickSpacingExtraInfo(uint24) external view returns (bool whitelistRequested, bool enabled);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct feeAmountTickSpacingExtraInfoCall {
                pub _0: <::alloy::sol_types::sol_data::Uint<
                    24,
                > as ::alloy::sol_types::SolType>::RustType,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for feeAmountTickSpacingExtraInfoCall {
                #[inline]
                fn clone(&self) -> feeAmountTickSpacingExtraInfoCall {
                    feeAmountTickSpacingExtraInfoCall {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for feeAmountTickSpacingExtraInfoCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "feeAmountTickSpacingExtraInfoCall",
                        "_0",
                        &&self._0,
                    )
                }
            }
            ///Container type for the return parameters of the [`feeAmountTickSpacingExtraInfo(uint24)`](feeAmountTickSpacingExtraInfoCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct feeAmountTickSpacingExtraInfoReturn {
                pub whitelistRequested: bool,
                pub enabled: bool,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for feeAmountTickSpacingExtraInfoReturn {
                #[inline]
                fn clone(&self) -> feeAmountTickSpacingExtraInfoReturn {
                    feeAmountTickSpacingExtraInfoReturn {
                        whitelistRequested: ::core::clone::Clone::clone(
                            &self.whitelistRequested,
                        ),
                        enabled: ::core::clone::Clone::clone(&self.enabled),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for feeAmountTickSpacingExtraInfoReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "feeAmountTickSpacingExtraInfoReturn",
                        "whitelistRequested",
                        &self.whitelistRequested,
                        "enabled",
                        &&self.enabled,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Uint<24>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        <::alloy::sol_types::sol_data::Uint<
                            24,
                        > as ::alloy::sol_types::SolType>::RustType,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<feeAmountTickSpacingExtraInfoCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: feeAmountTickSpacingExtraInfoCall) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for feeAmountTickSpacingExtraInfoCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Bool,
                        ::alloy::sol_types::sol_data::Bool,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (bool, bool);
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<feeAmountTickSpacingExtraInfoReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: feeAmountTickSpacingExtraInfoReturn) -> Self {
                            (value.whitelistRequested, value.enabled)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for feeAmountTickSpacingExtraInfoReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {
                                whitelistRequested: tuple.0,
                                enabled: tuple.1,
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for feeAmountTickSpacingExtraInfoCall {
                    type Parameters<'a> = (::alloy::sol_types::sol_data::Uint<24>,);
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = feeAmountTickSpacingExtraInfoReturn;
                    type ReturnTuple<'a> = (
                        ::alloy::sol_types::sol_data::Bool,
                        ::alloy::sol_types::sol_data::Bool,
                    );
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "feeAmountTickSpacingExtraInfo(uint24)";
                    const SELECTOR: [u8; 4] = [136u8, 232u8, 0u8, 109u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Uint<
                                24,
                            > as alloy_sol_types::SolType>::tokenize(&self._0),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `getPool(address,address,uint24)` and selector `0x1698ee82`.
```solidity
function getPool(address, address, uint24) external view returns (address);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct getPoolCall {
                pub _0: ::alloy::sol_types::private::Address,
                pub _1: ::alloy::sol_types::private::Address,
                pub _2: <::alloy::sol_types::sol_data::Uint<
                    24,
                > as ::alloy::sol_types::SolType>::RustType,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for getPoolCall {
                #[inline]
                fn clone(&self) -> getPoolCall {
                    getPoolCall {
                        _0: ::core::clone::Clone::clone(&self._0),
                        _1: ::core::clone::Clone::clone(&self._1),
                        _2: ::core::clone::Clone::clone(&self._2),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for getPoolCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "getPoolCall",
                        "_0",
                        &self._0,
                        "_1",
                        &self._1,
                        "_2",
                        &&self._2,
                    )
                }
            }
            ///Container type for the return parameters of the [`getPool(address,address,uint24)`](getPoolCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct getPoolReturn {
                pub _0: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for getPoolReturn {
                #[inline]
                fn clone(&self) -> getPoolReturn {
                    getPoolReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for getPoolReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "getPoolReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Uint<24>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                        ::alloy::sol_types::private::Address,
                        <::alloy::sol_types::sol_data::Uint<
                            24,
                        > as ::alloy::sol_types::SolType>::RustType,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<getPoolCall> for UnderlyingRustTuple<'_> {
                        fn from(value: getPoolCall) -> Self {
                            (value._0, value._1, value._2)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>> for getPoolCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {
                                _0: tuple.0,
                                _1: tuple.1,
                                _2: tuple.2,
                            }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<getPoolReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: getPoolReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for getPoolReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for getPoolCall {
                    type Parameters<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Uint<24>,
                    );
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = getPoolReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Address,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "getPool(address,address,uint24)";
                    const SELECTOR: [u8; 4] = [22u8, 152u8, 238u8, 130u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self._0,
                            ),
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self._1,
                            ),
                            <::alloy::sol_types::sol_data::Uint<
                                24,
                            > as alloy_sol_types::SolType>::tokenize(&self._2),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `lmPoolDeployer()` and selector `0x5e492ac8`.
```solidity
function lmPoolDeployer() external view returns (address);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct lmPoolDeployerCall {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for lmPoolDeployerCall {
                #[inline]
                fn clone(&self) -> lmPoolDeployerCall {
                    lmPoolDeployerCall {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for lmPoolDeployerCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "lmPoolDeployerCall")
                }
            }
            ///Container type for the return parameters of the [`lmPoolDeployer()`](lmPoolDeployerCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct lmPoolDeployerReturn {
                pub _0: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for lmPoolDeployerReturn {
                #[inline]
                fn clone(&self) -> lmPoolDeployerReturn {
                    lmPoolDeployerReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for lmPoolDeployerReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "lmPoolDeployerReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<lmPoolDeployerCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: lmPoolDeployerCall) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for lmPoolDeployerCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<lmPoolDeployerReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: lmPoolDeployerReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for lmPoolDeployerReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for lmPoolDeployerCall {
                    type Parameters<'a> = ();
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = lmPoolDeployerReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Address,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "lmPoolDeployer()";
                    const SELECTOR: [u8; 4] = [94u8, 73u8, 42u8, 200u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `owner()` and selector `0x8da5cb5b`.
```solidity
function owner() external view returns (address);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct ownerCall {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for ownerCall {
                #[inline]
                fn clone(&self) -> ownerCall {
                    ownerCall {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for ownerCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "ownerCall")
                }
            }
            ///Container type for the return parameters of the [`owner()`](ownerCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct ownerReturn {
                pub _0: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for ownerReturn {
                #[inline]
                fn clone(&self) -> ownerReturn {
                    ownerReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for ownerReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "ownerReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<ownerCall> for UnderlyingRustTuple<'_> {
                        fn from(value: ownerCall) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<ownerReturn> for UnderlyingRustTuple<'_> {
                        fn from(value: ownerReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for ownerCall {
                    type Parameters<'a> = ();
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = ownerReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Address,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "owner()";
                    const SELECTOR: [u8; 4] = [141u8, 165u8, 203u8, 91u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `poolDeployer()` and selector `0x3119049a`.
```solidity
function poolDeployer() external view returns (address);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct poolDeployerCall {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for poolDeployerCall {
                #[inline]
                fn clone(&self) -> poolDeployerCall {
                    poolDeployerCall {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for poolDeployerCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "poolDeployerCall")
                }
            }
            ///Container type for the return parameters of the [`poolDeployer()`](poolDeployerCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct poolDeployerReturn {
                pub _0: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for poolDeployerReturn {
                #[inline]
                fn clone(&self) -> poolDeployerReturn {
                    poolDeployerReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for poolDeployerReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "poolDeployerReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<poolDeployerCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: poolDeployerCall) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for poolDeployerCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<poolDeployerReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: poolDeployerReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for poolDeployerReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for poolDeployerCall {
                    type Parameters<'a> = ();
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = poolDeployerReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Address,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "poolDeployer()";
                    const SELECTOR: [u8; 4] = [49u8, 25u8, 4u8, 154u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `setFeeAmountExtraInfo(uint24,bool,bool)` and selector `0x8ff38e80`.
```solidity
function setFeeAmountExtraInfo(uint24 fee, bool whitelistRequested, bool enabled) external;
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct setFeeAmountExtraInfoCall {
                pub fee: <::alloy::sol_types::sol_data::Uint<
                    24,
                > as ::alloy::sol_types::SolType>::RustType,
                pub whitelistRequested: bool,
                pub enabled: bool,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for setFeeAmountExtraInfoCall {
                #[inline]
                fn clone(&self) -> setFeeAmountExtraInfoCall {
                    setFeeAmountExtraInfoCall {
                        fee: ::core::clone::Clone::clone(&self.fee),
                        whitelistRequested: ::core::clone::Clone::clone(
                            &self.whitelistRequested,
                        ),
                        enabled: ::core::clone::Clone::clone(&self.enabled),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for setFeeAmountExtraInfoCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "setFeeAmountExtraInfoCall",
                        "fee",
                        &self.fee,
                        "whitelistRequested",
                        &self.whitelistRequested,
                        "enabled",
                        &&self.enabled,
                    )
                }
            }
            ///Container type for the return parameters of the [`setFeeAmountExtraInfo(uint24,bool,bool)`](setFeeAmountExtraInfoCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct setFeeAmountExtraInfoReturn {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for setFeeAmountExtraInfoReturn {
                #[inline]
                fn clone(&self) -> setFeeAmountExtraInfoReturn {
                    setFeeAmountExtraInfoReturn {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for setFeeAmountExtraInfoReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "setFeeAmountExtraInfoReturn")
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Uint<24>,
                        ::alloy::sol_types::sol_data::Bool,
                        ::alloy::sol_types::sol_data::Bool,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        <::alloy::sol_types::sol_data::Uint<
                            24,
                        > as ::alloy::sol_types::SolType>::RustType,
                        bool,
                        bool,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<setFeeAmountExtraInfoCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: setFeeAmountExtraInfoCall) -> Self {
                            (value.fee, value.whitelistRequested, value.enabled)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for setFeeAmountExtraInfoCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {
                                fee: tuple.0,
                                whitelistRequested: tuple.1,
                                enabled: tuple.2,
                            }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<setFeeAmountExtraInfoReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: setFeeAmountExtraInfoReturn) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for setFeeAmountExtraInfoReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for setFeeAmountExtraInfoCall {
                    type Parameters<'a> = (
                        ::alloy::sol_types::sol_data::Uint<24>,
                        ::alloy::sol_types::sol_data::Bool,
                        ::alloy::sol_types::sol_data::Bool,
                    );
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = setFeeAmountExtraInfoReturn;
                    type ReturnTuple<'a> = ();
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "setFeeAmountExtraInfo(uint24,bool,bool)";
                    const SELECTOR: [u8; 4] = [143u8, 243u8, 142u8, 128u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Uint<
                                24,
                            > as alloy_sol_types::SolType>::tokenize(&self.fee),
                            <::alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                                &self.whitelistRequested,
                            ),
                            <::alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                                &self.enabled,
                            ),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `setFeeProtocol(address,uint32,uint32)` and selector `0x7e8435e6`.
```solidity
function setFeeProtocol(address pool, uint32 feeProtocol0, uint32 feeProtocol1) external;
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct setFeeProtocolCall {
                pub pool: ::alloy::sol_types::private::Address,
                pub feeProtocol0: u32,
                pub feeProtocol1: u32,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for setFeeProtocolCall {
                #[inline]
                fn clone(&self) -> setFeeProtocolCall {
                    setFeeProtocolCall {
                        pool: ::core::clone::Clone::clone(&self.pool),
                        feeProtocol0: ::core::clone::Clone::clone(&self.feeProtocol0),
                        feeProtocol1: ::core::clone::Clone::clone(&self.feeProtocol1),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for setFeeProtocolCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "setFeeProtocolCall",
                        "pool",
                        &self.pool,
                        "feeProtocol0",
                        &self.feeProtocol0,
                        "feeProtocol1",
                        &&self.feeProtocol1,
                    )
                }
            }
            ///Container type for the return parameters of the [`setFeeProtocol(address,uint32,uint32)`](setFeeProtocolCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct setFeeProtocolReturn {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for setFeeProtocolReturn {
                #[inline]
                fn clone(&self) -> setFeeProtocolReturn {
                    setFeeProtocolReturn {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for setFeeProtocolReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "setFeeProtocolReturn")
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Uint<32>,
                        ::alloy::sol_types::sol_data::Uint<32>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                        u32,
                        u32,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<setFeeProtocolCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: setFeeProtocolCall) -> Self {
                            (value.pool, value.feeProtocol0, value.feeProtocol1)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for setFeeProtocolCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {
                                pool: tuple.0,
                                feeProtocol0: tuple.1,
                                feeProtocol1: tuple.2,
                            }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<setFeeProtocolReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: setFeeProtocolReturn) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for setFeeProtocolReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for setFeeProtocolCall {
                    type Parameters<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Uint<32>,
                        ::alloy::sol_types::sol_data::Uint<32>,
                    );
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = setFeeProtocolReturn;
                    type ReturnTuple<'a> = ();
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "setFeeProtocol(address,uint32,uint32)";
                    const SELECTOR: [u8; 4] = [126u8, 132u8, 53u8, 230u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self.pool,
                            ),
                            <::alloy::sol_types::sol_data::Uint<
                                32,
                            > as alloy_sol_types::SolType>::tokenize(&self.feeProtocol0),
                            <::alloy::sol_types::sol_data::Uint<
                                32,
                            > as alloy_sol_types::SolType>::tokenize(&self.feeProtocol1),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `setLmPool(address,address)` and selector `0x11ff5e8d`.
```solidity
function setLmPool(address pool, address lmPool) external;
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct setLmPoolCall {
                pub pool: ::alloy::sol_types::private::Address,
                pub lmPool: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for setLmPoolCall {
                #[inline]
                fn clone(&self) -> setLmPoolCall {
                    setLmPoolCall {
                        pool: ::core::clone::Clone::clone(&self.pool),
                        lmPool: ::core::clone::Clone::clone(&self.lmPool),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for setLmPoolCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "setLmPoolCall",
                        "pool",
                        &self.pool,
                        "lmPool",
                        &&self.lmPool,
                    )
                }
            }
            ///Container type for the return parameters of the [`setLmPool(address,address)`](setLmPoolCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct setLmPoolReturn {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for setLmPoolReturn {
                #[inline]
                fn clone(&self) -> setLmPoolReturn {
                    setLmPoolReturn {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for setLmPoolReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "setLmPoolReturn")
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<setLmPoolCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: setLmPoolCall) -> Self {
                            (value.pool, value.lmPool)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for setLmPoolCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {
                                pool: tuple.0,
                                lmPool: tuple.1,
                            }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<setLmPoolReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: setLmPoolReturn) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for setLmPoolReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for setLmPoolCall {
                    type Parameters<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                    );
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = setLmPoolReturn;
                    type ReturnTuple<'a> = ();
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "setLmPool(address,address)";
                    const SELECTOR: [u8; 4] = [17u8, 255u8, 94u8, 141u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self.pool,
                            ),
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self.lmPool,
                            ),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `setLmPoolDeployer(address)` and selector `0x80d6a792`.
```solidity
function setLmPoolDeployer(address _lmPoolDeployer) external;
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct setLmPoolDeployerCall {
                pub _lmPoolDeployer: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for setLmPoolDeployerCall {
                #[inline]
                fn clone(&self) -> setLmPoolDeployerCall {
                    setLmPoolDeployerCall {
                        _lmPoolDeployer: ::core::clone::Clone::clone(
                            &self._lmPoolDeployer,
                        ),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for setLmPoolDeployerCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "setLmPoolDeployerCall",
                        "_lmPoolDeployer",
                        &&self._lmPoolDeployer,
                    )
                }
            }
            ///Container type for the return parameters of the [`setLmPoolDeployer(address)`](setLmPoolDeployerCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct setLmPoolDeployerReturn {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for setLmPoolDeployerReturn {
                #[inline]
                fn clone(&self) -> setLmPoolDeployerReturn {
                    setLmPoolDeployerReturn {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for setLmPoolDeployerReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "setLmPoolDeployerReturn")
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<setLmPoolDeployerCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: setLmPoolDeployerCall) -> Self {
                            (value._lmPoolDeployer,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for setLmPoolDeployerCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _lmPoolDeployer: tuple.0 }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<setLmPoolDeployerReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: setLmPoolDeployerReturn) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for setLmPoolDeployerReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for setLmPoolDeployerCall {
                    type Parameters<'a> = (::alloy::sol_types::sol_data::Address,);
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = setLmPoolDeployerReturn;
                    type ReturnTuple<'a> = ();
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "setLmPoolDeployer(address)";
                    const SELECTOR: [u8; 4] = [128u8, 214u8, 167u8, 146u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self._lmPoolDeployer,
                            ),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `setOwner(address)` and selector `0x13af4035`.
```solidity
function setOwner(address _owner) external;
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct setOwnerCall {
                pub _owner: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for setOwnerCall {
                #[inline]
                fn clone(&self) -> setOwnerCall {
                    setOwnerCall {
                        _owner: ::core::clone::Clone::clone(&self._owner),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for setOwnerCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "setOwnerCall",
                        "_owner",
                        &&self._owner,
                    )
                }
            }
            ///Container type for the return parameters of the [`setOwner(address)`](setOwnerCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct setOwnerReturn {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for setOwnerReturn {
                #[inline]
                fn clone(&self) -> setOwnerReturn {
                    setOwnerReturn {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for setOwnerReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "setOwnerReturn")
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<setOwnerCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: setOwnerCall) -> Self {
                            (value._owner,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for setOwnerCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _owner: tuple.0 }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<setOwnerReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: setOwnerReturn) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for setOwnerReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for setOwnerCall {
                    type Parameters<'a> = (::alloy::sol_types::sol_data::Address,);
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = setOwnerReturn;
                    type ReturnTuple<'a> = ();
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "setOwner(address)";
                    const SELECTOR: [u8; 4] = [19u8, 175u8, 64u8, 53u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self._owner,
                            ),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `setWhiteListAddress(address,bool)` and selector `0xe4a86a99`.
```solidity
function setWhiteListAddress(address user, bool verified) external;
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct setWhiteListAddressCall {
                pub user: ::alloy::sol_types::private::Address,
                pub verified: bool,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for setWhiteListAddressCall {
                #[inline]
                fn clone(&self) -> setWhiteListAddressCall {
                    setWhiteListAddressCall {
                        user: ::core::clone::Clone::clone(&self.user),
                        verified: ::core::clone::Clone::clone(&self.verified),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for setWhiteListAddressCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "setWhiteListAddressCall",
                        "user",
                        &self.user,
                        "verified",
                        &&self.verified,
                    )
                }
            }
            ///Container type for the return parameters of the [`setWhiteListAddress(address,bool)`](setWhiteListAddressCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct setWhiteListAddressReturn {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for setWhiteListAddressReturn {
                #[inline]
                fn clone(&self) -> setWhiteListAddressReturn {
                    setWhiteListAddressReturn {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for setWhiteListAddressReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "setWhiteListAddressReturn")
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Bool,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                        bool,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<setWhiteListAddressCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: setWhiteListAddressCall) -> Self {
                            (value.user, value.verified)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for setWhiteListAddressCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {
                                user: tuple.0,
                                verified: tuple.1,
                            }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<setWhiteListAddressReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: setWhiteListAddressReturn) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for setWhiteListAddressReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for setWhiteListAddressCall {
                    type Parameters<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Bool,
                    );
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = setWhiteListAddressReturn;
                    type ReturnTuple<'a> = ();
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "setWhiteListAddress(address,bool)";
                    const SELECTOR: [u8; 4] = [228u8, 168u8, 106u8, 153u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self.user,
                            ),
                            <::alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                                &self.verified,
                            ),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            ///Container for all the [`PancakeSwapV3Factory`](self) function calls.
            pub enum PancakeSwapV3FactoryCalls {
                collectProtocol(collectProtocolCall),
                createPool(createPoolCall),
                enableFeeAmount(enableFeeAmountCall),
                feeAmountTickSpacing(feeAmountTickSpacingCall),
                feeAmountTickSpacingExtraInfo(feeAmountTickSpacingExtraInfoCall),
                getPool(getPoolCall),
                lmPoolDeployer(lmPoolDeployerCall),
                owner(ownerCall),
                poolDeployer(poolDeployerCall),
                setFeeAmountExtraInfo(setFeeAmountExtraInfoCall),
                setFeeProtocol(setFeeProtocolCall),
                setLmPool(setLmPoolCall),
                setLmPoolDeployer(setLmPoolDeployerCall),
                setOwner(setOwnerCall),
                setWhiteListAddress(setWhiteListAddressCall),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for PancakeSwapV3FactoryCalls {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        PancakeSwapV3FactoryCalls::collectProtocol(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "collectProtocol",
                                &__self_0,
                            )
                        }
                        PancakeSwapV3FactoryCalls::createPool(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "createPool",
                                &__self_0,
                            )
                        }
                        PancakeSwapV3FactoryCalls::enableFeeAmount(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "enableFeeAmount",
                                &__self_0,
                            )
                        }
                        PancakeSwapV3FactoryCalls::feeAmountTickSpacing(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "feeAmountTickSpacing",
                                &__self_0,
                            )
                        }
                        PancakeSwapV3FactoryCalls::feeAmountTickSpacingExtraInfo(
                            __self_0,
                        ) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "feeAmountTickSpacingExtraInfo",
                                &__self_0,
                            )
                        }
                        PancakeSwapV3FactoryCalls::getPool(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "getPool",
                                &__self_0,
                            )
                        }
                        PancakeSwapV3FactoryCalls::lmPoolDeployer(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "lmPoolDeployer",
                                &__self_0,
                            )
                        }
                        PancakeSwapV3FactoryCalls::owner(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "owner",
                                &__self_0,
                            )
                        }
                        PancakeSwapV3FactoryCalls::poolDeployer(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "poolDeployer",
                                &__self_0,
                            )
                        }
                        PancakeSwapV3FactoryCalls::setFeeAmountExtraInfo(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "setFeeAmountExtraInfo",
                                &__self_0,
                            )
                        }
                        PancakeSwapV3FactoryCalls::setFeeProtocol(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "setFeeProtocol",
                                &__self_0,
                            )
                        }
                        PancakeSwapV3FactoryCalls::setLmPool(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "setLmPool",
                                &__self_0,
                            )
                        }
                        PancakeSwapV3FactoryCalls::setLmPoolDeployer(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "setLmPoolDeployer",
                                &__self_0,
                            )
                        }
                        PancakeSwapV3FactoryCalls::setOwner(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "setOwner",
                                &__self_0,
                            )
                        }
                        PancakeSwapV3FactoryCalls::setWhiteListAddress(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "setWhiteListAddress",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl PancakeSwapV3FactoryCalls {
                /// All the selectors of this enum.
                ///
                /// Note that the selectors might not be in the same order as the variants.
                /// No guarantees are made about the order of the selectors.
                ///
                /// Prefer using `SolInterface` methods instead.
                pub const SELECTORS: &'static [[u8; 4usize]] = &[
                    [17u8, 255u8, 94u8, 141u8],
                    [19u8, 175u8, 64u8, 53u8],
                    [22u8, 152u8, 238u8, 130u8],
                    [34u8, 175u8, 204u8, 203u8],
                    [49u8, 25u8, 4u8, 154u8],
                    [67u8, 219u8, 135u8, 218u8],
                    [94u8, 73u8, 42u8, 200u8],
                    [126u8, 132u8, 53u8, 230u8],
                    [128u8, 214u8, 167u8, 146u8],
                    [136u8, 232u8, 0u8, 109u8],
                    [138u8, 124u8, 25u8, 95u8],
                    [141u8, 165u8, 203u8, 91u8],
                    [143u8, 243u8, 142u8, 128u8],
                    [161u8, 103u8, 18u8, 149u8],
                    [228u8, 168u8, 106u8, 153u8],
                ];
            }
            #[automatically_derived]
            impl alloy_sol_types::SolInterface for PancakeSwapV3FactoryCalls {
                const NAME: &'static str = "PancakeSwapV3FactoryCalls";
                const MIN_DATA_LENGTH: usize = 0usize;
                const COUNT: usize = 15usize;
                #[inline]
                fn selector(&self) -> [u8; 4] {
                    match self {
                        Self::collectProtocol(_) => {
                            <collectProtocolCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::createPool(_) => {
                            <createPoolCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::enableFeeAmount(_) => {
                            <enableFeeAmountCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::feeAmountTickSpacing(_) => {
                            <feeAmountTickSpacingCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::feeAmountTickSpacingExtraInfo(_) => {
                            <feeAmountTickSpacingExtraInfoCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::getPool(_) => {
                            <getPoolCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::lmPoolDeployer(_) => {
                            <lmPoolDeployerCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::owner(_) => {
                            <ownerCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::poolDeployer(_) => {
                            <poolDeployerCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::setFeeAmountExtraInfo(_) => {
                            <setFeeAmountExtraInfoCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::setFeeProtocol(_) => {
                            <setFeeProtocolCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::setLmPool(_) => {
                            <setLmPoolCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::setLmPoolDeployer(_) => {
                            <setLmPoolDeployerCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::setOwner(_) => {
                            <setOwnerCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::setWhiteListAddress(_) => {
                            <setWhiteListAddressCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                    }
                }
                #[inline]
                fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
                    Self::SELECTORS.get(i).copied()
                }
                #[inline]
                fn valid_selector(selector: [u8; 4]) -> bool {
                    Self::SELECTORS.binary_search(&selector).is_ok()
                }
                #[inline]
                #[allow(unsafe_code, non_snake_case)]
                fn abi_decode_raw(
                    selector: [u8; 4],
                    data: &[u8],
                    validate: bool,
                ) -> alloy_sol_types::Result<Self> {
                    static DECODE_SHIMS: &[fn(
                        &[u8],
                        bool,
                    ) -> alloy_sol_types::Result<PancakeSwapV3FactoryCalls>] = &[
                        {
                            fn setLmPool(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<PancakeSwapV3FactoryCalls> {
                                <setLmPoolCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(PancakeSwapV3FactoryCalls::setLmPool)
                            }
                            setLmPool
                        },
                        {
                            fn setOwner(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<PancakeSwapV3FactoryCalls> {
                                <setOwnerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(PancakeSwapV3FactoryCalls::setOwner)
                            }
                            setOwner
                        },
                        {
                            fn getPool(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<PancakeSwapV3FactoryCalls> {
                                <getPoolCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(PancakeSwapV3FactoryCalls::getPool)
                            }
                            getPool
                        },
                        {
                            fn feeAmountTickSpacing(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<PancakeSwapV3FactoryCalls> {
                                <feeAmountTickSpacingCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(PancakeSwapV3FactoryCalls::feeAmountTickSpacing)
                            }
                            feeAmountTickSpacing
                        },
                        {
                            fn poolDeployer(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<PancakeSwapV3FactoryCalls> {
                                <poolDeployerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(PancakeSwapV3FactoryCalls::poolDeployer)
                            }
                            poolDeployer
                        },
                        {
                            fn collectProtocol(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<PancakeSwapV3FactoryCalls> {
                                <collectProtocolCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(PancakeSwapV3FactoryCalls::collectProtocol)
                            }
                            collectProtocol
                        },
                        {
                            fn lmPoolDeployer(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<PancakeSwapV3FactoryCalls> {
                                <lmPoolDeployerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(PancakeSwapV3FactoryCalls::lmPoolDeployer)
                            }
                            lmPoolDeployer
                        },
                        {
                            fn setFeeProtocol(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<PancakeSwapV3FactoryCalls> {
                                <setFeeProtocolCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(PancakeSwapV3FactoryCalls::setFeeProtocol)
                            }
                            setFeeProtocol
                        },
                        {
                            fn setLmPoolDeployer(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<PancakeSwapV3FactoryCalls> {
                                <setLmPoolDeployerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(PancakeSwapV3FactoryCalls::setLmPoolDeployer)
                            }
                            setLmPoolDeployer
                        },
                        {
                            fn feeAmountTickSpacingExtraInfo(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<PancakeSwapV3FactoryCalls> {
                                <feeAmountTickSpacingExtraInfoCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(
                                        PancakeSwapV3FactoryCalls::feeAmountTickSpacingExtraInfo,
                                    )
                            }
                            feeAmountTickSpacingExtraInfo
                        },
                        {
                            fn enableFeeAmount(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<PancakeSwapV3FactoryCalls> {
                                <enableFeeAmountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(PancakeSwapV3FactoryCalls::enableFeeAmount)
                            }
                            enableFeeAmount
                        },
                        {
                            fn owner(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<PancakeSwapV3FactoryCalls> {
                                <ownerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(PancakeSwapV3FactoryCalls::owner)
                            }
                            owner
                        },
                        {
                            fn setFeeAmountExtraInfo(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<PancakeSwapV3FactoryCalls> {
                                <setFeeAmountExtraInfoCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(PancakeSwapV3FactoryCalls::setFeeAmountExtraInfo)
                            }
                            setFeeAmountExtraInfo
                        },
                        {
                            fn createPool(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<PancakeSwapV3FactoryCalls> {
                                <createPoolCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(PancakeSwapV3FactoryCalls::createPool)
                            }
                            createPool
                        },
                        {
                            fn setWhiteListAddress(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<PancakeSwapV3FactoryCalls> {
                                <setWhiteListAddressCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(PancakeSwapV3FactoryCalls::setWhiteListAddress)
                            }
                            setWhiteListAddress
                        },
                    ];
                    let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                        return Err(
                            alloy_sol_types::Error::unknown_selector(
                                <Self as alloy_sol_types::SolInterface>::NAME,
                                selector,
                            ),
                        );
                    };
                    (unsafe { DECODE_SHIMS.get_unchecked(idx) })(data, validate)
                }
                #[inline]
                fn abi_encoded_size(&self) -> usize {
                    match self {
                        Self::collectProtocol(inner) => {
                            <collectProtocolCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::createPool(inner) => {
                            <createPoolCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::enableFeeAmount(inner) => {
                            <enableFeeAmountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::feeAmountTickSpacing(inner) => {
                            <feeAmountTickSpacingCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::feeAmountTickSpacingExtraInfo(inner) => {
                            <feeAmountTickSpacingExtraInfoCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::getPool(inner) => {
                            <getPoolCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::lmPoolDeployer(inner) => {
                            <lmPoolDeployerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::owner(inner) => {
                            <ownerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::poolDeployer(inner) => {
                            <poolDeployerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::setFeeAmountExtraInfo(inner) => {
                            <setFeeAmountExtraInfoCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::setFeeProtocol(inner) => {
                            <setFeeProtocolCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::setLmPool(inner) => {
                            <setLmPoolCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::setLmPoolDeployer(inner) => {
                            <setLmPoolDeployerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::setOwner(inner) => {
                            <setOwnerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::setWhiteListAddress(inner) => {
                            <setWhiteListAddressCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                    }
                }
                #[inline]
                fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                    match self {
                        Self::collectProtocol(inner) => {
                            <collectProtocolCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::createPool(inner) => {
                            <createPoolCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::enableFeeAmount(inner) => {
                            <enableFeeAmountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::feeAmountTickSpacing(inner) => {
                            <feeAmountTickSpacingCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::feeAmountTickSpacingExtraInfo(inner) => {
                            <feeAmountTickSpacingExtraInfoCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::getPool(inner) => {
                            <getPoolCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::lmPoolDeployer(inner) => {
                            <lmPoolDeployerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::owner(inner) => {
                            <ownerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::poolDeployer(inner) => {
                            <poolDeployerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::setFeeAmountExtraInfo(inner) => {
                            <setFeeAmountExtraInfoCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::setFeeProtocol(inner) => {
                            <setFeeProtocolCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::setLmPool(inner) => {
                            <setLmPoolCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::setLmPoolDeployer(inner) => {
                            <setLmPoolDeployerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::setOwner(inner) => {
                            <setOwnerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::setWhiteListAddress(inner) => {
                            <setWhiteListAddressCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                    }
                }
            }
            ///Container for all the [`PancakeSwapV3Factory`](self) events.
            pub enum PancakeSwapV3FactoryEvents {
                FeeAmountEnabled(FeeAmountEnabled),
                FeeAmountExtraInfoUpdated(FeeAmountExtraInfoUpdated),
                OwnerChanged(OwnerChanged),
                PoolCreated(PoolCreated),
                SetLmPoolDeployer(SetLmPoolDeployer),
                WhiteListAdded(WhiteListAdded),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for PancakeSwapV3FactoryEvents {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        PancakeSwapV3FactoryEvents::FeeAmountEnabled(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "FeeAmountEnabled",
                                &__self_0,
                            )
                        }
                        PancakeSwapV3FactoryEvents::FeeAmountExtraInfoUpdated(
                            __self_0,
                        ) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "FeeAmountExtraInfoUpdated",
                                &__self_0,
                            )
                        }
                        PancakeSwapV3FactoryEvents::OwnerChanged(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "OwnerChanged",
                                &__self_0,
                            )
                        }
                        PancakeSwapV3FactoryEvents::PoolCreated(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "PoolCreated",
                                &__self_0,
                            )
                        }
                        PancakeSwapV3FactoryEvents::SetLmPoolDeployer(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "SetLmPoolDeployer",
                                &__self_0,
                            )
                        }
                        PancakeSwapV3FactoryEvents::WhiteListAdded(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "WhiteListAdded",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl PancakeSwapV3FactoryEvents {
                /// All the selectors of this enum.
                ///
                /// Note that the selectors might not be in the same order as the variants.
                /// No guarantees are made about the order of the selectors.
                ///
                /// Prefer using `SolInterface` methods instead.
                pub const SELECTORS: &'static [[u8; 32usize]] = &[
                    [
                        76u8,
                        145u8,
                        34u8,
                        128u8,
                        205u8,
                        164u8,
                        123u8,
                        237u8,
                        50u8,
                        77u8,
                        225u8,
                        79u8,
                        96u8,
                        29u8,
                        63u8,
                        18u8,
                        90u8,
                        152u8,
                        37u8,
                        70u8,
                        113u8,
                        119u8,
                        47u8,
                        63u8,
                        31u8,
                        73u8,
                        30u8,
                        80u8,
                        250u8,
                        12u8,
                        164u8,
                        7u8,
                    ],
                    [
                        120u8,
                        60u8,
                        202u8,
                        28u8,
                        4u8,
                        18u8,
                        221u8,
                        13u8,
                        105u8,
                        94u8,
                        120u8,
                        69u8,
                        104u8,
                        201u8,
                        109u8,
                        162u8,
                        233u8,
                        194u8,
                        47u8,
                        249u8,
                        137u8,
                        53u8,
                        122u8,
                        46u8,
                        139u8,
                        29u8,
                        155u8,
                        43u8,
                        78u8,
                        107u8,
                        113u8,
                        24u8,
                    ],
                    [
                        174u8,
                        196u8,
                        42u8,
                        199u8,
                        241u8,
                        187u8,
                        134u8,
                        81u8,
                        144u8,
                        106u8,
                        230u8,
                        82u8,
                        47u8,
                        80u8,
                        161u8,
                        148u8,
                        41u8,
                        225u8,
                        36u8,
                        232u8,
                        234u8,
                        103u8,
                        142u8,
                        245u8,
                        159u8,
                        210u8,
                        119u8,
                        80u8,
                        117u8,
                        146u8,
                        136u8,
                        162u8,
                    ],
                    [
                        181u8,
                        50u8,
                        7u8,
                        59u8,
                        56u8,
                        200u8,
                        49u8,
                        69u8,
                        227u8,
                        229u8,
                        19u8,
                        83u8,
                        119u8,
                        160u8,
                        139u8,
                        249u8,
                        170u8,
                        181u8,
                        91u8,
                        192u8,
                        253u8,
                        124u8,
                        17u8,
                        121u8,
                        205u8,
                        79u8,
                        185u8,
                        149u8,
                        210u8,
                        165u8,
                        21u8,
                        156u8,
                    ],
                    [
                        198u8,
                        106u8,
                        63u8,
                        223u8,
                        7u8,
                        35u8,
                        44u8,
                        221u8,
                        24u8,
                        95u8,
                        235u8,
                        204u8,
                        101u8,
                        121u8,
                        212u8,
                        8u8,
                        194u8,
                        65u8,
                        180u8,
                        122u8,
                        226u8,
                        249u8,
                        144u8,
                        125u8,
                        132u8,
                        190u8,
                        101u8,
                        81u8,
                        65u8,
                        238u8,
                        174u8,
                        204u8,
                    ],
                    [
                        237u8,
                        133u8,
                        182u8,
                        22u8,
                        219u8,
                        251u8,
                        197u8,
                        77u8,
                        15u8,
                        17u8,
                        128u8,
                        167u8,
                        189u8,
                        15u8,
                        110u8,
                        59u8,
                        182u8,
                        69u8,
                        178u8,
                        105u8,
                        178u8,
                        52u8,
                        231u8,
                        169u8,
                        237u8,
                        204u8,
                        38u8,
                        158u8,
                        241u8,
                        68u8,
                        61u8,
                        136u8,
                    ],
                ];
            }
            #[automatically_derived]
            impl alloy_sol_types::SolEventInterface for PancakeSwapV3FactoryEvents {
                const NAME: &'static str = "PancakeSwapV3FactoryEvents";
                const COUNT: usize = 6usize;
                fn decode_raw_log(
                    topics: &[alloy_sol_types::Word],
                    data: &[u8],
                    validate: bool,
                ) -> alloy_sol_types::Result<Self> {
                    match topics.first().copied() {
                        Some(
                            <FeeAmountEnabled as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                        ) => {
                            <FeeAmountEnabled as alloy_sol_types::SolEvent>::decode_raw_log(
                                    topics,
                                    data,
                                    validate,
                                )
                                .map(Self::FeeAmountEnabled)
                        }
                        Some(
                            <FeeAmountExtraInfoUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                        ) => {
                            <FeeAmountExtraInfoUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                                    topics,
                                    data,
                                    validate,
                                )
                                .map(Self::FeeAmountExtraInfoUpdated)
                        }
                        Some(
                            <OwnerChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                        ) => {
                            <OwnerChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                                    topics,
                                    data,
                                    validate,
                                )
                                .map(Self::OwnerChanged)
                        }
                        Some(
                            <PoolCreated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                        ) => {
                            <PoolCreated as alloy_sol_types::SolEvent>::decode_raw_log(
                                    topics,
                                    data,
                                    validate,
                                )
                                .map(Self::PoolCreated)
                        }
                        Some(
                            <SetLmPoolDeployer as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                        ) => {
                            <SetLmPoolDeployer as alloy_sol_types::SolEvent>::decode_raw_log(
                                    topics,
                                    data,
                                    validate,
                                )
                                .map(Self::SetLmPoolDeployer)
                        }
                        Some(
                            <WhiteListAdded as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                        ) => {
                            <WhiteListAdded as alloy_sol_types::SolEvent>::decode_raw_log(
                                    topics,
                                    data,
                                    validate,
                                )
                                .map(Self::WhiteListAdded)
                        }
                        _ => {
                            alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                                name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                                log: alloy_sol_types::private::Box::new(
                                    alloy_sol_types::private::LogData::new_unchecked(
                                        topics.to_vec(),
                                        data.to_vec().into(),
                                    ),
                                ),
                            })
                        }
                    }
                }
            }
            #[automatically_derived]
            impl alloy_sol_types::private::IntoLogData for PancakeSwapV3FactoryEvents {
                fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                    match self {
                        Self::FeeAmountEnabled(inner) => {
                            alloy_sol_types::private::IntoLogData::to_log_data(inner)
                        }
                        Self::FeeAmountExtraInfoUpdated(inner) => {
                            alloy_sol_types::private::IntoLogData::to_log_data(inner)
                        }
                        Self::OwnerChanged(inner) => {
                            alloy_sol_types::private::IntoLogData::to_log_data(inner)
                        }
                        Self::PoolCreated(inner) => {
                            alloy_sol_types::private::IntoLogData::to_log_data(inner)
                        }
                        Self::SetLmPoolDeployer(inner) => {
                            alloy_sol_types::private::IntoLogData::to_log_data(inner)
                        }
                        Self::WhiteListAdded(inner) => {
                            alloy_sol_types::private::IntoLogData::to_log_data(inner)
                        }
                    }
                }
                fn into_log_data(self) -> alloy_sol_types::private::LogData {
                    match self {
                        Self::FeeAmountEnabled(inner) => {
                            alloy_sol_types::private::IntoLogData::into_log_data(inner)
                        }
                        Self::FeeAmountExtraInfoUpdated(inner) => {
                            alloy_sol_types::private::IntoLogData::into_log_data(inner)
                        }
                        Self::OwnerChanged(inner) => {
                            alloy_sol_types::private::IntoLogData::into_log_data(inner)
                        }
                        Self::PoolCreated(inner) => {
                            alloy_sol_types::private::IntoLogData::into_log_data(inner)
                        }
                        Self::SetLmPoolDeployer(inner) => {
                            alloy_sol_types::private::IntoLogData::into_log_data(inner)
                        }
                        Self::WhiteListAdded(inner) => {
                            alloy_sol_types::private::IntoLogData::into_log_data(inner)
                        }
                    }
                }
            }
            use ::alloy::contract as alloy_contract;
            /**Creates a new wrapper around an on-chain [`PancakeSwapV3Factory`](self) contract instance.

See the [wrapper's documentation](`PancakeSwapV3FactoryInstance`) for more details.*/
            #[inline]
            pub const fn new<
                T: alloy_contract::private::Transport + ::core::clone::Clone,
                P: alloy_contract::private::Provider<T, N>,
                N: alloy_contract::private::Network,
            >(
                address: alloy_sol_types::private::Address,
                provider: P,
            ) -> PancakeSwapV3FactoryInstance<T, P, N> {
                PancakeSwapV3FactoryInstance::<T, P, N>::new(address, provider)
            }
            /**A [`PancakeSwapV3Factory`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`PancakeSwapV3Factory`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
            pub struct PancakeSwapV3FactoryInstance<
                T,
                P,
                N = alloy_contract::private::Ethereum,
            > {
                address: alloy_sol_types::private::Address,
                provider: P,
                _network_transport: ::core::marker::PhantomData<(N, T)>,
            }
            #[automatically_derived]
            impl<
                T: ::core::clone::Clone,
                P: ::core::clone::Clone,
                N: ::core::clone::Clone,
            > ::core::clone::Clone for PancakeSwapV3FactoryInstance<T, P, N> {
                #[inline]
                fn clone(&self) -> PancakeSwapV3FactoryInstance<T, P, N> {
                    PancakeSwapV3FactoryInstance {
                        address: ::core::clone::Clone::clone(&self.address),
                        provider: ::core::clone::Clone::clone(&self.provider),
                        _network_transport: ::core::clone::Clone::clone(
                            &self._network_transport,
                        ),
                    }
                }
            }
            #[automatically_derived]
            impl<T, P, N> ::core::fmt::Debug for PancakeSwapV3FactoryInstance<T, P, N> {
                #[inline]
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_tuple("PancakeSwapV3FactoryInstance")
                        .field(&self.address)
                        .finish()
                }
            }
            /// Instantiation and getters/setters.
            #[automatically_derived]
            impl<
                T: alloy_contract::private::Transport + ::core::clone::Clone,
                P: alloy_contract::private::Provider<T, N>,
                N: alloy_contract::private::Network,
            > PancakeSwapV3FactoryInstance<T, P, N> {
                /**Creates a new wrapper around an on-chain [`PancakeSwapV3Factory`](self) contract instance.

See the [wrapper's documentation](`PancakeSwapV3FactoryInstance`) for more details.*/
                #[inline]
                pub const fn new(
                    address: alloy_sol_types::private::Address,
                    provider: P,
                ) -> Self {
                    Self {
                        address,
                        provider,
                        _network_transport: ::core::marker::PhantomData,
                    }
                }
                /// Returns a reference to the address.
                #[inline]
                pub const fn address(&self) -> &alloy_sol_types::private::Address {
                    &self.address
                }
                /// Sets the address.
                #[inline]
                pub fn set_address(
                    &mut self,
                    address: alloy_sol_types::private::Address,
                ) {
                    self.address = address;
                }
                /// Sets the address and returns `self`.
                pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
                    self.set_address(address);
                    self
                }
                /// Returns a reference to the provider.
                #[inline]
                pub const fn provider(&self) -> &P {
                    &self.provider
                }
            }
            impl<T, P: ::core::clone::Clone, N> PancakeSwapV3FactoryInstance<T, &P, N> {
                /// Clones the provider and returns a new instance with the cloned provider.
                #[inline]
                pub fn with_cloned_provider(
                    self,
                ) -> PancakeSwapV3FactoryInstance<T, P, N> {
                    PancakeSwapV3FactoryInstance {
                        address: self.address,
                        provider: ::core::clone::Clone::clone(&self.provider),
                        _network_transport: ::core::marker::PhantomData,
                    }
                }
            }
            /// Function calls.
            #[automatically_derived]
            impl<
                T: alloy_contract::private::Transport + ::core::clone::Clone,
                P: alloy_contract::private::Provider<T, N>,
                N: alloy_contract::private::Network,
            > PancakeSwapV3FactoryInstance<T, P, N> {
                /// Creates a new call builder using this contract instance's provider and address.
                ///
                /// Note that the call can be any function call, not just those defined in this
                /// contract. Prefer using the other methods for building type-safe contract calls.
                pub fn call_builder<C: alloy_sol_types::SolCall>(
                    &self,
                    call: &C,
                ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
                    alloy_contract::SolCallBuilder::new_sol(
                        &self.provider,
                        &self.address,
                        call,
                    )
                }
                ///Creates a new call builder for the [`collectProtocol`] function.
                pub fn collectProtocol(
                    &self,
                    pool: ::alloy::sol_types::private::Address,
                    recipient: ::alloy::sol_types::private::Address,
                    amount0Requested: u128,
                    amount1Requested: u128,
                ) -> alloy_contract::SolCallBuilder<T, &P, collectProtocolCall, N> {
                    self.call_builder(
                        &collectProtocolCall {
                            pool,
                            recipient,
                            amount0Requested,
                            amount1Requested,
                        },
                    )
                }
                ///Creates a new call builder for the [`createPool`] function.
                pub fn createPool(
                    &self,
                    tokenA: ::alloy::sol_types::private::Address,
                    tokenB: ::alloy::sol_types::private::Address,
                    fee: <::alloy::sol_types::sol_data::Uint<
                        24,
                    > as ::alloy::sol_types::SolType>::RustType,
                ) -> alloy_contract::SolCallBuilder<T, &P, createPoolCall, N> {
                    self.call_builder(
                        &createPoolCall {
                            tokenA,
                            tokenB,
                            fee,
                        },
                    )
                }
                ///Creates a new call builder for the [`enableFeeAmount`] function.
                pub fn enableFeeAmount(
                    &self,
                    fee: <::alloy::sol_types::sol_data::Uint<
                        24,
                    > as ::alloy::sol_types::SolType>::RustType,
                    tickSpacing: <::alloy::sol_types::sol_data::Int<
                        24,
                    > as ::alloy::sol_types::SolType>::RustType,
                ) -> alloy_contract::SolCallBuilder<T, &P, enableFeeAmountCall, N> {
                    self.call_builder(
                        &enableFeeAmountCall {
                            fee,
                            tickSpacing,
                        },
                    )
                }
                ///Creates a new call builder for the [`feeAmountTickSpacing`] function.
                pub fn feeAmountTickSpacing(
                    &self,
                    _0: <::alloy::sol_types::sol_data::Uint<
                        24,
                    > as ::alloy::sol_types::SolType>::RustType,
                ) -> alloy_contract::SolCallBuilder<T, &P, feeAmountTickSpacingCall, N> {
                    self.call_builder(&feeAmountTickSpacingCall { _0 })
                }
                ///Creates a new call builder for the [`feeAmountTickSpacingExtraInfo`] function.
                pub fn feeAmountTickSpacingExtraInfo(
                    &self,
                    _0: <::alloy::sol_types::sol_data::Uint<
                        24,
                    > as ::alloy::sol_types::SolType>::RustType,
                ) -> alloy_contract::SolCallBuilder<
                    T,
                    &P,
                    feeAmountTickSpacingExtraInfoCall,
                    N,
                > {
                    self.call_builder(
                        &feeAmountTickSpacingExtraInfoCall {
                            _0,
                        },
                    )
                }
                ///Creates a new call builder for the [`getPool`] function.
                pub fn getPool(
                    &self,
                    _0: ::alloy::sol_types::private::Address,
                    _1: ::alloy::sol_types::private::Address,
                    _2: <::alloy::sol_types::sol_data::Uint<
                        24,
                    > as ::alloy::sol_types::SolType>::RustType,
                ) -> alloy_contract::SolCallBuilder<T, &P, getPoolCall, N> {
                    self.call_builder(&getPoolCall { _0, _1, _2 })
                }
                ///Creates a new call builder for the [`lmPoolDeployer`] function.
                pub fn lmPoolDeployer(
                    &self,
                ) -> alloy_contract::SolCallBuilder<T, &P, lmPoolDeployerCall, N> {
                    self.call_builder(&lmPoolDeployerCall {})
                }
                ///Creates a new call builder for the [`owner`] function.
                pub fn owner(
                    &self,
                ) -> alloy_contract::SolCallBuilder<T, &P, ownerCall, N> {
                    self.call_builder(&ownerCall {})
                }
                ///Creates a new call builder for the [`poolDeployer`] function.
                pub fn poolDeployer(
                    &self,
                ) -> alloy_contract::SolCallBuilder<T, &P, poolDeployerCall, N> {
                    self.call_builder(&poolDeployerCall {})
                }
                ///Creates a new call builder for the [`setFeeAmountExtraInfo`] function.
                pub fn setFeeAmountExtraInfo(
                    &self,
                    fee: <::alloy::sol_types::sol_data::Uint<
                        24,
                    > as ::alloy::sol_types::SolType>::RustType,
                    whitelistRequested: bool,
                    enabled: bool,
                ) -> alloy_contract::SolCallBuilder<
                    T,
                    &P,
                    setFeeAmountExtraInfoCall,
                    N,
                > {
                    self.call_builder(
                        &setFeeAmountExtraInfoCall {
                            fee,
                            whitelistRequested,
                            enabled,
                        },
                    )
                }
                ///Creates a new call builder for the [`setFeeProtocol`] function.
                pub fn setFeeProtocol(
                    &self,
                    pool: ::alloy::sol_types::private::Address,
                    feeProtocol0: u32,
                    feeProtocol1: u32,
                ) -> alloy_contract::SolCallBuilder<T, &P, setFeeProtocolCall, N> {
                    self.call_builder(
                        &setFeeProtocolCall {
                            pool,
                            feeProtocol0,
                            feeProtocol1,
                        },
                    )
                }
                ///Creates a new call builder for the [`setLmPool`] function.
                pub fn setLmPool(
                    &self,
                    pool: ::alloy::sol_types::private::Address,
                    lmPool: ::alloy::sol_types::private::Address,
                ) -> alloy_contract::SolCallBuilder<T, &P, setLmPoolCall, N> {
                    self.call_builder(&setLmPoolCall { pool, lmPool })
                }
                ///Creates a new call builder for the [`setLmPoolDeployer`] function.
                pub fn setLmPoolDeployer(
                    &self,
                    _lmPoolDeployer: ::alloy::sol_types::private::Address,
                ) -> alloy_contract::SolCallBuilder<T, &P, setLmPoolDeployerCall, N> {
                    self.call_builder(
                        &setLmPoolDeployerCall {
                            _lmPoolDeployer,
                        },
                    )
                }
                ///Creates a new call builder for the [`setOwner`] function.
                pub fn setOwner(
                    &self,
                    _owner: ::alloy::sol_types::private::Address,
                ) -> alloy_contract::SolCallBuilder<T, &P, setOwnerCall, N> {
                    self.call_builder(&setOwnerCall { _owner })
                }
                ///Creates a new call builder for the [`setWhiteListAddress`] function.
                pub fn setWhiteListAddress(
                    &self,
                    user: ::alloy::sol_types::private::Address,
                    verified: bool,
                ) -> alloy_contract::SolCallBuilder<T, &P, setWhiteListAddressCall, N> {
                    self.call_builder(
                        &setWhiteListAddressCall {
                            user,
                            verified,
                        },
                    )
                }
            }
            /// Event filters.
            #[automatically_derived]
            impl<
                T: alloy_contract::private::Transport + ::core::clone::Clone,
                P: alloy_contract::private::Provider<T, N>,
                N: alloy_contract::private::Network,
            > PancakeSwapV3FactoryInstance<T, P, N> {
                /// Creates a new event filter using this contract instance's provider and address.
                ///
                /// Note that the type can be any event, not just those defined in this contract.
                /// Prefer using the other methods for building type-safe event filters.
                pub fn event_filter<E: alloy_sol_types::SolEvent>(
                    &self,
                ) -> alloy_contract::Event<T, &P, E, N> {
                    alloy_contract::Event::new_sol(&self.provider, &self.address)
                }
                ///Creates a new event filter for the [`FeeAmountEnabled`] event.
                pub fn FeeAmountEnabled_filter(
                    &self,
                ) -> alloy_contract::Event<T, &P, FeeAmountEnabled, N> {
                    self.event_filter::<FeeAmountEnabled>()
                }
                ///Creates a new event filter for the [`FeeAmountExtraInfoUpdated`] event.
                pub fn FeeAmountExtraInfoUpdated_filter(
                    &self,
                ) -> alloy_contract::Event<T, &P, FeeAmountExtraInfoUpdated, N> {
                    self.event_filter::<FeeAmountExtraInfoUpdated>()
                }
                ///Creates a new event filter for the [`OwnerChanged`] event.
                pub fn OwnerChanged_filter(
                    &self,
                ) -> alloy_contract::Event<T, &P, OwnerChanged, N> {
                    self.event_filter::<OwnerChanged>()
                }
                ///Creates a new event filter for the [`PoolCreated`] event.
                pub fn PoolCreated_filter(
                    &self,
                ) -> alloy_contract::Event<T, &P, PoolCreated, N> {
                    self.event_filter::<PoolCreated>()
                }
                ///Creates a new event filter for the [`SetLmPoolDeployer`] event.
                pub fn SetLmPoolDeployer_filter(
                    &self,
                ) -> alloy_contract::Event<T, &P, SetLmPoolDeployer, N> {
                    self.event_filter::<SetLmPoolDeployer>()
                }
                ///Creates a new event filter for the [`WhiteListAdded`] event.
                pub fn WhiteListAdded_filter(
                    &self,
                ) -> alloy_contract::Event<T, &P, WhiteListAdded, N> {
                    self.event_filter::<WhiteListAdded>()
                }
            }
        }
        const _: &'static [u8] = b"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_implementation\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"FeeInvalid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FeeTooHigh\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPool\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotFeeManager\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotPauser\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotVoter\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PoolAlreadyExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SameAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroFee\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"stable\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"PoolCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"SetCustomFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feeManager\",\"type\":\"address\"}],\"name\":\"SetFeeManager\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"SetPauseState\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pauser\",\"type\":\"address\"}],\"name\":\"SetPauser\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"SetVoter\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ZERO_FEE_INDICATOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allPools\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allPoolsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"stable\",\"type\":\"bool\"}],\"name\":\"createPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"}],\"name\":\"createPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"customFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_stable\",\"type\":\"bool\"}],\"name\":\"getFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"}],\"name\":\"getPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"stable\",\"type\":\"bool\"}],\"name\":\"getPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"isPool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauser\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setCustomFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_stable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeManager\",\"type\":\"address\"}],\"name\":\"setFeeManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_state\",\"type\":\"bool\"}],\"name\":\"setPauseState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pauser\",\"type\":\"address\"}],\"name\":\"setPauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_voter\",\"type\":\"address\"}],\"name\":\"setVoter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stableFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"volatileFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"voter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]";
        /**

Generated by the following Solidity interface...
```solidity
interface AerodomeV2Factory {
    error FeeInvalid();
    error FeeTooHigh();
    error InvalidPool();
    error NotFeeManager();
    error NotPauser();
    error NotVoter();
    error PoolAlreadyExists();
    error SameAddress();
    error ZeroAddress();
    error ZeroFee();

    event PoolCreated(address indexed token0, address indexed token1, bool indexed stable, address pool, uint256);
    event SetCustomFee(address indexed pool, uint256 fee);
    event SetFeeManager(address feeManager);
    event SetPauseState(bool state);
    event SetPauser(address pauser);
    event SetVoter(address voter);

    constructor(address _implementation);

    function MAX_FEE() external view returns (uint256);
    function ZERO_FEE_INDICATOR() external view returns (uint256);
    function allPools(uint256) external view returns (address);
    function allPoolsLength() external view returns (uint256);
    function createPool(address tokenA, address tokenB, bool stable) external returns (address pool);
    function createPool(address tokenA, address tokenB, uint24 fee) external returns (address pool);
    function customFee(address) external view returns (uint256);
    function feeManager() external view returns (address);
    function getFee(address pool, bool _stable) external view returns (uint256);
    function getPool(address tokenA, address tokenB, uint24 fee) external view returns (address);
    function getPool(address tokenA, address tokenB, bool stable) external view returns (address);
    function implementation() external view returns (address);
    function isPaused() external view returns (bool);
    function isPool(address pool) external view returns (bool);
    function pauser() external view returns (address);
    function setCustomFee(address pool, uint256 fee) external;
    function setFee(bool _stable, uint256 _fee) external;
    function setFeeManager(address _feeManager) external;
    function setPauseState(bool _state) external;
    function setPauser(address _pauser) external;
    function setVoter(address _voter) external;
    function stableFee() external view returns (uint256);
    function volatileFee() external view returns (uint256);
    function voter() external view returns (address);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "_implementation",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "MAX_FEE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "ZERO_FEE_INDICATOR",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "allPools",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "allPoolsLength",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "createPool",
    "inputs": [
      {
        "name": "tokenA",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "tokenB",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "stable",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [
      {
        "name": "pool",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "createPool",
    "inputs": [
      {
        "name": "tokenA",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "tokenB",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "fee",
        "type": "uint24",
        "internalType": "uint24"
      }
    ],
    "outputs": [
      {
        "name": "pool",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "customFee",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "feeManager",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getFee",
    "inputs": [
      {
        "name": "pool",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_stable",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getPool",
    "inputs": [
      {
        "name": "tokenA",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "tokenB",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "fee",
        "type": "uint24",
        "internalType": "uint24"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getPool",
    "inputs": [
      {
        "name": "tokenA",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "tokenB",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "stable",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "implementation",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isPaused",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isPool",
    "inputs": [
      {
        "name": "pool",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "pauser",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "setCustomFee",
    "inputs": [
      {
        "name": "pool",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "fee",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setFee",
    "inputs": [
      {
        "name": "_stable",
        "type": "bool",
        "internalType": "bool"
      },
      {
        "name": "_fee",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setFeeManager",
    "inputs": [
      {
        "name": "_feeManager",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setPauseState",
    "inputs": [
      {
        "name": "_state",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setPauser",
    "inputs": [
      {
        "name": "_pauser",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setVoter",
    "inputs": [
      {
        "name": "_voter",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "stableFee",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "volatileFee",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "voter",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "event",
    "name": "PoolCreated",
    "inputs": [
      {
        "name": "token0",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "token1",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "stable",
        "type": "bool",
        "indexed": true,
        "internalType": "bool"
      },
      {
        "name": "pool",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "SetCustomFee",
    "inputs": [
      {
        "name": "pool",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "fee",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "SetFeeManager",
    "inputs": [
      {
        "name": "feeManager",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "SetPauseState",
    "inputs": [
      {
        "name": "state",
        "type": "bool",
        "indexed": false,
        "internalType": "bool"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "SetPauser",
    "inputs": [
      {
        "name": "pauser",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "SetVoter",
    "inputs": [
      {
        "name": "voter",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "FeeInvalid",
    "inputs": []
  },
  {
    "type": "error",
    "name": "FeeTooHigh",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidPool",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotFeeManager",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotPauser",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotVoter",
    "inputs": []
  },
  {
    "type": "error",
    "name": "PoolAlreadyExists",
    "inputs": []
  },
  {
    "type": "error",
    "name": "SameAddress",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ZeroAddress",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ZeroFee",
    "inputs": []
  }
]
```*/
        #[allow(non_camel_case_types, non_snake_case, clippy::style)]
        pub mod AerodomeV2Factory {
            use super::*;
            use ::alloy::sol_types as alloy_sol_types;
            /**Custom error with signature `FeeInvalid()` and selector `0x52dadcf9`.
```solidity
error FeeInvalid();
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct FeeInvalid {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for FeeInvalid {
                #[inline]
                fn clone(&self) -> FeeInvalid {
                    FeeInvalid {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for FeeInvalid {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "FeeInvalid")
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                #[doc(hidden)]
                type UnderlyingSolTuple<'a> = ();
                #[doc(hidden)]
                type UnderlyingRustTuple<'a> = ();
                #[automatically_derived]
                #[doc(hidden)]
                impl ::core::convert::From<FeeInvalid> for UnderlyingRustTuple<'_> {
                    fn from(value: FeeInvalid) -> Self {
                        ()
                    }
                }
                #[automatically_derived]
                #[doc(hidden)]
                impl ::core::convert::From<UnderlyingRustTuple<'_>> for FeeInvalid {
                    fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                        Self {}
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolError for FeeInvalid {
                    type Parameters<'a> = UnderlyingSolTuple<'a>;
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "FeeInvalid()";
                    const SELECTOR: [u8; 4] = [82u8, 218u8, 220u8, 249u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                }
            };
            /**Custom error with signature `FeeTooHigh()` and selector `0xcd4e6167`.
```solidity
error FeeTooHigh();
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct FeeTooHigh {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for FeeTooHigh {
                #[inline]
                fn clone(&self) -> FeeTooHigh {
                    FeeTooHigh {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for FeeTooHigh {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "FeeTooHigh")
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                #[doc(hidden)]
                type UnderlyingSolTuple<'a> = ();
                #[doc(hidden)]
                type UnderlyingRustTuple<'a> = ();
                #[automatically_derived]
                #[doc(hidden)]
                impl ::core::convert::From<FeeTooHigh> for UnderlyingRustTuple<'_> {
                    fn from(value: FeeTooHigh) -> Self {
                        ()
                    }
                }
                #[automatically_derived]
                #[doc(hidden)]
                impl ::core::convert::From<UnderlyingRustTuple<'_>> for FeeTooHigh {
                    fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                        Self {}
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolError for FeeTooHigh {
                    type Parameters<'a> = UnderlyingSolTuple<'a>;
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "FeeTooHigh()";
                    const SELECTOR: [u8; 4] = [205u8, 78u8, 97u8, 103u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                }
            };
            /**Custom error with signature `InvalidPool()` and selector `0x2083cd40`.
```solidity
error InvalidPool();
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct InvalidPool {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for InvalidPool {
                #[inline]
                fn clone(&self) -> InvalidPool {
                    InvalidPool {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for InvalidPool {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "InvalidPool")
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                #[doc(hidden)]
                type UnderlyingSolTuple<'a> = ();
                #[doc(hidden)]
                type UnderlyingRustTuple<'a> = ();
                #[automatically_derived]
                #[doc(hidden)]
                impl ::core::convert::From<InvalidPool> for UnderlyingRustTuple<'_> {
                    fn from(value: InvalidPool) -> Self {
                        ()
                    }
                }
                #[automatically_derived]
                #[doc(hidden)]
                impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidPool {
                    fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                        Self {}
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolError for InvalidPool {
                    type Parameters<'a> = UnderlyingSolTuple<'a>;
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "InvalidPool()";
                    const SELECTOR: [u8; 4] = [32u8, 131u8, 205u8, 64u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                }
            };
            /**Custom error with signature `NotFeeManager()` and selector `0xf5d267eb`.
```solidity
error NotFeeManager();
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct NotFeeManager {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for NotFeeManager {
                #[inline]
                fn clone(&self) -> NotFeeManager {
                    NotFeeManager {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for NotFeeManager {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "NotFeeManager")
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                #[doc(hidden)]
                type UnderlyingSolTuple<'a> = ();
                #[doc(hidden)]
                type UnderlyingRustTuple<'a> = ();
                #[automatically_derived]
                #[doc(hidden)]
                impl ::core::convert::From<NotFeeManager> for UnderlyingRustTuple<'_> {
                    fn from(value: NotFeeManager) -> Self {
                        ()
                    }
                }
                #[automatically_derived]
                #[doc(hidden)]
                impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotFeeManager {
                    fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                        Self {}
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolError for NotFeeManager {
                    type Parameters<'a> = UnderlyingSolTuple<'a>;
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "NotFeeManager()";
                    const SELECTOR: [u8; 4] = [245u8, 210u8, 103u8, 235u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                }
            };
            /**Custom error with signature `NotPauser()` and selector `0x492f6781`.
```solidity
error NotPauser();
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct NotPauser {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for NotPauser {
                #[inline]
                fn clone(&self) -> NotPauser {
                    NotPauser {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for NotPauser {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "NotPauser")
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                #[doc(hidden)]
                type UnderlyingSolTuple<'a> = ();
                #[doc(hidden)]
                type UnderlyingRustTuple<'a> = ();
                #[automatically_derived]
                #[doc(hidden)]
                impl ::core::convert::From<NotPauser> for UnderlyingRustTuple<'_> {
                    fn from(value: NotPauser) -> Self {
                        ()
                    }
                }
                #[automatically_derived]
                #[doc(hidden)]
                impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotPauser {
                    fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                        Self {}
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolError for NotPauser {
                    type Parameters<'a> = UnderlyingSolTuple<'a>;
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "NotPauser()";
                    const SELECTOR: [u8; 4] = [73u8, 47u8, 103u8, 129u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                }
            };
            /**Custom error with signature `NotVoter()` and selector `0xc18384c1`.
```solidity
error NotVoter();
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct NotVoter {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for NotVoter {
                #[inline]
                fn clone(&self) -> NotVoter {
                    NotVoter {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for NotVoter {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "NotVoter")
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                #[doc(hidden)]
                type UnderlyingSolTuple<'a> = ();
                #[doc(hidden)]
                type UnderlyingRustTuple<'a> = ();
                #[automatically_derived]
                #[doc(hidden)]
                impl ::core::convert::From<NotVoter> for UnderlyingRustTuple<'_> {
                    fn from(value: NotVoter) -> Self {
                        ()
                    }
                }
                #[automatically_derived]
                #[doc(hidden)]
                impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotVoter {
                    fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                        Self {}
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolError for NotVoter {
                    type Parameters<'a> = UnderlyingSolTuple<'a>;
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "NotVoter()";
                    const SELECTOR: [u8; 4] = [193u8, 131u8, 132u8, 193u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                }
            };
            /**Custom error with signature `PoolAlreadyExists()` and selector `0x03119322`.
```solidity
error PoolAlreadyExists();
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct PoolAlreadyExists {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for PoolAlreadyExists {
                #[inline]
                fn clone(&self) -> PoolAlreadyExists {
                    PoolAlreadyExists {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for PoolAlreadyExists {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "PoolAlreadyExists")
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                #[doc(hidden)]
                type UnderlyingSolTuple<'a> = ();
                #[doc(hidden)]
                type UnderlyingRustTuple<'a> = ();
                #[automatically_derived]
                #[doc(hidden)]
                impl ::core::convert::From<PoolAlreadyExists>
                for UnderlyingRustTuple<'_> {
                    fn from(value: PoolAlreadyExists) -> Self {
                        ()
                    }
                }
                #[automatically_derived]
                #[doc(hidden)]
                impl ::core::convert::From<UnderlyingRustTuple<'_>>
                for PoolAlreadyExists {
                    fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                        Self {}
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolError for PoolAlreadyExists {
                    type Parameters<'a> = UnderlyingSolTuple<'a>;
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "PoolAlreadyExists()";
                    const SELECTOR: [u8; 4] = [3u8, 17u8, 147u8, 34u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                }
            };
            /**Custom error with signature `SameAddress()` and selector `0x367558c3`.
```solidity
error SameAddress();
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct SameAddress {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for SameAddress {
                #[inline]
                fn clone(&self) -> SameAddress {
                    SameAddress {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for SameAddress {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "SameAddress")
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                #[doc(hidden)]
                type UnderlyingSolTuple<'a> = ();
                #[doc(hidden)]
                type UnderlyingRustTuple<'a> = ();
                #[automatically_derived]
                #[doc(hidden)]
                impl ::core::convert::From<SameAddress> for UnderlyingRustTuple<'_> {
                    fn from(value: SameAddress) -> Self {
                        ()
                    }
                }
                #[automatically_derived]
                #[doc(hidden)]
                impl ::core::convert::From<UnderlyingRustTuple<'_>> for SameAddress {
                    fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                        Self {}
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolError for SameAddress {
                    type Parameters<'a> = UnderlyingSolTuple<'a>;
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "SameAddress()";
                    const SELECTOR: [u8; 4] = [54u8, 117u8, 88u8, 195u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                }
            };
            /**Custom error with signature `ZeroAddress()` and selector `0xd92e233d`.
```solidity
error ZeroAddress();
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct ZeroAddress {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for ZeroAddress {
                #[inline]
                fn clone(&self) -> ZeroAddress {
                    ZeroAddress {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for ZeroAddress {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "ZeroAddress")
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                #[doc(hidden)]
                type UnderlyingSolTuple<'a> = ();
                #[doc(hidden)]
                type UnderlyingRustTuple<'a> = ();
                #[automatically_derived]
                #[doc(hidden)]
                impl ::core::convert::From<ZeroAddress> for UnderlyingRustTuple<'_> {
                    fn from(value: ZeroAddress) -> Self {
                        ()
                    }
                }
                #[automatically_derived]
                #[doc(hidden)]
                impl ::core::convert::From<UnderlyingRustTuple<'_>> for ZeroAddress {
                    fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                        Self {}
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolError for ZeroAddress {
                    type Parameters<'a> = UnderlyingSolTuple<'a>;
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "ZeroAddress()";
                    const SELECTOR: [u8; 4] = [217u8, 46u8, 35u8, 61u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                }
            };
            /**Custom error with signature `ZeroFee()` and selector `0xaf13986d`.
```solidity
error ZeroFee();
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct ZeroFee {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for ZeroFee {
                #[inline]
                fn clone(&self) -> ZeroFee {
                    ZeroFee {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for ZeroFee {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "ZeroFee")
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                #[doc(hidden)]
                type UnderlyingSolTuple<'a> = ();
                #[doc(hidden)]
                type UnderlyingRustTuple<'a> = ();
                #[automatically_derived]
                #[doc(hidden)]
                impl ::core::convert::From<ZeroFee> for UnderlyingRustTuple<'_> {
                    fn from(value: ZeroFee) -> Self {
                        ()
                    }
                }
                #[automatically_derived]
                #[doc(hidden)]
                impl ::core::convert::From<UnderlyingRustTuple<'_>> for ZeroFee {
                    fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                        Self {}
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolError for ZeroFee {
                    type Parameters<'a> = UnderlyingSolTuple<'a>;
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "ZeroFee()";
                    const SELECTOR: [u8; 4] = [175u8, 19u8, 152u8, 109u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                }
            };
            /**Event with signature `PoolCreated(address,address,bool,address,uint256)` and selector `0x2128d88d14c80cb081c1252a5acff7a264671bf199ce226b53788fb26065005e`.
```solidity
event PoolCreated(address indexed token0, address indexed token1, bool indexed stable, address pool, uint256);
```*/
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            pub struct PoolCreated {
                #[allow(missing_docs)]
                pub token0: ::alloy::sol_types::private::Address,
                #[allow(missing_docs)]
                pub token1: ::alloy::sol_types::private::Address,
                #[allow(missing_docs)]
                pub stable: bool,
                #[allow(missing_docs)]
                pub pool: ::alloy::sol_types::private::Address,
                #[allow(missing_docs)]
                pub _4: ::alloy::sol_types::private::U256,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            impl ::core::clone::Clone for PoolCreated {
                #[inline]
                fn clone(&self) -> PoolCreated {
                    PoolCreated {
                        token0: ::core::clone::Clone::clone(&self.token0),
                        token1: ::core::clone::Clone::clone(&self.token1),
                        stable: ::core::clone::Clone::clone(&self.stable),
                        pool: ::core::clone::Clone::clone(&self.pool),
                        _4: ::core::clone::Clone::clone(&self._4),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            impl ::core::fmt::Debug for PoolCreated {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "PoolCreated",
                        "token0",
                        &self.token0,
                        "token1",
                        &self.token1,
                        "stable",
                        &self.stable,
                        "pool",
                        &self.pool,
                        "_4",
                        &&self._4,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                #[automatically_derived]
                impl alloy_sol_types::SolEvent for PoolCreated {
                    type DataTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Uint<256>,
                    );
                    type DataToken<'a> = <Self::DataTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type TopicList = (
                        alloy_sol_types::sol_data::FixedBytes<32>,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Bool,
                    );
                    const SIGNATURE: &'static str = "PoolCreated(address,address,bool,address,uint256)";
                    const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                        33u8,
                        40u8,
                        216u8,
                        141u8,
                        20u8,
                        200u8,
                        12u8,
                        176u8,
                        129u8,
                        193u8,
                        37u8,
                        42u8,
                        90u8,
                        207u8,
                        247u8,
                        162u8,
                        100u8,
                        103u8,
                        27u8,
                        241u8,
                        153u8,
                        206u8,
                        34u8,
                        107u8,
                        83u8,
                        120u8,
                        143u8,
                        178u8,
                        96u8,
                        101u8,
                        0u8,
                        94u8,
                    ]);
                    const ANONYMOUS: bool = false;
                    #[allow(unused_variables)]
                    #[inline]
                    fn new(
                        topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                        data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        Self {
                            token0: topics.1,
                            token1: topics.2,
                            stable: topics.3,
                            pool: data.0,
                            _4: data.1,
                        }
                    }
                    #[inline]
                    fn tokenize_body(&self) -> Self::DataToken<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self.pool,
                            ),
                            <::alloy::sol_types::sol_data::Uint<
                                256,
                            > as alloy_sol_types::SolType>::tokenize(&self._4),
                        )
                    }
                    #[inline]
                    fn topics(
                        &self,
                    ) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                        (
                            Self::SIGNATURE_HASH.into(),
                            self.token0.clone(),
                            self.token1.clone(),
                            self.stable.clone(),
                        )
                    }
                    #[inline]
                    fn encode_topics_raw(
                        &self,
                        out: &mut [alloy_sol_types::abi::token::WordToken],
                    ) -> alloy_sol_types::Result<()> {
                        if out.len()
                            < <Self::TopicList as alloy_sol_types::TopicList>::COUNT
                        {
                            return Err(alloy_sol_types::Error::Overrun);
                        }
                        out[0usize] = alloy_sol_types::abi::token::WordToken(
                            Self::SIGNATURE_HASH,
                        );
                        out[1usize] = <::alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                            &self.token0,
                        );
                        out[2usize] = <::alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                            &self.token1,
                        );
                        out[3usize] = <::alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::encode_topic(
                            &self.stable,
                        );
                        Ok(())
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::private::IntoLogData for PoolCreated {
                    fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                        From::from(self)
                    }
                    fn into_log_data(self) -> alloy_sol_types::private::LogData {
                        From::from(&self)
                    }
                }
                #[automatically_derived]
                impl From<&PoolCreated> for alloy_sol_types::private::LogData {
                    #[inline]
                    fn from(this: &PoolCreated) -> alloy_sol_types::private::LogData {
                        alloy_sol_types::SolEvent::encode_log_data(this)
                    }
                }
            };
            /**Event with signature `SetCustomFee(address,uint256)` and selector `0xae468ce586f9a87660fdffc1448cee942042c16ae2f02046b134b5224f31936b`.
```solidity
event SetCustomFee(address indexed pool, uint256 fee);
```*/
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            pub struct SetCustomFee {
                #[allow(missing_docs)]
                pub pool: ::alloy::sol_types::private::Address,
                #[allow(missing_docs)]
                pub fee: ::alloy::sol_types::private::U256,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            impl ::core::clone::Clone for SetCustomFee {
                #[inline]
                fn clone(&self) -> SetCustomFee {
                    SetCustomFee {
                        pool: ::core::clone::Clone::clone(&self.pool),
                        fee: ::core::clone::Clone::clone(&self.fee),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            impl ::core::fmt::Debug for SetCustomFee {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "SetCustomFee",
                        "pool",
                        &self.pool,
                        "fee",
                        &&self.fee,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                #[automatically_derived]
                impl alloy_sol_types::SolEvent for SetCustomFee {
                    type DataTuple<'a> = (::alloy::sol_types::sol_data::Uint<256>,);
                    type DataToken<'a> = <Self::DataTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type TopicList = (
                        alloy_sol_types::sol_data::FixedBytes<32>,
                        ::alloy::sol_types::sol_data::Address,
                    );
                    const SIGNATURE: &'static str = "SetCustomFee(address,uint256)";
                    const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                        174u8,
                        70u8,
                        140u8,
                        229u8,
                        134u8,
                        249u8,
                        168u8,
                        118u8,
                        96u8,
                        253u8,
                        255u8,
                        193u8,
                        68u8,
                        140u8,
                        238u8,
                        148u8,
                        32u8,
                        66u8,
                        193u8,
                        106u8,
                        226u8,
                        240u8,
                        32u8,
                        70u8,
                        177u8,
                        52u8,
                        181u8,
                        34u8,
                        79u8,
                        49u8,
                        147u8,
                        107u8,
                    ]);
                    const ANONYMOUS: bool = false;
                    #[allow(unused_variables)]
                    #[inline]
                    fn new(
                        topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                        data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        Self {
                            pool: topics.1,
                            fee: data.0,
                        }
                    }
                    #[inline]
                    fn tokenize_body(&self) -> Self::DataToken<'_> {
                        (
                            <::alloy::sol_types::sol_data::Uint<
                                256,
                            > as alloy_sol_types::SolType>::tokenize(&self.fee),
                        )
                    }
                    #[inline]
                    fn topics(
                        &self,
                    ) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                        (Self::SIGNATURE_HASH.into(), self.pool.clone())
                    }
                    #[inline]
                    fn encode_topics_raw(
                        &self,
                        out: &mut [alloy_sol_types::abi::token::WordToken],
                    ) -> alloy_sol_types::Result<()> {
                        if out.len()
                            < <Self::TopicList as alloy_sol_types::TopicList>::COUNT
                        {
                            return Err(alloy_sol_types::Error::Overrun);
                        }
                        out[0usize] = alloy_sol_types::abi::token::WordToken(
                            Self::SIGNATURE_HASH,
                        );
                        out[1usize] = <::alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                            &self.pool,
                        );
                        Ok(())
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::private::IntoLogData for SetCustomFee {
                    fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                        From::from(self)
                    }
                    fn into_log_data(self) -> alloy_sol_types::private::LogData {
                        From::from(&self)
                    }
                }
                #[automatically_derived]
                impl From<&SetCustomFee> for alloy_sol_types::private::LogData {
                    #[inline]
                    fn from(this: &SetCustomFee) -> alloy_sol_types::private::LogData {
                        alloy_sol_types::SolEvent::encode_log_data(this)
                    }
                }
            };
            /**Event with signature `SetFeeManager(address)` and selector `0x5d0517e3a4eabea892d9750138cd21d4a6cf3b935b43d0598df7055f463819b2`.
```solidity
event SetFeeManager(address feeManager);
```*/
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            pub struct SetFeeManager {
                #[allow(missing_docs)]
                pub feeManager: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            impl ::core::clone::Clone for SetFeeManager {
                #[inline]
                fn clone(&self) -> SetFeeManager {
                    SetFeeManager {
                        feeManager: ::core::clone::Clone::clone(&self.feeManager),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            impl ::core::fmt::Debug for SetFeeManager {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "SetFeeManager",
                        "feeManager",
                        &&self.feeManager,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                #[automatically_derived]
                impl alloy_sol_types::SolEvent for SetFeeManager {
                    type DataTuple<'a> = (::alloy::sol_types::sol_data::Address,);
                    type DataToken<'a> = <Self::DataTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
                    const SIGNATURE: &'static str = "SetFeeManager(address)";
                    const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                        93u8,
                        5u8,
                        23u8,
                        227u8,
                        164u8,
                        234u8,
                        190u8,
                        168u8,
                        146u8,
                        217u8,
                        117u8,
                        1u8,
                        56u8,
                        205u8,
                        33u8,
                        212u8,
                        166u8,
                        207u8,
                        59u8,
                        147u8,
                        91u8,
                        67u8,
                        208u8,
                        89u8,
                        141u8,
                        247u8,
                        5u8,
                        95u8,
                        70u8,
                        56u8,
                        25u8,
                        178u8,
                    ]);
                    const ANONYMOUS: bool = false;
                    #[allow(unused_variables)]
                    #[inline]
                    fn new(
                        topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                        data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        Self { feeManager: data.0 }
                    }
                    #[inline]
                    fn tokenize_body(&self) -> Self::DataToken<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self.feeManager,
                            ),
                        )
                    }
                    #[inline]
                    fn topics(
                        &self,
                    ) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                        (Self::SIGNATURE_HASH.into(),)
                    }
                    #[inline]
                    fn encode_topics_raw(
                        &self,
                        out: &mut [alloy_sol_types::abi::token::WordToken],
                    ) -> alloy_sol_types::Result<()> {
                        if out.len()
                            < <Self::TopicList as alloy_sol_types::TopicList>::COUNT
                        {
                            return Err(alloy_sol_types::Error::Overrun);
                        }
                        out[0usize] = alloy_sol_types::abi::token::WordToken(
                            Self::SIGNATURE_HASH,
                        );
                        Ok(())
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::private::IntoLogData for SetFeeManager {
                    fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                        From::from(self)
                    }
                    fn into_log_data(self) -> alloy_sol_types::private::LogData {
                        From::from(&self)
                    }
                }
                #[automatically_derived]
                impl From<&SetFeeManager> for alloy_sol_types::private::LogData {
                    #[inline]
                    fn from(this: &SetFeeManager) -> alloy_sol_types::private::LogData {
                        alloy_sol_types::SolEvent::encode_log_data(this)
                    }
                }
            };
            /**Event with signature `SetPauseState(bool)` and selector `0x0d76538efc408318a051137c2720a9e82902acdbd46b802d488b74ca3a09a116`.
```solidity
event SetPauseState(bool state);
```*/
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            pub struct SetPauseState {
                #[allow(missing_docs)]
                pub state: bool,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            impl ::core::clone::Clone for SetPauseState {
                #[inline]
                fn clone(&self) -> SetPauseState {
                    SetPauseState {
                        state: ::core::clone::Clone::clone(&self.state),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            impl ::core::fmt::Debug for SetPauseState {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "SetPauseState",
                        "state",
                        &&self.state,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                #[automatically_derived]
                impl alloy_sol_types::SolEvent for SetPauseState {
                    type DataTuple<'a> = (::alloy::sol_types::sol_data::Bool,);
                    type DataToken<'a> = <Self::DataTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
                    const SIGNATURE: &'static str = "SetPauseState(bool)";
                    const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                        13u8,
                        118u8,
                        83u8,
                        142u8,
                        252u8,
                        64u8,
                        131u8,
                        24u8,
                        160u8,
                        81u8,
                        19u8,
                        124u8,
                        39u8,
                        32u8,
                        169u8,
                        232u8,
                        41u8,
                        2u8,
                        172u8,
                        219u8,
                        212u8,
                        107u8,
                        128u8,
                        45u8,
                        72u8,
                        139u8,
                        116u8,
                        202u8,
                        58u8,
                        9u8,
                        161u8,
                        22u8,
                    ]);
                    const ANONYMOUS: bool = false;
                    #[allow(unused_variables)]
                    #[inline]
                    fn new(
                        topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                        data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        Self { state: data.0 }
                    }
                    #[inline]
                    fn tokenize_body(&self) -> Self::DataToken<'_> {
                        (
                            <::alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                                &self.state,
                            ),
                        )
                    }
                    #[inline]
                    fn topics(
                        &self,
                    ) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                        (Self::SIGNATURE_HASH.into(),)
                    }
                    #[inline]
                    fn encode_topics_raw(
                        &self,
                        out: &mut [alloy_sol_types::abi::token::WordToken],
                    ) -> alloy_sol_types::Result<()> {
                        if out.len()
                            < <Self::TopicList as alloy_sol_types::TopicList>::COUNT
                        {
                            return Err(alloy_sol_types::Error::Overrun);
                        }
                        out[0usize] = alloy_sol_types::abi::token::WordToken(
                            Self::SIGNATURE_HASH,
                        );
                        Ok(())
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::private::IntoLogData for SetPauseState {
                    fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                        From::from(self)
                    }
                    fn into_log_data(self) -> alloy_sol_types::private::LogData {
                        From::from(&self)
                    }
                }
                #[automatically_derived]
                impl From<&SetPauseState> for alloy_sol_types::private::LogData {
                    #[inline]
                    fn from(this: &SetPauseState) -> alloy_sol_types::private::LogData {
                        alloy_sol_types::SolEvent::encode_log_data(this)
                    }
                }
            };
            /**Event with signature `SetPauser(address)` and selector `0xe02efb9e8f0fc21546730ab32d594f62d586e1bbb15bb5045edd0b1878a77b35`.
```solidity
event SetPauser(address pauser);
```*/
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            pub struct SetPauser {
                #[allow(missing_docs)]
                pub pauser: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            impl ::core::clone::Clone for SetPauser {
                #[inline]
                fn clone(&self) -> SetPauser {
                    SetPauser {
                        pauser: ::core::clone::Clone::clone(&self.pauser),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            impl ::core::fmt::Debug for SetPauser {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "SetPauser",
                        "pauser",
                        &&self.pauser,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                #[automatically_derived]
                impl alloy_sol_types::SolEvent for SetPauser {
                    type DataTuple<'a> = (::alloy::sol_types::sol_data::Address,);
                    type DataToken<'a> = <Self::DataTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
                    const SIGNATURE: &'static str = "SetPauser(address)";
                    const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                        224u8,
                        46u8,
                        251u8,
                        158u8,
                        143u8,
                        15u8,
                        194u8,
                        21u8,
                        70u8,
                        115u8,
                        10u8,
                        179u8,
                        45u8,
                        89u8,
                        79u8,
                        98u8,
                        213u8,
                        134u8,
                        225u8,
                        187u8,
                        177u8,
                        91u8,
                        181u8,
                        4u8,
                        94u8,
                        221u8,
                        11u8,
                        24u8,
                        120u8,
                        167u8,
                        123u8,
                        53u8,
                    ]);
                    const ANONYMOUS: bool = false;
                    #[allow(unused_variables)]
                    #[inline]
                    fn new(
                        topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                        data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        Self { pauser: data.0 }
                    }
                    #[inline]
                    fn tokenize_body(&self) -> Self::DataToken<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self.pauser,
                            ),
                        )
                    }
                    #[inline]
                    fn topics(
                        &self,
                    ) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                        (Self::SIGNATURE_HASH.into(),)
                    }
                    #[inline]
                    fn encode_topics_raw(
                        &self,
                        out: &mut [alloy_sol_types::abi::token::WordToken],
                    ) -> alloy_sol_types::Result<()> {
                        if out.len()
                            < <Self::TopicList as alloy_sol_types::TopicList>::COUNT
                        {
                            return Err(alloy_sol_types::Error::Overrun);
                        }
                        out[0usize] = alloy_sol_types::abi::token::WordToken(
                            Self::SIGNATURE_HASH,
                        );
                        Ok(())
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::private::IntoLogData for SetPauser {
                    fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                        From::from(self)
                    }
                    fn into_log_data(self) -> alloy_sol_types::private::LogData {
                        From::from(&self)
                    }
                }
                #[automatically_derived]
                impl From<&SetPauser> for alloy_sol_types::private::LogData {
                    #[inline]
                    fn from(this: &SetPauser) -> alloy_sol_types::private::LogData {
                        alloy_sol_types::SolEvent::encode_log_data(this)
                    }
                }
            };
            /**Event with signature `SetVoter(address)` and selector `0xc6ff127433b785c51da9ae4088ee184c909b1a55b9afd82ae6c64224d3bc15d2`.
```solidity
event SetVoter(address voter);
```*/
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            pub struct SetVoter {
                #[allow(missing_docs)]
                pub voter: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            impl ::core::clone::Clone for SetVoter {
                #[inline]
                fn clone(&self) -> SetVoter {
                    SetVoter {
                        voter: ::core::clone::Clone::clone(&self.voter),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            impl ::core::fmt::Debug for SetVoter {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "SetVoter",
                        "voter",
                        &&self.voter,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                #[automatically_derived]
                impl alloy_sol_types::SolEvent for SetVoter {
                    type DataTuple<'a> = (::alloy::sol_types::sol_data::Address,);
                    type DataToken<'a> = <Self::DataTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
                    const SIGNATURE: &'static str = "SetVoter(address)";
                    const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                        198u8,
                        255u8,
                        18u8,
                        116u8,
                        51u8,
                        183u8,
                        133u8,
                        197u8,
                        29u8,
                        169u8,
                        174u8,
                        64u8,
                        136u8,
                        238u8,
                        24u8,
                        76u8,
                        144u8,
                        155u8,
                        26u8,
                        85u8,
                        185u8,
                        175u8,
                        216u8,
                        42u8,
                        230u8,
                        198u8,
                        66u8,
                        36u8,
                        211u8,
                        188u8,
                        21u8,
                        210u8,
                    ]);
                    const ANONYMOUS: bool = false;
                    #[allow(unused_variables)]
                    #[inline]
                    fn new(
                        topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                        data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        Self { voter: data.0 }
                    }
                    #[inline]
                    fn tokenize_body(&self) -> Self::DataToken<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self.voter,
                            ),
                        )
                    }
                    #[inline]
                    fn topics(
                        &self,
                    ) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                        (Self::SIGNATURE_HASH.into(),)
                    }
                    #[inline]
                    fn encode_topics_raw(
                        &self,
                        out: &mut [alloy_sol_types::abi::token::WordToken],
                    ) -> alloy_sol_types::Result<()> {
                        if out.len()
                            < <Self::TopicList as alloy_sol_types::TopicList>::COUNT
                        {
                            return Err(alloy_sol_types::Error::Overrun);
                        }
                        out[0usize] = alloy_sol_types::abi::token::WordToken(
                            Self::SIGNATURE_HASH,
                        );
                        Ok(())
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::private::IntoLogData for SetVoter {
                    fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                        From::from(self)
                    }
                    fn into_log_data(self) -> alloy_sol_types::private::LogData {
                        From::from(&self)
                    }
                }
                #[automatically_derived]
                impl From<&SetVoter> for alloy_sol_types::private::LogData {
                    #[inline]
                    fn from(this: &SetVoter) -> alloy_sol_types::private::LogData {
                        alloy_sol_types::SolEvent::encode_log_data(this)
                    }
                }
            };
            /**Constructor`.
```solidity
constructor(address _implementation);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct constructorCall {
                pub _implementation: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for constructorCall {
                #[inline]
                fn clone(&self) -> constructorCall {
                    constructorCall {
                        _implementation: ::core::clone::Clone::clone(
                            &self._implementation,
                        ),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for constructorCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "constructorCall",
                        "_implementation",
                        &&self._implementation,
                    )
                }
            }
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<constructorCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: constructorCall) -> Self {
                            (value._implementation,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for constructorCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _implementation: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolConstructor for constructorCall {
                    type Parameters<'a> = (::alloy::sol_types::sol_data::Address,);
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self._implementation,
                            ),
                        )
                    }
                }
            };
            /**Function with signature `MAX_FEE()` and selector `0xbc063e1a`.
```solidity
function MAX_FEE() external view returns (uint256);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct MAX_FEECall {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for MAX_FEECall {
                #[inline]
                fn clone(&self) -> MAX_FEECall {
                    MAX_FEECall {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for MAX_FEECall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "MAX_FEECall")
                }
            }
            ///Container type for the return parameters of the [`MAX_FEE()`](MAX_FEECall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct MAX_FEEReturn {
                pub _0: ::alloy::sol_types::private::U256,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for MAX_FEEReturn {
                #[inline]
                fn clone(&self) -> MAX_FEEReturn {
                    MAX_FEEReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for MAX_FEEReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "MAX_FEEReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<MAX_FEECall> for UnderlyingRustTuple<'_> {
                        fn from(value: MAX_FEECall) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>> for MAX_FEECall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Uint<256>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (::alloy::sol_types::private::U256,);
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<MAX_FEEReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: MAX_FEEReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for MAX_FEEReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for MAX_FEECall {
                    type Parameters<'a> = ();
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = MAX_FEEReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Uint<256>,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "MAX_FEE()";
                    const SELECTOR: [u8; 4] = [188u8, 6u8, 62u8, 26u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `ZERO_FEE_INDICATOR()` and selector `0x38c55d46`.
```solidity
function ZERO_FEE_INDICATOR() external view returns (uint256);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct ZERO_FEE_INDICATORCall {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for ZERO_FEE_INDICATORCall {
                #[inline]
                fn clone(&self) -> ZERO_FEE_INDICATORCall {
                    ZERO_FEE_INDICATORCall {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for ZERO_FEE_INDICATORCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "ZERO_FEE_INDICATORCall")
                }
            }
            ///Container type for the return parameters of the [`ZERO_FEE_INDICATOR()`](ZERO_FEE_INDICATORCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct ZERO_FEE_INDICATORReturn {
                pub _0: ::alloy::sol_types::private::U256,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for ZERO_FEE_INDICATORReturn {
                #[inline]
                fn clone(&self) -> ZERO_FEE_INDICATORReturn {
                    ZERO_FEE_INDICATORReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for ZERO_FEE_INDICATORReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "ZERO_FEE_INDICATORReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<ZERO_FEE_INDICATORCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: ZERO_FEE_INDICATORCall) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for ZERO_FEE_INDICATORCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Uint<256>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (::alloy::sol_types::private::U256,);
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<ZERO_FEE_INDICATORReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: ZERO_FEE_INDICATORReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for ZERO_FEE_INDICATORReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for ZERO_FEE_INDICATORCall {
                    type Parameters<'a> = ();
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = ZERO_FEE_INDICATORReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Uint<256>,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "ZERO_FEE_INDICATOR()";
                    const SELECTOR: [u8; 4] = [56u8, 197u8, 93u8, 70u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `allPools(uint256)` and selector `0x41d1de97`.
```solidity
function allPools(uint256) external view returns (address);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct allPoolsCall {
                pub _0: ::alloy::sol_types::private::U256,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for allPoolsCall {
                #[inline]
                fn clone(&self) -> allPoolsCall {
                    allPoolsCall {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for allPoolsCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "allPoolsCall",
                        "_0",
                        &&self._0,
                    )
                }
            }
            ///Container type for the return parameters of the [`allPools(uint256)`](allPoolsCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct allPoolsReturn {
                pub _0: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for allPoolsReturn {
                #[inline]
                fn clone(&self) -> allPoolsReturn {
                    allPoolsReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for allPoolsReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "allPoolsReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Uint<256>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (::alloy::sol_types::private::U256,);
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<allPoolsCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: allPoolsCall) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for allPoolsCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<allPoolsReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: allPoolsReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for allPoolsReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for allPoolsCall {
                    type Parameters<'a> = (::alloy::sol_types::sol_data::Uint<256>,);
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = allPoolsReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Address,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "allPools(uint256)";
                    const SELECTOR: [u8; 4] = [65u8, 209u8, 222u8, 151u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Uint<
                                256,
                            > as alloy_sol_types::SolType>::tokenize(&self._0),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `allPoolsLength()` and selector `0xefde4e64`.
```solidity
function allPoolsLength() external view returns (uint256);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct allPoolsLengthCall {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for allPoolsLengthCall {
                #[inline]
                fn clone(&self) -> allPoolsLengthCall {
                    allPoolsLengthCall {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for allPoolsLengthCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "allPoolsLengthCall")
                }
            }
            ///Container type for the return parameters of the [`allPoolsLength()`](allPoolsLengthCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct allPoolsLengthReturn {
                pub _0: ::alloy::sol_types::private::U256,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for allPoolsLengthReturn {
                #[inline]
                fn clone(&self) -> allPoolsLengthReturn {
                    allPoolsLengthReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for allPoolsLengthReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "allPoolsLengthReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<allPoolsLengthCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: allPoolsLengthCall) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for allPoolsLengthCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Uint<256>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (::alloy::sol_types::private::U256,);
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<allPoolsLengthReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: allPoolsLengthReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for allPoolsLengthReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for allPoolsLengthCall {
                    type Parameters<'a> = ();
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = allPoolsLengthReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Uint<256>,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "allPoolsLength()";
                    const SELECTOR: [u8; 4] = [239u8, 222u8, 78u8, 100u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `createPool(address,address,bool)` and selector `0x36bf95a0`.
```solidity
function createPool(address tokenA, address tokenB, bool stable) external returns (address pool);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct createPool_0Call {
                pub tokenA: ::alloy::sol_types::private::Address,
                pub tokenB: ::alloy::sol_types::private::Address,
                pub stable: bool,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for createPool_0Call {
                #[inline]
                fn clone(&self) -> createPool_0Call {
                    createPool_0Call {
                        tokenA: ::core::clone::Clone::clone(&self.tokenA),
                        tokenB: ::core::clone::Clone::clone(&self.tokenB),
                        stable: ::core::clone::Clone::clone(&self.stable),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for createPool_0Call {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "createPool_0Call",
                        "tokenA",
                        &self.tokenA,
                        "tokenB",
                        &self.tokenB,
                        "stable",
                        &&self.stable,
                    )
                }
            }
            ///Container type for the return parameters of the [`createPool(address,address,bool)`](createPool_0Call) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct createPool_0Return {
                pub pool: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for createPool_0Return {
                #[inline]
                fn clone(&self) -> createPool_0Return {
                    createPool_0Return {
                        pool: ::core::clone::Clone::clone(&self.pool),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for createPool_0Return {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "createPool_0Return",
                        "pool",
                        &&self.pool,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Bool,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                        ::alloy::sol_types::private::Address,
                        bool,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<createPool_0Call>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: createPool_0Call) -> Self {
                            (value.tokenA, value.tokenB, value.stable)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for createPool_0Call {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {
                                tokenA: tuple.0,
                                tokenB: tuple.1,
                                stable: tuple.2,
                            }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<createPool_0Return>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: createPool_0Return) -> Self {
                            (value.pool,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for createPool_0Return {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { pool: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for createPool_0Call {
                    type Parameters<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Bool,
                    );
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = createPool_0Return;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Address,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "createPool(address,address,bool)";
                    const SELECTOR: [u8; 4] = [54u8, 191u8, 149u8, 160u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self.tokenA,
                            ),
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self.tokenB,
                            ),
                            <::alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                                &self.stable,
                            ),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `createPool(address,address,uint24)` and selector `0xa1671295`.
```solidity
function createPool(address tokenA, address tokenB, uint24 fee) external returns (address pool);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct createPool_1Call {
                pub tokenA: ::alloy::sol_types::private::Address,
                pub tokenB: ::alloy::sol_types::private::Address,
                pub fee: <::alloy::sol_types::sol_data::Uint<
                    24,
                > as ::alloy::sol_types::SolType>::RustType,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for createPool_1Call {
                #[inline]
                fn clone(&self) -> createPool_1Call {
                    createPool_1Call {
                        tokenA: ::core::clone::Clone::clone(&self.tokenA),
                        tokenB: ::core::clone::Clone::clone(&self.tokenB),
                        fee: ::core::clone::Clone::clone(&self.fee),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for createPool_1Call {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "createPool_1Call",
                        "tokenA",
                        &self.tokenA,
                        "tokenB",
                        &self.tokenB,
                        "fee",
                        &&self.fee,
                    )
                }
            }
            ///Container type for the return parameters of the [`createPool(address,address,uint24)`](createPool_1Call) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct createPool_1Return {
                pub pool: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for createPool_1Return {
                #[inline]
                fn clone(&self) -> createPool_1Return {
                    createPool_1Return {
                        pool: ::core::clone::Clone::clone(&self.pool),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for createPool_1Return {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "createPool_1Return",
                        "pool",
                        &&self.pool,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Uint<24>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                        ::alloy::sol_types::private::Address,
                        <::alloy::sol_types::sol_data::Uint<
                            24,
                        > as ::alloy::sol_types::SolType>::RustType,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<createPool_1Call>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: createPool_1Call) -> Self {
                            (value.tokenA, value.tokenB, value.fee)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for createPool_1Call {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {
                                tokenA: tuple.0,
                                tokenB: tuple.1,
                                fee: tuple.2,
                            }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<createPool_1Return>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: createPool_1Return) -> Self {
                            (value.pool,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for createPool_1Return {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { pool: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for createPool_1Call {
                    type Parameters<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Uint<24>,
                    );
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = createPool_1Return;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Address,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "createPool(address,address,uint24)";
                    const SELECTOR: [u8; 4] = [161u8, 103u8, 18u8, 149u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self.tokenA,
                            ),
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self.tokenB,
                            ),
                            <::alloy::sol_types::sol_data::Uint<
                                24,
                            > as alloy_sol_types::SolType>::tokenize(&self.fee),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `customFee(address)` and selector `0x4d419abc`.
```solidity
function customFee(address) external view returns (uint256);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct customFeeCall {
                pub _0: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for customFeeCall {
                #[inline]
                fn clone(&self) -> customFeeCall {
                    customFeeCall {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for customFeeCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "customFeeCall",
                        "_0",
                        &&self._0,
                    )
                }
            }
            ///Container type for the return parameters of the [`customFee(address)`](customFeeCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct customFeeReturn {
                pub _0: ::alloy::sol_types::private::U256,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for customFeeReturn {
                #[inline]
                fn clone(&self) -> customFeeReturn {
                    customFeeReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for customFeeReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "customFeeReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<customFeeCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: customFeeCall) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for customFeeCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Uint<256>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (::alloy::sol_types::private::U256,);
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<customFeeReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: customFeeReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for customFeeReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for customFeeCall {
                    type Parameters<'a> = (::alloy::sol_types::sol_data::Address,);
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = customFeeReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Uint<256>,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "customFee(address)";
                    const SELECTOR: [u8; 4] = [77u8, 65u8, 154u8, 188u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self._0,
                            ),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `feeManager()` and selector `0xd0fb0203`.
```solidity
function feeManager() external view returns (address);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct feeManagerCall {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for feeManagerCall {
                #[inline]
                fn clone(&self) -> feeManagerCall {
                    feeManagerCall {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for feeManagerCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "feeManagerCall")
                }
            }
            ///Container type for the return parameters of the [`feeManager()`](feeManagerCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct feeManagerReturn {
                pub _0: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for feeManagerReturn {
                #[inline]
                fn clone(&self) -> feeManagerReturn {
                    feeManagerReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for feeManagerReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "feeManagerReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<feeManagerCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: feeManagerCall) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for feeManagerCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<feeManagerReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: feeManagerReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for feeManagerReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for feeManagerCall {
                    type Parameters<'a> = ();
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = feeManagerReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Address,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "feeManager()";
                    const SELECTOR: [u8; 4] = [208u8, 251u8, 2u8, 3u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `getFee(address,bool)` and selector `0xcc56b2c5`.
```solidity
function getFee(address pool, bool _stable) external view returns (uint256);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct getFeeCall {
                pub pool: ::alloy::sol_types::private::Address,
                pub _stable: bool,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for getFeeCall {
                #[inline]
                fn clone(&self) -> getFeeCall {
                    getFeeCall {
                        pool: ::core::clone::Clone::clone(&self.pool),
                        _stable: ::core::clone::Clone::clone(&self._stable),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for getFeeCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "getFeeCall",
                        "pool",
                        &self.pool,
                        "_stable",
                        &&self._stable,
                    )
                }
            }
            ///Container type for the return parameters of the [`getFee(address,bool)`](getFeeCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct getFeeReturn {
                pub _0: ::alloy::sol_types::private::U256,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for getFeeReturn {
                #[inline]
                fn clone(&self) -> getFeeReturn {
                    getFeeReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for getFeeReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "getFeeReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Bool,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                        bool,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<getFeeCall> for UnderlyingRustTuple<'_> {
                        fn from(value: getFeeCall) -> Self {
                            (value.pool, value._stable)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>> for getFeeCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {
                                pool: tuple.0,
                                _stable: tuple.1,
                            }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Uint<256>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (::alloy::sol_types::private::U256,);
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<getFeeReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: getFeeReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for getFeeReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for getFeeCall {
                    type Parameters<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Bool,
                    );
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = getFeeReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Uint<256>,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "getFee(address,bool)";
                    const SELECTOR: [u8; 4] = [204u8, 86u8, 178u8, 197u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self.pool,
                            ),
                            <::alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                                &self._stable,
                            ),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `getPool(address,address,uint24)` and selector `0x1698ee82`.
```solidity
function getPool(address tokenA, address tokenB, uint24 fee) external view returns (address);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct getPool_0Call {
                pub tokenA: ::alloy::sol_types::private::Address,
                pub tokenB: ::alloy::sol_types::private::Address,
                pub fee: <::alloy::sol_types::sol_data::Uint<
                    24,
                > as ::alloy::sol_types::SolType>::RustType,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for getPool_0Call {
                #[inline]
                fn clone(&self) -> getPool_0Call {
                    getPool_0Call {
                        tokenA: ::core::clone::Clone::clone(&self.tokenA),
                        tokenB: ::core::clone::Clone::clone(&self.tokenB),
                        fee: ::core::clone::Clone::clone(&self.fee),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for getPool_0Call {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "getPool_0Call",
                        "tokenA",
                        &self.tokenA,
                        "tokenB",
                        &self.tokenB,
                        "fee",
                        &&self.fee,
                    )
                }
            }
            ///Container type for the return parameters of the [`getPool(address,address,uint24)`](getPool_0Call) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct getPool_0Return {
                pub _0: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for getPool_0Return {
                #[inline]
                fn clone(&self) -> getPool_0Return {
                    getPool_0Return {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for getPool_0Return {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "getPool_0Return",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Uint<24>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                        ::alloy::sol_types::private::Address,
                        <::alloy::sol_types::sol_data::Uint<
                            24,
                        > as ::alloy::sol_types::SolType>::RustType,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<getPool_0Call>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: getPool_0Call) -> Self {
                            (value.tokenA, value.tokenB, value.fee)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for getPool_0Call {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {
                                tokenA: tuple.0,
                                tokenB: tuple.1,
                                fee: tuple.2,
                            }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<getPool_0Return>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: getPool_0Return) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for getPool_0Return {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for getPool_0Call {
                    type Parameters<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Uint<24>,
                    );
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = getPool_0Return;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Address,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "getPool(address,address,uint24)";
                    const SELECTOR: [u8; 4] = [22u8, 152u8, 238u8, 130u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self.tokenA,
                            ),
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self.tokenB,
                            ),
                            <::alloy::sol_types::sol_data::Uint<
                                24,
                            > as alloy_sol_types::SolType>::tokenize(&self.fee),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `getPool(address,address,bool)` and selector `0x79bc57d5`.
```solidity
function getPool(address tokenA, address tokenB, bool stable) external view returns (address);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct getPool_1Call {
                pub tokenA: ::alloy::sol_types::private::Address,
                pub tokenB: ::alloy::sol_types::private::Address,
                pub stable: bool,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for getPool_1Call {
                #[inline]
                fn clone(&self) -> getPool_1Call {
                    getPool_1Call {
                        tokenA: ::core::clone::Clone::clone(&self.tokenA),
                        tokenB: ::core::clone::Clone::clone(&self.tokenB),
                        stable: ::core::clone::Clone::clone(&self.stable),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for getPool_1Call {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "getPool_1Call",
                        "tokenA",
                        &self.tokenA,
                        "tokenB",
                        &self.tokenB,
                        "stable",
                        &&self.stable,
                    )
                }
            }
            ///Container type for the return parameters of the [`getPool(address,address,bool)`](getPool_1Call) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct getPool_1Return {
                pub _0: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for getPool_1Return {
                #[inline]
                fn clone(&self) -> getPool_1Return {
                    getPool_1Return {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for getPool_1Return {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "getPool_1Return",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Bool,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                        ::alloy::sol_types::private::Address,
                        bool,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<getPool_1Call>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: getPool_1Call) -> Self {
                            (value.tokenA, value.tokenB, value.stable)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for getPool_1Call {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {
                                tokenA: tuple.0,
                                tokenB: tuple.1,
                                stable: tuple.2,
                            }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<getPool_1Return>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: getPool_1Return) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for getPool_1Return {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for getPool_1Call {
                    type Parameters<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Bool,
                    );
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = getPool_1Return;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Address,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "getPool(address,address,bool)";
                    const SELECTOR: [u8; 4] = [121u8, 188u8, 87u8, 213u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self.tokenA,
                            ),
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self.tokenB,
                            ),
                            <::alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                                &self.stable,
                            ),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `implementation()` and selector `0x5c60da1b`.
```solidity
function implementation() external view returns (address);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct implementationCall {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for implementationCall {
                #[inline]
                fn clone(&self) -> implementationCall {
                    implementationCall {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for implementationCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "implementationCall")
                }
            }
            ///Container type for the return parameters of the [`implementation()`](implementationCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct implementationReturn {
                pub _0: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for implementationReturn {
                #[inline]
                fn clone(&self) -> implementationReturn {
                    implementationReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for implementationReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "implementationReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<implementationCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: implementationCall) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for implementationCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<implementationReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: implementationReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for implementationReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for implementationCall {
                    type Parameters<'a> = ();
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = implementationReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Address,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "implementation()";
                    const SELECTOR: [u8; 4] = [92u8, 96u8, 218u8, 27u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `isPaused()` and selector `0xb187bd26`.
```solidity
function isPaused() external view returns (bool);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct isPausedCall {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for isPausedCall {
                #[inline]
                fn clone(&self) -> isPausedCall {
                    isPausedCall {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for isPausedCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "isPausedCall")
                }
            }
            ///Container type for the return parameters of the [`isPaused()`](isPausedCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct isPausedReturn {
                pub _0: bool,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for isPausedReturn {
                #[inline]
                fn clone(&self) -> isPausedReturn {
                    isPausedReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for isPausedReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "isPausedReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<isPausedCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: isPausedCall) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for isPausedCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (::alloy::sol_types::sol_data::Bool,);
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (bool,);
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<isPausedReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: isPausedReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for isPausedReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for isPausedCall {
                    type Parameters<'a> = ();
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = isPausedReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Bool,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "isPaused()";
                    const SELECTOR: [u8; 4] = [177u8, 135u8, 189u8, 38u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `isPool(address)` and selector `0x5b16ebb7`.
```solidity
function isPool(address pool) external view returns (bool);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct isPoolCall {
                pub pool: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for isPoolCall {
                #[inline]
                fn clone(&self) -> isPoolCall {
                    isPoolCall {
                        pool: ::core::clone::Clone::clone(&self.pool),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for isPoolCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "isPoolCall",
                        "pool",
                        &&self.pool,
                    )
                }
            }
            ///Container type for the return parameters of the [`isPool(address)`](isPoolCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct isPoolReturn {
                pub _0: bool,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for isPoolReturn {
                #[inline]
                fn clone(&self) -> isPoolReturn {
                    isPoolReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for isPoolReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "isPoolReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<isPoolCall> for UnderlyingRustTuple<'_> {
                        fn from(value: isPoolCall) -> Self {
                            (value.pool,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>> for isPoolCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { pool: tuple.0 }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (::alloy::sol_types::sol_data::Bool,);
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (bool,);
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<isPoolReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: isPoolReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for isPoolReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for isPoolCall {
                    type Parameters<'a> = (::alloy::sol_types::sol_data::Address,);
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = isPoolReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Bool,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "isPool(address)";
                    const SELECTOR: [u8; 4] = [91u8, 22u8, 235u8, 183u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self.pool,
                            ),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `pauser()` and selector `0x9fd0506d`.
```solidity
function pauser() external view returns (address);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct pauserCall {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for pauserCall {
                #[inline]
                fn clone(&self) -> pauserCall {
                    pauserCall {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for pauserCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "pauserCall")
                }
            }
            ///Container type for the return parameters of the [`pauser()`](pauserCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct pauserReturn {
                pub _0: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for pauserReturn {
                #[inline]
                fn clone(&self) -> pauserReturn {
                    pauserReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for pauserReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "pauserReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<pauserCall> for UnderlyingRustTuple<'_> {
                        fn from(value: pauserCall) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauserCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<pauserReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: pauserReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for pauserReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for pauserCall {
                    type Parameters<'a> = ();
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = pauserReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Address,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "pauser()";
                    const SELECTOR: [u8; 4] = [159u8, 208u8, 80u8, 109u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `setCustomFee(address,uint256)` and selector `0xd49466a8`.
```solidity
function setCustomFee(address pool, uint256 fee) external;
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct setCustomFeeCall {
                pub pool: ::alloy::sol_types::private::Address,
                pub fee: ::alloy::sol_types::private::U256,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for setCustomFeeCall {
                #[inline]
                fn clone(&self) -> setCustomFeeCall {
                    setCustomFeeCall {
                        pool: ::core::clone::Clone::clone(&self.pool),
                        fee: ::core::clone::Clone::clone(&self.fee),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for setCustomFeeCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "setCustomFeeCall",
                        "pool",
                        &self.pool,
                        "fee",
                        &&self.fee,
                    )
                }
            }
            ///Container type for the return parameters of the [`setCustomFee(address,uint256)`](setCustomFeeCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct setCustomFeeReturn {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for setCustomFeeReturn {
                #[inline]
                fn clone(&self) -> setCustomFeeReturn {
                    setCustomFeeReturn {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for setCustomFeeReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "setCustomFeeReturn")
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Uint<256>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                        ::alloy::sol_types::private::U256,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<setCustomFeeCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: setCustomFeeCall) -> Self {
                            (value.pool, value.fee)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for setCustomFeeCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {
                                pool: tuple.0,
                                fee: tuple.1,
                            }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<setCustomFeeReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: setCustomFeeReturn) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for setCustomFeeReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for setCustomFeeCall {
                    type Parameters<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Uint<256>,
                    );
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = setCustomFeeReturn;
                    type ReturnTuple<'a> = ();
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "setCustomFee(address,uint256)";
                    const SELECTOR: [u8; 4] = [212u8, 148u8, 102u8, 168u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self.pool,
                            ),
                            <::alloy::sol_types::sol_data::Uint<
                                256,
                            > as alloy_sol_types::SolType>::tokenize(&self.fee),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `setFee(bool,uint256)` and selector `0xe1f76b44`.
```solidity
function setFee(bool _stable, uint256 _fee) external;
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct setFeeCall {
                pub _stable: bool,
                pub _fee: ::alloy::sol_types::private::U256,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for setFeeCall {
                #[inline]
                fn clone(&self) -> setFeeCall {
                    setFeeCall {
                        _stable: ::core::clone::Clone::clone(&self._stable),
                        _fee: ::core::clone::Clone::clone(&self._fee),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for setFeeCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "setFeeCall",
                        "_stable",
                        &self._stable,
                        "_fee",
                        &&self._fee,
                    )
                }
            }
            ///Container type for the return parameters of the [`setFee(bool,uint256)`](setFeeCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct setFeeReturn {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for setFeeReturn {
                #[inline]
                fn clone(&self) -> setFeeReturn {
                    setFeeReturn {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for setFeeReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "setFeeReturn")
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Bool,
                        ::alloy::sol_types::sol_data::Uint<256>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        bool,
                        ::alloy::sol_types::private::U256,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<setFeeCall> for UnderlyingRustTuple<'_> {
                        fn from(value: setFeeCall) -> Self {
                            (value._stable, value._fee)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>> for setFeeCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {
                                _stable: tuple.0,
                                _fee: tuple.1,
                            }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<setFeeReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: setFeeReturn) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for setFeeReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for setFeeCall {
                    type Parameters<'a> = (
                        ::alloy::sol_types::sol_data::Bool,
                        ::alloy::sol_types::sol_data::Uint<256>,
                    );
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = setFeeReturn;
                    type ReturnTuple<'a> = ();
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "setFee(bool,uint256)";
                    const SELECTOR: [u8; 4] = [225u8, 247u8, 107u8, 68u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                                &self._stable,
                            ),
                            <::alloy::sol_types::sol_data::Uint<
                                256,
                            > as alloy_sol_types::SolType>::tokenize(&self._fee),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `setFeeManager(address)` and selector `0x472d35b9`.
```solidity
function setFeeManager(address _feeManager) external;
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct setFeeManagerCall {
                pub _feeManager: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for setFeeManagerCall {
                #[inline]
                fn clone(&self) -> setFeeManagerCall {
                    setFeeManagerCall {
                        _feeManager: ::core::clone::Clone::clone(&self._feeManager),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for setFeeManagerCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "setFeeManagerCall",
                        "_feeManager",
                        &&self._feeManager,
                    )
                }
            }
            ///Container type for the return parameters of the [`setFeeManager(address)`](setFeeManagerCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct setFeeManagerReturn {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for setFeeManagerReturn {
                #[inline]
                fn clone(&self) -> setFeeManagerReturn {
                    setFeeManagerReturn {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for setFeeManagerReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "setFeeManagerReturn")
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<setFeeManagerCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: setFeeManagerCall) -> Self {
                            (value._feeManager,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for setFeeManagerCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _feeManager: tuple.0 }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<setFeeManagerReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: setFeeManagerReturn) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for setFeeManagerReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for setFeeManagerCall {
                    type Parameters<'a> = (::alloy::sol_types::sol_data::Address,);
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = setFeeManagerReturn;
                    type ReturnTuple<'a> = ();
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "setFeeManager(address)";
                    const SELECTOR: [u8; 4] = [71u8, 45u8, 53u8, 185u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self._feeManager,
                            ),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `setPauseState(bool)` and selector `0xcdb88ad1`.
```solidity
function setPauseState(bool _state) external;
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct setPauseStateCall {
                pub _state: bool,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for setPauseStateCall {
                #[inline]
                fn clone(&self) -> setPauseStateCall {
                    setPauseStateCall {
                        _state: ::core::clone::Clone::clone(&self._state),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for setPauseStateCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "setPauseStateCall",
                        "_state",
                        &&self._state,
                    )
                }
            }
            ///Container type for the return parameters of the [`setPauseState(bool)`](setPauseStateCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct setPauseStateReturn {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for setPauseStateReturn {
                #[inline]
                fn clone(&self) -> setPauseStateReturn {
                    setPauseStateReturn {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for setPauseStateReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "setPauseStateReturn")
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (::alloy::sol_types::sol_data::Bool,);
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (bool,);
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<setPauseStateCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: setPauseStateCall) -> Self {
                            (value._state,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for setPauseStateCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _state: tuple.0 }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<setPauseStateReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: setPauseStateReturn) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for setPauseStateReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for setPauseStateCall {
                    type Parameters<'a> = (::alloy::sol_types::sol_data::Bool,);
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = setPauseStateReturn;
                    type ReturnTuple<'a> = ();
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "setPauseState(bool)";
                    const SELECTOR: [u8; 4] = [205u8, 184u8, 138u8, 209u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                                &self._state,
                            ),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `setPauser(address)` and selector `0x2d88af4a`.
```solidity
function setPauser(address _pauser) external;
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct setPauserCall {
                pub _pauser: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for setPauserCall {
                #[inline]
                fn clone(&self) -> setPauserCall {
                    setPauserCall {
                        _pauser: ::core::clone::Clone::clone(&self._pauser),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for setPauserCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "setPauserCall",
                        "_pauser",
                        &&self._pauser,
                    )
                }
            }
            ///Container type for the return parameters of the [`setPauser(address)`](setPauserCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct setPauserReturn {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for setPauserReturn {
                #[inline]
                fn clone(&self) -> setPauserReturn {
                    setPauserReturn {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for setPauserReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "setPauserReturn")
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<setPauserCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: setPauserCall) -> Self {
                            (value._pauser,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for setPauserCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _pauser: tuple.0 }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<setPauserReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: setPauserReturn) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for setPauserReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for setPauserCall {
                    type Parameters<'a> = (::alloy::sol_types::sol_data::Address,);
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = setPauserReturn;
                    type ReturnTuple<'a> = ();
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "setPauser(address)";
                    const SELECTOR: [u8; 4] = [45u8, 136u8, 175u8, 74u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self._pauser,
                            ),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `setVoter(address)` and selector `0x4bc2a657`.
```solidity
function setVoter(address _voter) external;
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct setVoterCall {
                pub _voter: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for setVoterCall {
                #[inline]
                fn clone(&self) -> setVoterCall {
                    setVoterCall {
                        _voter: ::core::clone::Clone::clone(&self._voter),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for setVoterCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "setVoterCall",
                        "_voter",
                        &&self._voter,
                    )
                }
            }
            ///Container type for the return parameters of the [`setVoter(address)`](setVoterCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct setVoterReturn {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for setVoterReturn {
                #[inline]
                fn clone(&self) -> setVoterReturn {
                    setVoterReturn {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for setVoterReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "setVoterReturn")
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<setVoterCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: setVoterCall) -> Self {
                            (value._voter,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for setVoterCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _voter: tuple.0 }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<setVoterReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: setVoterReturn) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for setVoterReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for setVoterCall {
                    type Parameters<'a> = (::alloy::sol_types::sol_data::Address,);
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = setVoterReturn;
                    type ReturnTuple<'a> = ();
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "setVoter(address)";
                    const SELECTOR: [u8; 4] = [75u8, 194u8, 166u8, 87u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self._voter,
                            ),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `stableFee()` and selector `0x40bbd775`.
```solidity
function stableFee() external view returns (uint256);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct stableFeeCall {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for stableFeeCall {
                #[inline]
                fn clone(&self) -> stableFeeCall {
                    stableFeeCall {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for stableFeeCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "stableFeeCall")
                }
            }
            ///Container type for the return parameters of the [`stableFee()`](stableFeeCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct stableFeeReturn {
                pub _0: ::alloy::sol_types::private::U256,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for stableFeeReturn {
                #[inline]
                fn clone(&self) -> stableFeeReturn {
                    stableFeeReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for stableFeeReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "stableFeeReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<stableFeeCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: stableFeeCall) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for stableFeeCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Uint<256>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (::alloy::sol_types::private::U256,);
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<stableFeeReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: stableFeeReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for stableFeeReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for stableFeeCall {
                    type Parameters<'a> = ();
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = stableFeeReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Uint<256>,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "stableFee()";
                    const SELECTOR: [u8; 4] = [64u8, 187u8, 215u8, 117u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `volatileFee()` and selector `0x5084ed03`.
```solidity
function volatileFee() external view returns (uint256);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct volatileFeeCall {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for volatileFeeCall {
                #[inline]
                fn clone(&self) -> volatileFeeCall {
                    volatileFeeCall {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for volatileFeeCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "volatileFeeCall")
                }
            }
            ///Container type for the return parameters of the [`volatileFee()`](volatileFeeCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct volatileFeeReturn {
                pub _0: ::alloy::sol_types::private::U256,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for volatileFeeReturn {
                #[inline]
                fn clone(&self) -> volatileFeeReturn {
                    volatileFeeReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for volatileFeeReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "volatileFeeReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<volatileFeeCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: volatileFeeCall) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for volatileFeeCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Uint<256>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (::alloy::sol_types::private::U256,);
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<volatileFeeReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: volatileFeeReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for volatileFeeReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for volatileFeeCall {
                    type Parameters<'a> = ();
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = volatileFeeReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Uint<256>,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "volatileFee()";
                    const SELECTOR: [u8; 4] = [80u8, 132u8, 237u8, 3u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `voter()` and selector `0x46c96aac`.
```solidity
function voter() external view returns (address);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct voterCall {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for voterCall {
                #[inline]
                fn clone(&self) -> voterCall {
                    voterCall {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for voterCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "voterCall")
                }
            }
            ///Container type for the return parameters of the [`voter()`](voterCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct voterReturn {
                pub _0: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for voterReturn {
                #[inline]
                fn clone(&self) -> voterReturn {
                    voterReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for voterReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "voterReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<voterCall> for UnderlyingRustTuple<'_> {
                        fn from(value: voterCall) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>> for voterCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<voterReturn> for UnderlyingRustTuple<'_> {
                        fn from(value: voterReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>> for voterReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for voterCall {
                    type Parameters<'a> = ();
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = voterReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Address,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "voter()";
                    const SELECTOR: [u8; 4] = [70u8, 201u8, 106u8, 172u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            ///Container for all the [`AerodomeV2Factory`](self) function calls.
            pub enum AerodomeV2FactoryCalls {
                MAX_FEE(MAX_FEECall),
                ZERO_FEE_INDICATOR(ZERO_FEE_INDICATORCall),
                allPools(allPoolsCall),
                allPoolsLength(allPoolsLengthCall),
                createPool_0(createPool_0Call),
                createPool_1(createPool_1Call),
                customFee(customFeeCall),
                feeManager(feeManagerCall),
                getFee(getFeeCall),
                getPool_0(getPool_0Call),
                getPool_1(getPool_1Call),
                implementation(implementationCall),
                isPaused(isPausedCall),
                isPool(isPoolCall),
                pauser(pauserCall),
                setCustomFee(setCustomFeeCall),
                setFee(setFeeCall),
                setFeeManager(setFeeManagerCall),
                setPauseState(setPauseStateCall),
                setPauser(setPauserCall),
                setVoter(setVoterCall),
                stableFee(stableFeeCall),
                volatileFee(volatileFeeCall),
                voter(voterCall),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for AerodomeV2FactoryCalls {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        AerodomeV2FactoryCalls::MAX_FEE(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "MAX_FEE",
                                &__self_0,
                            )
                        }
                        AerodomeV2FactoryCalls::ZERO_FEE_INDICATOR(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "ZERO_FEE_INDICATOR",
                                &__self_0,
                            )
                        }
                        AerodomeV2FactoryCalls::allPools(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "allPools",
                                &__self_0,
                            )
                        }
                        AerodomeV2FactoryCalls::allPoolsLength(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "allPoolsLength",
                                &__self_0,
                            )
                        }
                        AerodomeV2FactoryCalls::createPool_0(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "createPool_0",
                                &__self_0,
                            )
                        }
                        AerodomeV2FactoryCalls::createPool_1(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "createPool_1",
                                &__self_0,
                            )
                        }
                        AerodomeV2FactoryCalls::customFee(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "customFee",
                                &__self_0,
                            )
                        }
                        AerodomeV2FactoryCalls::feeManager(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "feeManager",
                                &__self_0,
                            )
                        }
                        AerodomeV2FactoryCalls::getFee(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "getFee",
                                &__self_0,
                            )
                        }
                        AerodomeV2FactoryCalls::getPool_0(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "getPool_0",
                                &__self_0,
                            )
                        }
                        AerodomeV2FactoryCalls::getPool_1(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "getPool_1",
                                &__self_0,
                            )
                        }
                        AerodomeV2FactoryCalls::implementation(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "implementation",
                                &__self_0,
                            )
                        }
                        AerodomeV2FactoryCalls::isPaused(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "isPaused",
                                &__self_0,
                            )
                        }
                        AerodomeV2FactoryCalls::isPool(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "isPool",
                                &__self_0,
                            )
                        }
                        AerodomeV2FactoryCalls::pauser(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "pauser",
                                &__self_0,
                            )
                        }
                        AerodomeV2FactoryCalls::setCustomFee(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "setCustomFee",
                                &__self_0,
                            )
                        }
                        AerodomeV2FactoryCalls::setFee(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "setFee",
                                &__self_0,
                            )
                        }
                        AerodomeV2FactoryCalls::setFeeManager(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "setFeeManager",
                                &__self_0,
                            )
                        }
                        AerodomeV2FactoryCalls::setPauseState(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "setPauseState",
                                &__self_0,
                            )
                        }
                        AerodomeV2FactoryCalls::setPauser(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "setPauser",
                                &__self_0,
                            )
                        }
                        AerodomeV2FactoryCalls::setVoter(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "setVoter",
                                &__self_0,
                            )
                        }
                        AerodomeV2FactoryCalls::stableFee(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "stableFee",
                                &__self_0,
                            )
                        }
                        AerodomeV2FactoryCalls::volatileFee(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "volatileFee",
                                &__self_0,
                            )
                        }
                        AerodomeV2FactoryCalls::voter(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "voter",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl AerodomeV2FactoryCalls {
                /// All the selectors of this enum.
                ///
                /// Note that the selectors might not be in the same order as the variants.
                /// No guarantees are made about the order of the selectors.
                ///
                /// Prefer using `SolInterface` methods instead.
                pub const SELECTORS: &'static [[u8; 4usize]] = &[
                    [22u8, 152u8, 238u8, 130u8],
                    [45u8, 136u8, 175u8, 74u8],
                    [54u8, 191u8, 149u8, 160u8],
                    [56u8, 197u8, 93u8, 70u8],
                    [64u8, 187u8, 215u8, 117u8],
                    [65u8, 209u8, 222u8, 151u8],
                    [70u8, 201u8, 106u8, 172u8],
                    [71u8, 45u8, 53u8, 185u8],
                    [75u8, 194u8, 166u8, 87u8],
                    [77u8, 65u8, 154u8, 188u8],
                    [80u8, 132u8, 237u8, 3u8],
                    [91u8, 22u8, 235u8, 183u8],
                    [92u8, 96u8, 218u8, 27u8],
                    [121u8, 188u8, 87u8, 213u8],
                    [159u8, 208u8, 80u8, 109u8],
                    [161u8, 103u8, 18u8, 149u8],
                    [177u8, 135u8, 189u8, 38u8],
                    [188u8, 6u8, 62u8, 26u8],
                    [204u8, 86u8, 178u8, 197u8],
                    [205u8, 184u8, 138u8, 209u8],
                    [208u8, 251u8, 2u8, 3u8],
                    [212u8, 148u8, 102u8, 168u8],
                    [225u8, 247u8, 107u8, 68u8],
                    [239u8, 222u8, 78u8, 100u8],
                ];
            }
            #[automatically_derived]
            impl alloy_sol_types::SolInterface for AerodomeV2FactoryCalls {
                const NAME: &'static str = "AerodomeV2FactoryCalls";
                const MIN_DATA_LENGTH: usize = 0usize;
                const COUNT: usize = 24usize;
                #[inline]
                fn selector(&self) -> [u8; 4] {
                    match self {
                        Self::MAX_FEE(_) => {
                            <MAX_FEECall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::ZERO_FEE_INDICATOR(_) => {
                            <ZERO_FEE_INDICATORCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::allPools(_) => {
                            <allPoolsCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::allPoolsLength(_) => {
                            <allPoolsLengthCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::createPool_0(_) => {
                            <createPool_0Call as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::createPool_1(_) => {
                            <createPool_1Call as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::customFee(_) => {
                            <customFeeCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::feeManager(_) => {
                            <feeManagerCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::getFee(_) => {
                            <getFeeCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::getPool_0(_) => {
                            <getPool_0Call as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::getPool_1(_) => {
                            <getPool_1Call as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::implementation(_) => {
                            <implementationCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::isPaused(_) => {
                            <isPausedCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::isPool(_) => {
                            <isPoolCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::pauser(_) => {
                            <pauserCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::setCustomFee(_) => {
                            <setCustomFeeCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::setFee(_) => {
                            <setFeeCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::setFeeManager(_) => {
                            <setFeeManagerCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::setPauseState(_) => {
                            <setPauseStateCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::setPauser(_) => {
                            <setPauserCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::setVoter(_) => {
                            <setVoterCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::stableFee(_) => {
                            <stableFeeCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::volatileFee(_) => {
                            <volatileFeeCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::voter(_) => {
                            <voterCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                    }
                }
                #[inline]
                fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
                    Self::SELECTORS.get(i).copied()
                }
                #[inline]
                fn valid_selector(selector: [u8; 4]) -> bool {
                    Self::SELECTORS.binary_search(&selector).is_ok()
                }
                #[inline]
                #[allow(unsafe_code, non_snake_case)]
                fn abi_decode_raw(
                    selector: [u8; 4],
                    data: &[u8],
                    validate: bool,
                ) -> alloy_sol_types::Result<Self> {
                    static DECODE_SHIMS: &[fn(
                        &[u8],
                        bool,
                    ) -> alloy_sol_types::Result<AerodomeV2FactoryCalls>] = &[
                        {
                            fn getPool_0(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<AerodomeV2FactoryCalls> {
                                <getPool_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(AerodomeV2FactoryCalls::getPool_0)
                            }
                            getPool_0
                        },
                        {
                            fn setPauser(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<AerodomeV2FactoryCalls> {
                                <setPauserCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(AerodomeV2FactoryCalls::setPauser)
                            }
                            setPauser
                        },
                        {
                            fn createPool_0(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<AerodomeV2FactoryCalls> {
                                <createPool_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(AerodomeV2FactoryCalls::createPool_0)
                            }
                            createPool_0
                        },
                        {
                            fn ZERO_FEE_INDICATOR(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<AerodomeV2FactoryCalls> {
                                <ZERO_FEE_INDICATORCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(AerodomeV2FactoryCalls::ZERO_FEE_INDICATOR)
                            }
                            ZERO_FEE_INDICATOR
                        },
                        {
                            fn stableFee(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<AerodomeV2FactoryCalls> {
                                <stableFeeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(AerodomeV2FactoryCalls::stableFee)
                            }
                            stableFee
                        },
                        {
                            fn allPools(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<AerodomeV2FactoryCalls> {
                                <allPoolsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(AerodomeV2FactoryCalls::allPools)
                            }
                            allPools
                        },
                        {
                            fn voter(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<AerodomeV2FactoryCalls> {
                                <voterCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(AerodomeV2FactoryCalls::voter)
                            }
                            voter
                        },
                        {
                            fn setFeeManager(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<AerodomeV2FactoryCalls> {
                                <setFeeManagerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(AerodomeV2FactoryCalls::setFeeManager)
                            }
                            setFeeManager
                        },
                        {
                            fn setVoter(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<AerodomeV2FactoryCalls> {
                                <setVoterCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(AerodomeV2FactoryCalls::setVoter)
                            }
                            setVoter
                        },
                        {
                            fn customFee(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<AerodomeV2FactoryCalls> {
                                <customFeeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(AerodomeV2FactoryCalls::customFee)
                            }
                            customFee
                        },
                        {
                            fn volatileFee(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<AerodomeV2FactoryCalls> {
                                <volatileFeeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(AerodomeV2FactoryCalls::volatileFee)
                            }
                            volatileFee
                        },
                        {
                            fn isPool(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<AerodomeV2FactoryCalls> {
                                <isPoolCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(AerodomeV2FactoryCalls::isPool)
                            }
                            isPool
                        },
                        {
                            fn implementation(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<AerodomeV2FactoryCalls> {
                                <implementationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(AerodomeV2FactoryCalls::implementation)
                            }
                            implementation
                        },
                        {
                            fn getPool_1(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<AerodomeV2FactoryCalls> {
                                <getPool_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(AerodomeV2FactoryCalls::getPool_1)
                            }
                            getPool_1
                        },
                        {
                            fn pauser(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<AerodomeV2FactoryCalls> {
                                <pauserCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(AerodomeV2FactoryCalls::pauser)
                            }
                            pauser
                        },
                        {
                            fn createPool_1(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<AerodomeV2FactoryCalls> {
                                <createPool_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(AerodomeV2FactoryCalls::createPool_1)
                            }
                            createPool_1
                        },
                        {
                            fn isPaused(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<AerodomeV2FactoryCalls> {
                                <isPausedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(AerodomeV2FactoryCalls::isPaused)
                            }
                            isPaused
                        },
                        {
                            fn MAX_FEE(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<AerodomeV2FactoryCalls> {
                                <MAX_FEECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(AerodomeV2FactoryCalls::MAX_FEE)
                            }
                            MAX_FEE
                        },
                        {
                            fn getFee(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<AerodomeV2FactoryCalls> {
                                <getFeeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(AerodomeV2FactoryCalls::getFee)
                            }
                            getFee
                        },
                        {
                            fn setPauseState(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<AerodomeV2FactoryCalls> {
                                <setPauseStateCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(AerodomeV2FactoryCalls::setPauseState)
                            }
                            setPauseState
                        },
                        {
                            fn feeManager(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<AerodomeV2FactoryCalls> {
                                <feeManagerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(AerodomeV2FactoryCalls::feeManager)
                            }
                            feeManager
                        },
                        {
                            fn setCustomFee(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<AerodomeV2FactoryCalls> {
                                <setCustomFeeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(AerodomeV2FactoryCalls::setCustomFee)
                            }
                            setCustomFee
                        },
                        {
                            fn setFee(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<AerodomeV2FactoryCalls> {
                                <setFeeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(AerodomeV2FactoryCalls::setFee)
                            }
                            setFee
                        },
                        {
                            fn allPoolsLength(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<AerodomeV2FactoryCalls> {
                                <allPoolsLengthCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(AerodomeV2FactoryCalls::allPoolsLength)
                            }
                            allPoolsLength
                        },
                    ];
                    let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                        return Err(
                            alloy_sol_types::Error::unknown_selector(
                                <Self as alloy_sol_types::SolInterface>::NAME,
                                selector,
                            ),
                        );
                    };
                    (unsafe { DECODE_SHIMS.get_unchecked(idx) })(data, validate)
                }
                #[inline]
                fn abi_encoded_size(&self) -> usize {
                    match self {
                        Self::MAX_FEE(inner) => {
                            <MAX_FEECall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::ZERO_FEE_INDICATOR(inner) => {
                            <ZERO_FEE_INDICATORCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::allPools(inner) => {
                            <allPoolsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::allPoolsLength(inner) => {
                            <allPoolsLengthCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::createPool_0(inner) => {
                            <createPool_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::createPool_1(inner) => {
                            <createPool_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::customFee(inner) => {
                            <customFeeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::feeManager(inner) => {
                            <feeManagerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::getFee(inner) => {
                            <getFeeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::getPool_0(inner) => {
                            <getPool_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::getPool_1(inner) => {
                            <getPool_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::implementation(inner) => {
                            <implementationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::isPaused(inner) => {
                            <isPausedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::isPool(inner) => {
                            <isPoolCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::pauser(inner) => {
                            <pauserCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::setCustomFee(inner) => {
                            <setCustomFeeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::setFee(inner) => {
                            <setFeeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::setFeeManager(inner) => {
                            <setFeeManagerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::setPauseState(inner) => {
                            <setPauseStateCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::setPauser(inner) => {
                            <setPauserCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::setVoter(inner) => {
                            <setVoterCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::stableFee(inner) => {
                            <stableFeeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::volatileFee(inner) => {
                            <volatileFeeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::voter(inner) => {
                            <voterCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                    }
                }
                #[inline]
                fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                    match self {
                        Self::MAX_FEE(inner) => {
                            <MAX_FEECall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::ZERO_FEE_INDICATOR(inner) => {
                            <ZERO_FEE_INDICATORCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::allPools(inner) => {
                            <allPoolsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::allPoolsLength(inner) => {
                            <allPoolsLengthCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::createPool_0(inner) => {
                            <createPool_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::createPool_1(inner) => {
                            <createPool_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::customFee(inner) => {
                            <customFeeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::feeManager(inner) => {
                            <feeManagerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::getFee(inner) => {
                            <getFeeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::getPool_0(inner) => {
                            <getPool_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::getPool_1(inner) => {
                            <getPool_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::implementation(inner) => {
                            <implementationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::isPaused(inner) => {
                            <isPausedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::isPool(inner) => {
                            <isPoolCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::pauser(inner) => {
                            <pauserCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::setCustomFee(inner) => {
                            <setCustomFeeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::setFee(inner) => {
                            <setFeeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::setFeeManager(inner) => {
                            <setFeeManagerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::setPauseState(inner) => {
                            <setPauseStateCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::setPauser(inner) => {
                            <setPauserCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::setVoter(inner) => {
                            <setVoterCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::stableFee(inner) => {
                            <stableFeeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::volatileFee(inner) => {
                            <volatileFeeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::voter(inner) => {
                            <voterCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                    }
                }
            }
            ///Container for all the [`AerodomeV2Factory`](self) custom errors.
            pub enum AerodomeV2FactoryErrors {
                FeeInvalid(FeeInvalid),
                FeeTooHigh(FeeTooHigh),
                InvalidPool(InvalidPool),
                NotFeeManager(NotFeeManager),
                NotPauser(NotPauser),
                NotVoter(NotVoter),
                PoolAlreadyExists(PoolAlreadyExists),
                SameAddress(SameAddress),
                ZeroAddress(ZeroAddress),
                ZeroFee(ZeroFee),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for AerodomeV2FactoryErrors {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        AerodomeV2FactoryErrors::FeeInvalid(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "FeeInvalid",
                                &__self_0,
                            )
                        }
                        AerodomeV2FactoryErrors::FeeTooHigh(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "FeeTooHigh",
                                &__self_0,
                            )
                        }
                        AerodomeV2FactoryErrors::InvalidPool(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "InvalidPool",
                                &__self_0,
                            )
                        }
                        AerodomeV2FactoryErrors::NotFeeManager(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "NotFeeManager",
                                &__self_0,
                            )
                        }
                        AerodomeV2FactoryErrors::NotPauser(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "NotPauser",
                                &__self_0,
                            )
                        }
                        AerodomeV2FactoryErrors::NotVoter(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "NotVoter",
                                &__self_0,
                            )
                        }
                        AerodomeV2FactoryErrors::PoolAlreadyExists(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "PoolAlreadyExists",
                                &__self_0,
                            )
                        }
                        AerodomeV2FactoryErrors::SameAddress(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "SameAddress",
                                &__self_0,
                            )
                        }
                        AerodomeV2FactoryErrors::ZeroAddress(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "ZeroAddress",
                                &__self_0,
                            )
                        }
                        AerodomeV2FactoryErrors::ZeroFee(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "ZeroFee",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl AerodomeV2FactoryErrors {
                /// All the selectors of this enum.
                ///
                /// Note that the selectors might not be in the same order as the variants.
                /// No guarantees are made about the order of the selectors.
                ///
                /// Prefer using `SolInterface` methods instead.
                pub const SELECTORS: &'static [[u8; 4usize]] = &[
                    [3u8, 17u8, 147u8, 34u8],
                    [32u8, 131u8, 205u8, 64u8],
                    [54u8, 117u8, 88u8, 195u8],
                    [73u8, 47u8, 103u8, 129u8],
                    [82u8, 218u8, 220u8, 249u8],
                    [175u8, 19u8, 152u8, 109u8],
                    [193u8, 131u8, 132u8, 193u8],
                    [205u8, 78u8, 97u8, 103u8],
                    [217u8, 46u8, 35u8, 61u8],
                    [245u8, 210u8, 103u8, 235u8],
                ];
            }
            #[automatically_derived]
            impl alloy_sol_types::SolInterface for AerodomeV2FactoryErrors {
                const NAME: &'static str = "AerodomeV2FactoryErrors";
                const MIN_DATA_LENGTH: usize = 0usize;
                const COUNT: usize = 10usize;
                #[inline]
                fn selector(&self) -> [u8; 4] {
                    match self {
                        Self::FeeInvalid(_) => {
                            <FeeInvalid as alloy_sol_types::SolError>::SELECTOR
                        }
                        Self::FeeTooHigh(_) => {
                            <FeeTooHigh as alloy_sol_types::SolError>::SELECTOR
                        }
                        Self::InvalidPool(_) => {
                            <InvalidPool as alloy_sol_types::SolError>::SELECTOR
                        }
                        Self::NotFeeManager(_) => {
                            <NotFeeManager as alloy_sol_types::SolError>::SELECTOR
                        }
                        Self::NotPauser(_) => {
                            <NotPauser as alloy_sol_types::SolError>::SELECTOR
                        }
                        Self::NotVoter(_) => {
                            <NotVoter as alloy_sol_types::SolError>::SELECTOR
                        }
                        Self::PoolAlreadyExists(_) => {
                            <PoolAlreadyExists as alloy_sol_types::SolError>::SELECTOR
                        }
                        Self::SameAddress(_) => {
                            <SameAddress as alloy_sol_types::SolError>::SELECTOR
                        }
                        Self::ZeroAddress(_) => {
                            <ZeroAddress as alloy_sol_types::SolError>::SELECTOR
                        }
                        Self::ZeroFee(_) => {
                            <ZeroFee as alloy_sol_types::SolError>::SELECTOR
                        }
                    }
                }
                #[inline]
                fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
                    Self::SELECTORS.get(i).copied()
                }
                #[inline]
                fn valid_selector(selector: [u8; 4]) -> bool {
                    Self::SELECTORS.binary_search(&selector).is_ok()
                }
                #[inline]
                #[allow(unsafe_code, non_snake_case)]
                fn abi_decode_raw(
                    selector: [u8; 4],
                    data: &[u8],
                    validate: bool,
                ) -> alloy_sol_types::Result<Self> {
                    static DECODE_SHIMS: &[fn(
                        &[u8],
                        bool,
                    ) -> alloy_sol_types::Result<AerodomeV2FactoryErrors>] = &[
                        {
                            fn PoolAlreadyExists(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<AerodomeV2FactoryErrors> {
                                <PoolAlreadyExists as alloy_sol_types::SolError>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(AerodomeV2FactoryErrors::PoolAlreadyExists)
                            }
                            PoolAlreadyExists
                        },
                        {
                            fn InvalidPool(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<AerodomeV2FactoryErrors> {
                                <InvalidPool as alloy_sol_types::SolError>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(AerodomeV2FactoryErrors::InvalidPool)
                            }
                            InvalidPool
                        },
                        {
                            fn SameAddress(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<AerodomeV2FactoryErrors> {
                                <SameAddress as alloy_sol_types::SolError>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(AerodomeV2FactoryErrors::SameAddress)
                            }
                            SameAddress
                        },
                        {
                            fn NotPauser(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<AerodomeV2FactoryErrors> {
                                <NotPauser as alloy_sol_types::SolError>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(AerodomeV2FactoryErrors::NotPauser)
                            }
                            NotPauser
                        },
                        {
                            fn FeeInvalid(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<AerodomeV2FactoryErrors> {
                                <FeeInvalid as alloy_sol_types::SolError>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(AerodomeV2FactoryErrors::FeeInvalid)
                            }
                            FeeInvalid
                        },
                        {
                            fn ZeroFee(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<AerodomeV2FactoryErrors> {
                                <ZeroFee as alloy_sol_types::SolError>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(AerodomeV2FactoryErrors::ZeroFee)
                            }
                            ZeroFee
                        },
                        {
                            fn NotVoter(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<AerodomeV2FactoryErrors> {
                                <NotVoter as alloy_sol_types::SolError>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(AerodomeV2FactoryErrors::NotVoter)
                            }
                            NotVoter
                        },
                        {
                            fn FeeTooHigh(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<AerodomeV2FactoryErrors> {
                                <FeeTooHigh as alloy_sol_types::SolError>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(AerodomeV2FactoryErrors::FeeTooHigh)
                            }
                            FeeTooHigh
                        },
                        {
                            fn ZeroAddress(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<AerodomeV2FactoryErrors> {
                                <ZeroAddress as alloy_sol_types::SolError>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(AerodomeV2FactoryErrors::ZeroAddress)
                            }
                            ZeroAddress
                        },
                        {
                            fn NotFeeManager(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<AerodomeV2FactoryErrors> {
                                <NotFeeManager as alloy_sol_types::SolError>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(AerodomeV2FactoryErrors::NotFeeManager)
                            }
                            NotFeeManager
                        },
                    ];
                    let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                        return Err(
                            alloy_sol_types::Error::unknown_selector(
                                <Self as alloy_sol_types::SolInterface>::NAME,
                                selector,
                            ),
                        );
                    };
                    (unsafe { DECODE_SHIMS.get_unchecked(idx) })(data, validate)
                }
                #[inline]
                fn abi_encoded_size(&self) -> usize {
                    match self {
                        Self::FeeInvalid(inner) => {
                            <FeeInvalid as alloy_sol_types::SolError>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::FeeTooHigh(inner) => {
                            <FeeTooHigh as alloy_sol_types::SolError>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::InvalidPool(inner) => {
                            <InvalidPool as alloy_sol_types::SolError>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::NotFeeManager(inner) => {
                            <NotFeeManager as alloy_sol_types::SolError>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::NotPauser(inner) => {
                            <NotPauser as alloy_sol_types::SolError>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::NotVoter(inner) => {
                            <NotVoter as alloy_sol_types::SolError>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::PoolAlreadyExists(inner) => {
                            <PoolAlreadyExists as alloy_sol_types::SolError>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::SameAddress(inner) => {
                            <SameAddress as alloy_sol_types::SolError>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::ZeroAddress(inner) => {
                            <ZeroAddress as alloy_sol_types::SolError>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::ZeroFee(inner) => {
                            <ZeroFee as alloy_sol_types::SolError>::abi_encoded_size(
                                inner,
                            )
                        }
                    }
                }
                #[inline]
                fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                    match self {
                        Self::FeeInvalid(inner) => {
                            <FeeInvalid as alloy_sol_types::SolError>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::FeeTooHigh(inner) => {
                            <FeeTooHigh as alloy_sol_types::SolError>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::InvalidPool(inner) => {
                            <InvalidPool as alloy_sol_types::SolError>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::NotFeeManager(inner) => {
                            <NotFeeManager as alloy_sol_types::SolError>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::NotPauser(inner) => {
                            <NotPauser as alloy_sol_types::SolError>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::NotVoter(inner) => {
                            <NotVoter as alloy_sol_types::SolError>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::PoolAlreadyExists(inner) => {
                            <PoolAlreadyExists as alloy_sol_types::SolError>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::SameAddress(inner) => {
                            <SameAddress as alloy_sol_types::SolError>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::ZeroAddress(inner) => {
                            <ZeroAddress as alloy_sol_types::SolError>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::ZeroFee(inner) => {
                            <ZeroFee as alloy_sol_types::SolError>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                    }
                }
            }
            ///Container for all the [`AerodomeV2Factory`](self) events.
            pub enum AerodomeV2FactoryEvents {
                PoolCreated(PoolCreated),
                SetCustomFee(SetCustomFee),
                SetFeeManager(SetFeeManager),
                SetPauseState(SetPauseState),
                SetPauser(SetPauser),
                SetVoter(SetVoter),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for AerodomeV2FactoryEvents {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        AerodomeV2FactoryEvents::PoolCreated(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "PoolCreated",
                                &__self_0,
                            )
                        }
                        AerodomeV2FactoryEvents::SetCustomFee(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "SetCustomFee",
                                &__self_0,
                            )
                        }
                        AerodomeV2FactoryEvents::SetFeeManager(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "SetFeeManager",
                                &__self_0,
                            )
                        }
                        AerodomeV2FactoryEvents::SetPauseState(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "SetPauseState",
                                &__self_0,
                            )
                        }
                        AerodomeV2FactoryEvents::SetPauser(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "SetPauser",
                                &__self_0,
                            )
                        }
                        AerodomeV2FactoryEvents::SetVoter(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "SetVoter",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl AerodomeV2FactoryEvents {
                /// All the selectors of this enum.
                ///
                /// Note that the selectors might not be in the same order as the variants.
                /// No guarantees are made about the order of the selectors.
                ///
                /// Prefer using `SolInterface` methods instead.
                pub const SELECTORS: &'static [[u8; 32usize]] = &[
                    [
                        13u8,
                        118u8,
                        83u8,
                        142u8,
                        252u8,
                        64u8,
                        131u8,
                        24u8,
                        160u8,
                        81u8,
                        19u8,
                        124u8,
                        39u8,
                        32u8,
                        169u8,
                        232u8,
                        41u8,
                        2u8,
                        172u8,
                        219u8,
                        212u8,
                        107u8,
                        128u8,
                        45u8,
                        72u8,
                        139u8,
                        116u8,
                        202u8,
                        58u8,
                        9u8,
                        161u8,
                        22u8,
                    ],
                    [
                        33u8,
                        40u8,
                        216u8,
                        141u8,
                        20u8,
                        200u8,
                        12u8,
                        176u8,
                        129u8,
                        193u8,
                        37u8,
                        42u8,
                        90u8,
                        207u8,
                        247u8,
                        162u8,
                        100u8,
                        103u8,
                        27u8,
                        241u8,
                        153u8,
                        206u8,
                        34u8,
                        107u8,
                        83u8,
                        120u8,
                        143u8,
                        178u8,
                        96u8,
                        101u8,
                        0u8,
                        94u8,
                    ],
                    [
                        93u8,
                        5u8,
                        23u8,
                        227u8,
                        164u8,
                        234u8,
                        190u8,
                        168u8,
                        146u8,
                        217u8,
                        117u8,
                        1u8,
                        56u8,
                        205u8,
                        33u8,
                        212u8,
                        166u8,
                        207u8,
                        59u8,
                        147u8,
                        91u8,
                        67u8,
                        208u8,
                        89u8,
                        141u8,
                        247u8,
                        5u8,
                        95u8,
                        70u8,
                        56u8,
                        25u8,
                        178u8,
                    ],
                    [
                        174u8,
                        70u8,
                        140u8,
                        229u8,
                        134u8,
                        249u8,
                        168u8,
                        118u8,
                        96u8,
                        253u8,
                        255u8,
                        193u8,
                        68u8,
                        140u8,
                        238u8,
                        148u8,
                        32u8,
                        66u8,
                        193u8,
                        106u8,
                        226u8,
                        240u8,
                        32u8,
                        70u8,
                        177u8,
                        52u8,
                        181u8,
                        34u8,
                        79u8,
                        49u8,
                        147u8,
                        107u8,
                    ],
                    [
                        198u8,
                        255u8,
                        18u8,
                        116u8,
                        51u8,
                        183u8,
                        133u8,
                        197u8,
                        29u8,
                        169u8,
                        174u8,
                        64u8,
                        136u8,
                        238u8,
                        24u8,
                        76u8,
                        144u8,
                        155u8,
                        26u8,
                        85u8,
                        185u8,
                        175u8,
                        216u8,
                        42u8,
                        230u8,
                        198u8,
                        66u8,
                        36u8,
                        211u8,
                        188u8,
                        21u8,
                        210u8,
                    ],
                    [
                        224u8,
                        46u8,
                        251u8,
                        158u8,
                        143u8,
                        15u8,
                        194u8,
                        21u8,
                        70u8,
                        115u8,
                        10u8,
                        179u8,
                        45u8,
                        89u8,
                        79u8,
                        98u8,
                        213u8,
                        134u8,
                        225u8,
                        187u8,
                        177u8,
                        91u8,
                        181u8,
                        4u8,
                        94u8,
                        221u8,
                        11u8,
                        24u8,
                        120u8,
                        167u8,
                        123u8,
                        53u8,
                    ],
                ];
            }
            #[automatically_derived]
            impl alloy_sol_types::SolEventInterface for AerodomeV2FactoryEvents {
                const NAME: &'static str = "AerodomeV2FactoryEvents";
                const COUNT: usize = 6usize;
                fn decode_raw_log(
                    topics: &[alloy_sol_types::Word],
                    data: &[u8],
                    validate: bool,
                ) -> alloy_sol_types::Result<Self> {
                    match topics.first().copied() {
                        Some(
                            <PoolCreated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                        ) => {
                            <PoolCreated as alloy_sol_types::SolEvent>::decode_raw_log(
                                    topics,
                                    data,
                                    validate,
                                )
                                .map(Self::PoolCreated)
                        }
                        Some(
                            <SetCustomFee as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                        ) => {
                            <SetCustomFee as alloy_sol_types::SolEvent>::decode_raw_log(
                                    topics,
                                    data,
                                    validate,
                                )
                                .map(Self::SetCustomFee)
                        }
                        Some(
                            <SetFeeManager as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                        ) => {
                            <SetFeeManager as alloy_sol_types::SolEvent>::decode_raw_log(
                                    topics,
                                    data,
                                    validate,
                                )
                                .map(Self::SetFeeManager)
                        }
                        Some(
                            <SetPauseState as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                        ) => {
                            <SetPauseState as alloy_sol_types::SolEvent>::decode_raw_log(
                                    topics,
                                    data,
                                    validate,
                                )
                                .map(Self::SetPauseState)
                        }
                        Some(
                            <SetPauser as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                        ) => {
                            <SetPauser as alloy_sol_types::SolEvent>::decode_raw_log(
                                    topics,
                                    data,
                                    validate,
                                )
                                .map(Self::SetPauser)
                        }
                        Some(<SetVoter as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                            <SetVoter as alloy_sol_types::SolEvent>::decode_raw_log(
                                    topics,
                                    data,
                                    validate,
                                )
                                .map(Self::SetVoter)
                        }
                        _ => {
                            alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                                name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                                log: alloy_sol_types::private::Box::new(
                                    alloy_sol_types::private::LogData::new_unchecked(
                                        topics.to_vec(),
                                        data.to_vec().into(),
                                    ),
                                ),
                            })
                        }
                    }
                }
            }
            #[automatically_derived]
            impl alloy_sol_types::private::IntoLogData for AerodomeV2FactoryEvents {
                fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                    match self {
                        Self::PoolCreated(inner) => {
                            alloy_sol_types::private::IntoLogData::to_log_data(inner)
                        }
                        Self::SetCustomFee(inner) => {
                            alloy_sol_types::private::IntoLogData::to_log_data(inner)
                        }
                        Self::SetFeeManager(inner) => {
                            alloy_sol_types::private::IntoLogData::to_log_data(inner)
                        }
                        Self::SetPauseState(inner) => {
                            alloy_sol_types::private::IntoLogData::to_log_data(inner)
                        }
                        Self::SetPauser(inner) => {
                            alloy_sol_types::private::IntoLogData::to_log_data(inner)
                        }
                        Self::SetVoter(inner) => {
                            alloy_sol_types::private::IntoLogData::to_log_data(inner)
                        }
                    }
                }
                fn into_log_data(self) -> alloy_sol_types::private::LogData {
                    match self {
                        Self::PoolCreated(inner) => {
                            alloy_sol_types::private::IntoLogData::into_log_data(inner)
                        }
                        Self::SetCustomFee(inner) => {
                            alloy_sol_types::private::IntoLogData::into_log_data(inner)
                        }
                        Self::SetFeeManager(inner) => {
                            alloy_sol_types::private::IntoLogData::into_log_data(inner)
                        }
                        Self::SetPauseState(inner) => {
                            alloy_sol_types::private::IntoLogData::into_log_data(inner)
                        }
                        Self::SetPauser(inner) => {
                            alloy_sol_types::private::IntoLogData::into_log_data(inner)
                        }
                        Self::SetVoter(inner) => {
                            alloy_sol_types::private::IntoLogData::into_log_data(inner)
                        }
                    }
                }
            }
            use ::alloy::contract as alloy_contract;
            /**Creates a new wrapper around an on-chain [`AerodomeV2Factory`](self) contract instance.

See the [wrapper's documentation](`AerodomeV2FactoryInstance`) for more details.*/
            #[inline]
            pub const fn new<
                T: alloy_contract::private::Transport + ::core::clone::Clone,
                P: alloy_contract::private::Provider<T, N>,
                N: alloy_contract::private::Network,
            >(
                address: alloy_sol_types::private::Address,
                provider: P,
            ) -> AerodomeV2FactoryInstance<T, P, N> {
                AerodomeV2FactoryInstance::<T, P, N>::new(address, provider)
            }
            /**A [`AerodomeV2Factory`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`AerodomeV2Factory`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
            pub struct AerodomeV2FactoryInstance<
                T,
                P,
                N = alloy_contract::private::Ethereum,
            > {
                address: alloy_sol_types::private::Address,
                provider: P,
                _network_transport: ::core::marker::PhantomData<(N, T)>,
            }
            #[automatically_derived]
            impl<
                T: ::core::clone::Clone,
                P: ::core::clone::Clone,
                N: ::core::clone::Clone,
            > ::core::clone::Clone for AerodomeV2FactoryInstance<T, P, N> {
                #[inline]
                fn clone(&self) -> AerodomeV2FactoryInstance<T, P, N> {
                    AerodomeV2FactoryInstance {
                        address: ::core::clone::Clone::clone(&self.address),
                        provider: ::core::clone::Clone::clone(&self.provider),
                        _network_transport: ::core::clone::Clone::clone(
                            &self._network_transport,
                        ),
                    }
                }
            }
            #[automatically_derived]
            impl<T, P, N> ::core::fmt::Debug for AerodomeV2FactoryInstance<T, P, N> {
                #[inline]
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_tuple("AerodomeV2FactoryInstance")
                        .field(&self.address)
                        .finish()
                }
            }
            /// Instantiation and getters/setters.
            #[automatically_derived]
            impl<
                T: alloy_contract::private::Transport + ::core::clone::Clone,
                P: alloy_contract::private::Provider<T, N>,
                N: alloy_contract::private::Network,
            > AerodomeV2FactoryInstance<T, P, N> {
                /**Creates a new wrapper around an on-chain [`AerodomeV2Factory`](self) contract instance.

See the [wrapper's documentation](`AerodomeV2FactoryInstance`) for more details.*/
                #[inline]
                pub const fn new(
                    address: alloy_sol_types::private::Address,
                    provider: P,
                ) -> Self {
                    Self {
                        address,
                        provider,
                        _network_transport: ::core::marker::PhantomData,
                    }
                }
                /// Returns a reference to the address.
                #[inline]
                pub const fn address(&self) -> &alloy_sol_types::private::Address {
                    &self.address
                }
                /// Sets the address.
                #[inline]
                pub fn set_address(
                    &mut self,
                    address: alloy_sol_types::private::Address,
                ) {
                    self.address = address;
                }
                /// Sets the address and returns `self`.
                pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
                    self.set_address(address);
                    self
                }
                /// Returns a reference to the provider.
                #[inline]
                pub const fn provider(&self) -> &P {
                    &self.provider
                }
            }
            impl<T, P: ::core::clone::Clone, N> AerodomeV2FactoryInstance<T, &P, N> {
                /// Clones the provider and returns a new instance with the cloned provider.
                #[inline]
                pub fn with_cloned_provider(self) -> AerodomeV2FactoryInstance<T, P, N> {
                    AerodomeV2FactoryInstance {
                        address: self.address,
                        provider: ::core::clone::Clone::clone(&self.provider),
                        _network_transport: ::core::marker::PhantomData,
                    }
                }
            }
            /// Function calls.
            #[automatically_derived]
            impl<
                T: alloy_contract::private::Transport + ::core::clone::Clone,
                P: alloy_contract::private::Provider<T, N>,
                N: alloy_contract::private::Network,
            > AerodomeV2FactoryInstance<T, P, N> {
                /// Creates a new call builder using this contract instance's provider and address.
                ///
                /// Note that the call can be any function call, not just those defined in this
                /// contract. Prefer using the other methods for building type-safe contract calls.
                pub fn call_builder<C: alloy_sol_types::SolCall>(
                    &self,
                    call: &C,
                ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
                    alloy_contract::SolCallBuilder::new_sol(
                        &self.provider,
                        &self.address,
                        call,
                    )
                }
                ///Creates a new call builder for the [`MAX_FEE`] function.
                pub fn MAX_FEE(
                    &self,
                ) -> alloy_contract::SolCallBuilder<T, &P, MAX_FEECall, N> {
                    self.call_builder(&MAX_FEECall {})
                }
                ///Creates a new call builder for the [`ZERO_FEE_INDICATOR`] function.
                pub fn ZERO_FEE_INDICATOR(
                    &self,
                ) -> alloy_contract::SolCallBuilder<T, &P, ZERO_FEE_INDICATORCall, N> {
                    self.call_builder(&ZERO_FEE_INDICATORCall {})
                }
                ///Creates a new call builder for the [`allPools`] function.
                pub fn allPools(
                    &self,
                    _0: ::alloy::sol_types::private::U256,
                ) -> alloy_contract::SolCallBuilder<T, &P, allPoolsCall, N> {
                    self.call_builder(&allPoolsCall { _0 })
                }
                ///Creates a new call builder for the [`allPoolsLength`] function.
                pub fn allPoolsLength(
                    &self,
                ) -> alloy_contract::SolCallBuilder<T, &P, allPoolsLengthCall, N> {
                    self.call_builder(&allPoolsLengthCall {})
                }
                ///Creates a new call builder for the [`createPool_0`] function.
                pub fn createPool_0(
                    &self,
                    tokenA: ::alloy::sol_types::private::Address,
                    tokenB: ::alloy::sol_types::private::Address,
                    stable: bool,
                ) -> alloy_contract::SolCallBuilder<T, &P, createPool_0Call, N> {
                    self.call_builder(
                        &createPool_0Call {
                            tokenA,
                            tokenB,
                            stable,
                        },
                    )
                }
                ///Creates a new call builder for the [`createPool_1`] function.
                pub fn createPool_1(
                    &self,
                    tokenA: ::alloy::sol_types::private::Address,
                    tokenB: ::alloy::sol_types::private::Address,
                    fee: <::alloy::sol_types::sol_data::Uint<
                        24,
                    > as ::alloy::sol_types::SolType>::RustType,
                ) -> alloy_contract::SolCallBuilder<T, &P, createPool_1Call, N> {
                    self.call_builder(
                        &createPool_1Call {
                            tokenA,
                            tokenB,
                            fee,
                        },
                    )
                }
                ///Creates a new call builder for the [`customFee`] function.
                pub fn customFee(
                    &self,
                    _0: ::alloy::sol_types::private::Address,
                ) -> alloy_contract::SolCallBuilder<T, &P, customFeeCall, N> {
                    self.call_builder(&customFeeCall { _0 })
                }
                ///Creates a new call builder for the [`feeManager`] function.
                pub fn feeManager(
                    &self,
                ) -> alloy_contract::SolCallBuilder<T, &P, feeManagerCall, N> {
                    self.call_builder(&feeManagerCall {})
                }
                ///Creates a new call builder for the [`getFee`] function.
                pub fn getFee(
                    &self,
                    pool: ::alloy::sol_types::private::Address,
                    _stable: bool,
                ) -> alloy_contract::SolCallBuilder<T, &P, getFeeCall, N> {
                    self.call_builder(&getFeeCall { pool, _stable })
                }
                ///Creates a new call builder for the [`getPool_0`] function.
                pub fn getPool_0(
                    &self,
                    tokenA: ::alloy::sol_types::private::Address,
                    tokenB: ::alloy::sol_types::private::Address,
                    fee: <::alloy::sol_types::sol_data::Uint<
                        24,
                    > as ::alloy::sol_types::SolType>::RustType,
                ) -> alloy_contract::SolCallBuilder<T, &P, getPool_0Call, N> {
                    self.call_builder(
                        &getPool_0Call {
                            tokenA,
                            tokenB,
                            fee,
                        },
                    )
                }
                ///Creates a new call builder for the [`getPool_1`] function.
                pub fn getPool_1(
                    &self,
                    tokenA: ::alloy::sol_types::private::Address,
                    tokenB: ::alloy::sol_types::private::Address,
                    stable: bool,
                ) -> alloy_contract::SolCallBuilder<T, &P, getPool_1Call, N> {
                    self.call_builder(
                        &getPool_1Call {
                            tokenA,
                            tokenB,
                            stable,
                        },
                    )
                }
                ///Creates a new call builder for the [`implementation`] function.
                pub fn implementation(
                    &self,
                ) -> alloy_contract::SolCallBuilder<T, &P, implementationCall, N> {
                    self.call_builder(&implementationCall {})
                }
                ///Creates a new call builder for the [`isPaused`] function.
                pub fn isPaused(
                    &self,
                ) -> alloy_contract::SolCallBuilder<T, &P, isPausedCall, N> {
                    self.call_builder(&isPausedCall {})
                }
                ///Creates a new call builder for the [`isPool`] function.
                pub fn isPool(
                    &self,
                    pool: ::alloy::sol_types::private::Address,
                ) -> alloy_contract::SolCallBuilder<T, &P, isPoolCall, N> {
                    self.call_builder(&isPoolCall { pool })
                }
                ///Creates a new call builder for the [`pauser`] function.
                pub fn pauser(
                    &self,
                ) -> alloy_contract::SolCallBuilder<T, &P, pauserCall, N> {
                    self.call_builder(&pauserCall {})
                }
                ///Creates a new call builder for the [`setCustomFee`] function.
                pub fn setCustomFee(
                    &self,
                    pool: ::alloy::sol_types::private::Address,
                    fee: ::alloy::sol_types::private::U256,
                ) -> alloy_contract::SolCallBuilder<T, &P, setCustomFeeCall, N> {
                    self.call_builder(&setCustomFeeCall { pool, fee })
                }
                ///Creates a new call builder for the [`setFee`] function.
                pub fn setFee(
                    &self,
                    _stable: bool,
                    _fee: ::alloy::sol_types::private::U256,
                ) -> alloy_contract::SolCallBuilder<T, &P, setFeeCall, N> {
                    self.call_builder(&setFeeCall { _stable, _fee })
                }
                ///Creates a new call builder for the [`setFeeManager`] function.
                pub fn setFeeManager(
                    &self,
                    _feeManager: ::alloy::sol_types::private::Address,
                ) -> alloy_contract::SolCallBuilder<T, &P, setFeeManagerCall, N> {
                    self.call_builder(&setFeeManagerCall { _feeManager })
                }
                ///Creates a new call builder for the [`setPauseState`] function.
                pub fn setPauseState(
                    &self,
                    _state: bool,
                ) -> alloy_contract::SolCallBuilder<T, &P, setPauseStateCall, N> {
                    self.call_builder(&setPauseStateCall { _state })
                }
                ///Creates a new call builder for the [`setPauser`] function.
                pub fn setPauser(
                    &self,
                    _pauser: ::alloy::sol_types::private::Address,
                ) -> alloy_contract::SolCallBuilder<T, &P, setPauserCall, N> {
                    self.call_builder(&setPauserCall { _pauser })
                }
                ///Creates a new call builder for the [`setVoter`] function.
                pub fn setVoter(
                    &self,
                    _voter: ::alloy::sol_types::private::Address,
                ) -> alloy_contract::SolCallBuilder<T, &P, setVoterCall, N> {
                    self.call_builder(&setVoterCall { _voter })
                }
                ///Creates a new call builder for the [`stableFee`] function.
                pub fn stableFee(
                    &self,
                ) -> alloy_contract::SolCallBuilder<T, &P, stableFeeCall, N> {
                    self.call_builder(&stableFeeCall {})
                }
                ///Creates a new call builder for the [`volatileFee`] function.
                pub fn volatileFee(
                    &self,
                ) -> alloy_contract::SolCallBuilder<T, &P, volatileFeeCall, N> {
                    self.call_builder(&volatileFeeCall {})
                }
                ///Creates a new call builder for the [`voter`] function.
                pub fn voter(
                    &self,
                ) -> alloy_contract::SolCallBuilder<T, &P, voterCall, N> {
                    self.call_builder(&voterCall {})
                }
            }
            /// Event filters.
            #[automatically_derived]
            impl<
                T: alloy_contract::private::Transport + ::core::clone::Clone,
                P: alloy_contract::private::Provider<T, N>,
                N: alloy_contract::private::Network,
            > AerodomeV2FactoryInstance<T, P, N> {
                /// Creates a new event filter using this contract instance's provider and address.
                ///
                /// Note that the type can be any event, not just those defined in this contract.
                /// Prefer using the other methods for building type-safe event filters.
                pub fn event_filter<E: alloy_sol_types::SolEvent>(
                    &self,
                ) -> alloy_contract::Event<T, &P, E, N> {
                    alloy_contract::Event::new_sol(&self.provider, &self.address)
                }
                ///Creates a new event filter for the [`PoolCreated`] event.
                pub fn PoolCreated_filter(
                    &self,
                ) -> alloy_contract::Event<T, &P, PoolCreated, N> {
                    self.event_filter::<PoolCreated>()
                }
                ///Creates a new event filter for the [`SetCustomFee`] event.
                pub fn SetCustomFee_filter(
                    &self,
                ) -> alloy_contract::Event<T, &P, SetCustomFee, N> {
                    self.event_filter::<SetCustomFee>()
                }
                ///Creates a new event filter for the [`SetFeeManager`] event.
                pub fn SetFeeManager_filter(
                    &self,
                ) -> alloy_contract::Event<T, &P, SetFeeManager, N> {
                    self.event_filter::<SetFeeManager>()
                }
                ///Creates a new event filter for the [`SetPauseState`] event.
                pub fn SetPauseState_filter(
                    &self,
                ) -> alloy_contract::Event<T, &P, SetPauseState, N> {
                    self.event_filter::<SetPauseState>()
                }
                ///Creates a new event filter for the [`SetPauser`] event.
                pub fn SetPauser_filter(
                    &self,
                ) -> alloy_contract::Event<T, &P, SetPauser, N> {
                    self.event_filter::<SetPauser>()
                }
                ///Creates a new event filter for the [`SetVoter`] event.
                pub fn SetVoter_filter(
                    &self,
                ) -> alloy_contract::Event<T, &P, SetVoter, N> {
                    self.event_filter::<SetVoter>()
                }
            }
        }
        const _: &'static [u8] = b"[\n    {\n        \"constant\": true,\n        \"inputs\": [],\n        \"name\": \"name\",\n        \"outputs\": [\n            {\n                \"name\": \"\",\n                \"type\": \"string\"\n            }\n        ],\n        \"payable\": false,\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"constant\": false,\n        \"inputs\": [\n            {\n                \"name\": \"_spender\",\n                \"type\": \"address\"\n            },\n            {\n                \"name\": \"_value\",\n                \"type\": \"uint256\"\n            }\n        ],\n        \"name\": \"approve\",\n        \"outputs\": [\n            {\n                \"name\": \"\",\n                \"type\": \"bool\"\n            }\n        ],\n        \"payable\": false,\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"constant\": true,\n        \"inputs\": [],\n        \"name\": \"totalSupply\",\n        \"outputs\": [\n            {\n                \"name\": \"\",\n                \"type\": \"uint256\"\n            }\n        ],\n        \"payable\": false,\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"constant\": false,\n        \"inputs\": [\n            {\n                \"name\": \"_from\",\n                \"type\": \"address\"\n            },\n            {\n                \"name\": \"_to\",\n                \"type\": \"address\"\n            },\n            {\n                \"name\": \"_value\",\n                \"type\": \"uint256\"\n            }\n        ],\n        \"name\": \"transferFrom\",\n        \"outputs\": [\n            {\n                \"name\": \"\",\n                \"type\": \"bool\"\n            }\n        ],\n        \"payable\": false,\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"constant\": true,\n        \"inputs\": [],\n        \"name\": \"decimals\",\n        \"outputs\": [\n            {\n                \"name\": \"\",\n                \"type\": \"uint8\"\n            }\n        ],\n        \"payable\": false,\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"constant\": true,\n        \"inputs\": [\n            {\n                \"name\": \"_owner\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"balanceOf\",\n        \"outputs\": [\n            {\n                \"name\": \"balance\",\n                \"type\": \"uint256\"\n            }\n        ],\n        \"payable\": false,\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"constant\": true,\n        \"inputs\": [],\n        \"name\": \"symbol\",\n        \"outputs\": [\n            {\n                \"name\": \"\",\n                \"type\": \"string\"\n            }\n        ],\n        \"payable\": false,\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"constant\": false,\n        \"inputs\": [\n            {\n                \"name\": \"_to\",\n                \"type\": \"address\"\n            },\n            {\n                \"name\": \"_value\",\n                \"type\": \"uint256\"\n            }\n        ],\n        \"name\": \"transfer\",\n        \"outputs\": [\n            {\n                \"name\": \"\",\n                \"type\": \"bool\"\n            }\n        ],\n        \"payable\": false,\n        \"stateMutability\": \"nonpayable\",\n        \"type\": \"function\"\n    },\n    {\n        \"constant\": true,\n        \"inputs\": [\n            {\n                \"name\": \"_owner\",\n                \"type\": \"address\"\n            },\n            {\n                \"name\": \"_spender\",\n                \"type\": \"address\"\n            }\n        ],\n        \"name\": \"allowance\",\n        \"outputs\": [\n            {\n                \"name\": \"\",\n                \"type\": \"uint256\"\n            }\n        ],\n        \"payable\": false,\n        \"stateMutability\": \"view\",\n        \"type\": \"function\"\n    },\n    {\n        \"payable\": true,\n        \"stateMutability\": \"payable\",\n        \"type\": \"fallback\"\n    },\n    {\n        \"anonymous\": false,\n        \"inputs\": [\n            {\n                \"indexed\": true,\n                \"name\": \"owner\",\n                \"type\": \"address\"\n            },\n            {\n                \"indexed\": true,\n                \"name\": \"spender\",\n                \"type\": \"address\"\n            },\n            {\n                \"indexed\": false,\n                \"name\": \"value\",\n                \"type\": \"uint256\"\n            }\n        ],\n        \"name\": \"Approval\",\n        \"type\": \"event\"\n    },\n    {\n        \"anonymous\": false,\n        \"inputs\": [\n            {\n                \"indexed\": true,\n                \"name\": \"from\",\n                \"type\": \"address\"\n            },\n            {\n                \"indexed\": true,\n                \"name\": \"to\",\n                \"type\": \"address\"\n            },\n            {\n                \"indexed\": false,\n                \"name\": \"value\",\n                \"type\": \"uint256\"\n            }\n        ],\n        \"name\": \"Transfer\",\n        \"type\": \"event\"\n    }\n]";
        /**

Generated by the following Solidity interface...
```solidity
interface ERC20 {
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);

    fallback() external payable;

    function allowance(address _owner, address _spender) external view returns (uint256);
    function approve(address _spender, uint256 _value) external returns (bool);
    function balanceOf(address _owner) external view returns (uint256 balance);
    function decimals() external view returns (uint8);
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function totalSupply() external view returns (uint256);
    function transfer(address _to, uint256 _value) external returns (bool);
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "fallback",
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "allowance",
    "inputs": [
      {
        "name": "_owner",
        "type": "address"
      },
      {
        "name": "_spender",
        "type": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "approve",
    "inputs": [
      {
        "name": "_spender",
        "type": "address"
      },
      {
        "name": "_value",
        "type": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "balanceOf",
    "inputs": [
      {
        "name": "_owner",
        "type": "address"
      }
    ],
    "outputs": [
      {
        "name": "balance",
        "type": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "decimals",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint8"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "name",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "symbol",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "totalSupply",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "transfer",
    "inputs": [
      {
        "name": "_to",
        "type": "address"
      },
      {
        "name": "_value",
        "type": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "transferFrom",
    "inputs": [
      {
        "name": "_from",
        "type": "address"
      },
      {
        "name": "_to",
        "type": "address"
      },
      {
        "name": "_value",
        "type": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "Approval",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "indexed": true
      },
      {
        "name": "spender",
        "type": "address",
        "indexed": true
      },
      {
        "name": "value",
        "type": "uint256",
        "indexed": false
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Transfer",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "indexed": true
      },
      {
        "name": "to",
        "type": "address",
        "indexed": true
      },
      {
        "name": "value",
        "type": "uint256",
        "indexed": false
      }
    ],
    "anonymous": false
  }
]
```*/
        #[allow(non_camel_case_types, non_snake_case, clippy::style)]
        pub mod ERC20 {
            use super::*;
            use ::alloy::sol_types as alloy_sol_types;
            /**Event with signature `Approval(address,address,uint256)` and selector `0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925`.
```solidity
event Approval(address indexed owner, address indexed spender, uint256 value);
```*/
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            pub struct Approval {
                #[allow(missing_docs)]
                pub owner: ::alloy::sol_types::private::Address,
                #[allow(missing_docs)]
                pub spender: ::alloy::sol_types::private::Address,
                #[allow(missing_docs)]
                pub value: ::alloy::sol_types::private::U256,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            impl ::core::clone::Clone for Approval {
                #[inline]
                fn clone(&self) -> Approval {
                    Approval {
                        owner: ::core::clone::Clone::clone(&self.owner),
                        spender: ::core::clone::Clone::clone(&self.spender),
                        value: ::core::clone::Clone::clone(&self.value),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            impl ::core::fmt::Debug for Approval {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Approval",
                        "owner",
                        &self.owner,
                        "spender",
                        &self.spender,
                        "value",
                        &&self.value,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                #[automatically_derived]
                impl alloy_sol_types::SolEvent for Approval {
                    type DataTuple<'a> = (::alloy::sol_types::sol_data::Uint<256>,);
                    type DataToken<'a> = <Self::DataTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type TopicList = (
                        alloy_sol_types::sol_data::FixedBytes<32>,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                    );
                    const SIGNATURE: &'static str = "Approval(address,address,uint256)";
                    const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                        140u8,
                        91u8,
                        225u8,
                        229u8,
                        235u8,
                        236u8,
                        125u8,
                        91u8,
                        209u8,
                        79u8,
                        113u8,
                        66u8,
                        125u8,
                        30u8,
                        132u8,
                        243u8,
                        221u8,
                        3u8,
                        20u8,
                        192u8,
                        247u8,
                        178u8,
                        41u8,
                        30u8,
                        91u8,
                        32u8,
                        10u8,
                        200u8,
                        199u8,
                        195u8,
                        185u8,
                        37u8,
                    ]);
                    const ANONYMOUS: bool = false;
                    #[allow(unused_variables)]
                    #[inline]
                    fn new(
                        topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                        data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        Self {
                            owner: topics.1,
                            spender: topics.2,
                            value: data.0,
                        }
                    }
                    #[inline]
                    fn tokenize_body(&self) -> Self::DataToken<'_> {
                        (
                            <::alloy::sol_types::sol_data::Uint<
                                256,
                            > as alloy_sol_types::SolType>::tokenize(&self.value),
                        )
                    }
                    #[inline]
                    fn topics(
                        &self,
                    ) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                        (
                            Self::SIGNATURE_HASH.into(),
                            self.owner.clone(),
                            self.spender.clone(),
                        )
                    }
                    #[inline]
                    fn encode_topics_raw(
                        &self,
                        out: &mut [alloy_sol_types::abi::token::WordToken],
                    ) -> alloy_sol_types::Result<()> {
                        if out.len()
                            < <Self::TopicList as alloy_sol_types::TopicList>::COUNT
                        {
                            return Err(alloy_sol_types::Error::Overrun);
                        }
                        out[0usize] = alloy_sol_types::abi::token::WordToken(
                            Self::SIGNATURE_HASH,
                        );
                        out[1usize] = <::alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                            &self.owner,
                        );
                        out[2usize] = <::alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                            &self.spender,
                        );
                        Ok(())
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::private::IntoLogData for Approval {
                    fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                        From::from(self)
                    }
                    fn into_log_data(self) -> alloy_sol_types::private::LogData {
                        From::from(&self)
                    }
                }
                #[automatically_derived]
                impl From<&Approval> for alloy_sol_types::private::LogData {
                    #[inline]
                    fn from(this: &Approval) -> alloy_sol_types::private::LogData {
                        alloy_sol_types::SolEvent::encode_log_data(this)
                    }
                }
            };
            /**Event with signature `Transfer(address,address,uint256)` and selector `0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef`.
```solidity
event Transfer(address indexed from, address indexed to, uint256 value);
```*/
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            pub struct Transfer {
                #[allow(missing_docs)]
                pub from: ::alloy::sol_types::private::Address,
                #[allow(missing_docs)]
                pub to: ::alloy::sol_types::private::Address,
                #[allow(missing_docs)]
                pub value: ::alloy::sol_types::private::U256,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            impl ::core::clone::Clone for Transfer {
                #[inline]
                fn clone(&self) -> Transfer {
                    Transfer {
                        from: ::core::clone::Clone::clone(&self.from),
                        to: ::core::clone::Clone::clone(&self.to),
                        value: ::core::clone::Clone::clone(&self.value),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            impl ::core::fmt::Debug for Transfer {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Transfer",
                        "from",
                        &self.from,
                        "to",
                        &self.to,
                        "value",
                        &&self.value,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                #[automatically_derived]
                impl alloy_sol_types::SolEvent for Transfer {
                    type DataTuple<'a> = (::alloy::sol_types::sol_data::Uint<256>,);
                    type DataToken<'a> = <Self::DataTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type TopicList = (
                        alloy_sol_types::sol_data::FixedBytes<32>,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                    );
                    const SIGNATURE: &'static str = "Transfer(address,address,uint256)";
                    const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                        221u8,
                        242u8,
                        82u8,
                        173u8,
                        27u8,
                        226u8,
                        200u8,
                        155u8,
                        105u8,
                        194u8,
                        176u8,
                        104u8,
                        252u8,
                        55u8,
                        141u8,
                        170u8,
                        149u8,
                        43u8,
                        167u8,
                        241u8,
                        99u8,
                        196u8,
                        161u8,
                        22u8,
                        40u8,
                        245u8,
                        90u8,
                        77u8,
                        245u8,
                        35u8,
                        179u8,
                        239u8,
                    ]);
                    const ANONYMOUS: bool = false;
                    #[allow(unused_variables)]
                    #[inline]
                    fn new(
                        topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                        data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        Self {
                            from: topics.1,
                            to: topics.2,
                            value: data.0,
                        }
                    }
                    #[inline]
                    fn tokenize_body(&self) -> Self::DataToken<'_> {
                        (
                            <::alloy::sol_types::sol_data::Uint<
                                256,
                            > as alloy_sol_types::SolType>::tokenize(&self.value),
                        )
                    }
                    #[inline]
                    fn topics(
                        &self,
                    ) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                        (Self::SIGNATURE_HASH.into(), self.from.clone(), self.to.clone())
                    }
                    #[inline]
                    fn encode_topics_raw(
                        &self,
                        out: &mut [alloy_sol_types::abi::token::WordToken],
                    ) -> alloy_sol_types::Result<()> {
                        if out.len()
                            < <Self::TopicList as alloy_sol_types::TopicList>::COUNT
                        {
                            return Err(alloy_sol_types::Error::Overrun);
                        }
                        out[0usize] = alloy_sol_types::abi::token::WordToken(
                            Self::SIGNATURE_HASH,
                        );
                        out[1usize] = <::alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                            &self.from,
                        );
                        out[2usize] = <::alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                            &self.to,
                        );
                        Ok(())
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::private::IntoLogData for Transfer {
                    fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                        From::from(self)
                    }
                    fn into_log_data(self) -> alloy_sol_types::private::LogData {
                        From::from(&self)
                    }
                }
                #[automatically_derived]
                impl From<&Transfer> for alloy_sol_types::private::LogData {
                    #[inline]
                    fn from(this: &Transfer) -> alloy_sol_types::private::LogData {
                        alloy_sol_types::SolEvent::encode_log_data(this)
                    }
                }
            };
            /**Function with signature `allowance(address,address)` and selector `0xdd62ed3e`.
```solidity
function allowance(address _owner, address _spender) external view returns (uint256);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct allowanceCall {
                pub _owner: ::alloy::sol_types::private::Address,
                pub _spender: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for allowanceCall {
                #[inline]
                fn clone(&self) -> allowanceCall {
                    allowanceCall {
                        _owner: ::core::clone::Clone::clone(&self._owner),
                        _spender: ::core::clone::Clone::clone(&self._spender),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for allowanceCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "allowanceCall",
                        "_owner",
                        &self._owner,
                        "_spender",
                        &&self._spender,
                    )
                }
            }
            ///Container type for the return parameters of the [`allowance(address,address)`](allowanceCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct allowanceReturn {
                pub _0: ::alloy::sol_types::private::U256,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for allowanceReturn {
                #[inline]
                fn clone(&self) -> allowanceReturn {
                    allowanceReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for allowanceReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "allowanceReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<allowanceCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: allowanceCall) -> Self {
                            (value._owner, value._spender)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for allowanceCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {
                                _owner: tuple.0,
                                _spender: tuple.1,
                            }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Uint<256>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (::alloy::sol_types::private::U256,);
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<allowanceReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: allowanceReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for allowanceReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for allowanceCall {
                    type Parameters<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                    );
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = allowanceReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Uint<256>,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "allowance(address,address)";
                    const SELECTOR: [u8; 4] = [221u8, 98u8, 237u8, 62u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self._owner,
                            ),
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self._spender,
                            ),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `approve(address,uint256)` and selector `0x095ea7b3`.
```solidity
function approve(address _spender, uint256 _value) external returns (bool);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct approveCall {
                pub _spender: ::alloy::sol_types::private::Address,
                pub _value: ::alloy::sol_types::private::U256,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for approveCall {
                #[inline]
                fn clone(&self) -> approveCall {
                    approveCall {
                        _spender: ::core::clone::Clone::clone(&self._spender),
                        _value: ::core::clone::Clone::clone(&self._value),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for approveCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "approveCall",
                        "_spender",
                        &self._spender,
                        "_value",
                        &&self._value,
                    )
                }
            }
            ///Container type for the return parameters of the [`approve(address,uint256)`](approveCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct approveReturn {
                pub _0: bool,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for approveReturn {
                #[inline]
                fn clone(&self) -> approveReturn {
                    approveReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for approveReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "approveReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Uint<256>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                        ::alloy::sol_types::private::U256,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<approveCall> for UnderlyingRustTuple<'_> {
                        fn from(value: approveCall) -> Self {
                            (value._spender, value._value)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>> for approveCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {
                                _spender: tuple.0,
                                _value: tuple.1,
                            }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (::alloy::sol_types::sol_data::Bool,);
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (bool,);
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<approveReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: approveReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for approveReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for approveCall {
                    type Parameters<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Uint<256>,
                    );
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = approveReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Bool,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "approve(address,uint256)";
                    const SELECTOR: [u8; 4] = [9u8, 94u8, 167u8, 179u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self._spender,
                            ),
                            <::alloy::sol_types::sol_data::Uint<
                                256,
                            > as alloy_sol_types::SolType>::tokenize(&self._value),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `balanceOf(address)` and selector `0x70a08231`.
```solidity
function balanceOf(address _owner) external view returns (uint256 balance);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct balanceOfCall {
                pub _owner: ::alloy::sol_types::private::Address,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for balanceOfCall {
                #[inline]
                fn clone(&self) -> balanceOfCall {
                    balanceOfCall {
                        _owner: ::core::clone::Clone::clone(&self._owner),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for balanceOfCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "balanceOfCall",
                        "_owner",
                        &&self._owner,
                    )
                }
            }
            ///Container type for the return parameters of the [`balanceOf(address)`](balanceOfCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct balanceOfReturn {
                pub balance: ::alloy::sol_types::private::U256,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for balanceOfReturn {
                #[inline]
                fn clone(&self) -> balanceOfReturn {
                    balanceOfReturn {
                        balance: ::core::clone::Clone::clone(&self.balance),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for balanceOfReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "balanceOfReturn",
                        "balance",
                        &&self.balance,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<balanceOfCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: balanceOfCall) -> Self {
                            (value._owner,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for balanceOfCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _owner: tuple.0 }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Uint<256>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (::alloy::sol_types::private::U256,);
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<balanceOfReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: balanceOfReturn) -> Self {
                            (value.balance,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for balanceOfReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { balance: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for balanceOfCall {
                    type Parameters<'a> = (::alloy::sol_types::sol_data::Address,);
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = balanceOfReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Uint<256>,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "balanceOf(address)";
                    const SELECTOR: [u8; 4] = [112u8, 160u8, 130u8, 49u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self._owner,
                            ),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `decimals()` and selector `0x313ce567`.
```solidity
function decimals() external view returns (uint8);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct decimalsCall {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for decimalsCall {
                #[inline]
                fn clone(&self) -> decimalsCall {
                    decimalsCall {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for decimalsCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "decimalsCall")
                }
            }
            ///Container type for the return parameters of the [`decimals()`](decimalsCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct decimalsReturn {
                pub _0: u8,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for decimalsReturn {
                #[inline]
                fn clone(&self) -> decimalsReturn {
                    decimalsReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for decimalsReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "decimalsReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<decimalsCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: decimalsCall) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for decimalsCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Uint<8>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (u8,);
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<decimalsReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: decimalsReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for decimalsReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for decimalsCall {
                    type Parameters<'a> = ();
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = decimalsReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Uint<8>,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "decimals()";
                    const SELECTOR: [u8; 4] = [49u8, 60u8, 229u8, 103u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `name()` and selector `0x06fdde03`.
```solidity
function name() external view returns (string memory);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct nameCall {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for nameCall {
                #[inline]
                fn clone(&self) -> nameCall {
                    nameCall {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for nameCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "nameCall")
                }
            }
            ///Container type for the return parameters of the [`name()`](nameCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct nameReturn {
                pub _0: ::alloy::sol_types::private::String,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for nameReturn {
                #[inline]
                fn clone(&self) -> nameReturn {
                    nameReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for nameReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "nameReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<nameCall> for UnderlyingRustTuple<'_> {
                        fn from(value: nameCall) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>> for nameCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::String,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::String,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<nameReturn> for UnderlyingRustTuple<'_> {
                        fn from(value: nameReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>> for nameReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for nameCall {
                    type Parameters<'a> = ();
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = nameReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::String,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "name()";
                    const SELECTOR: [u8; 4] = [6u8, 253u8, 222u8, 3u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `symbol()` and selector `0x95d89b41`.
```solidity
function symbol() external view returns (string memory);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct symbolCall {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for symbolCall {
                #[inline]
                fn clone(&self) -> symbolCall {
                    symbolCall {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for symbolCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "symbolCall")
                }
            }
            ///Container type for the return parameters of the [`symbol()`](symbolCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct symbolReturn {
                pub _0: ::alloy::sol_types::private::String,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for symbolReturn {
                #[inline]
                fn clone(&self) -> symbolReturn {
                    symbolReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for symbolReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "symbolReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<symbolCall> for UnderlyingRustTuple<'_> {
                        fn from(value: symbolCall) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>> for symbolCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::String,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::String,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<symbolReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: symbolReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for symbolReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for symbolCall {
                    type Parameters<'a> = ();
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = symbolReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::String,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "symbol()";
                    const SELECTOR: [u8; 4] = [149u8, 216u8, 155u8, 65u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `totalSupply()` and selector `0x18160ddd`.
```solidity
function totalSupply() external view returns (uint256);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct totalSupplyCall {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for totalSupplyCall {
                #[inline]
                fn clone(&self) -> totalSupplyCall {
                    totalSupplyCall {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for totalSupplyCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "totalSupplyCall")
                }
            }
            ///Container type for the return parameters of the [`totalSupply()`](totalSupplyCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct totalSupplyReturn {
                pub _0: ::alloy::sol_types::private::U256,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for totalSupplyReturn {
                #[inline]
                fn clone(&self) -> totalSupplyReturn {
                    totalSupplyReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for totalSupplyReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "totalSupplyReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<totalSupplyCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: totalSupplyCall) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for totalSupplyCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Uint<256>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (::alloy::sol_types::private::U256,);
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<totalSupplyReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: totalSupplyReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for totalSupplyReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for totalSupplyCall {
                    type Parameters<'a> = ();
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = totalSupplyReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Uint<256>,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "totalSupply()";
                    const SELECTOR: [u8; 4] = [24u8, 22u8, 13u8, 221u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `transfer(address,uint256)` and selector `0xa9059cbb`.
```solidity
function transfer(address _to, uint256 _value) external returns (bool);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct transferCall {
                pub _to: ::alloy::sol_types::private::Address,
                pub _value: ::alloy::sol_types::private::U256,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for transferCall {
                #[inline]
                fn clone(&self) -> transferCall {
                    transferCall {
                        _to: ::core::clone::Clone::clone(&self._to),
                        _value: ::core::clone::Clone::clone(&self._value),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for transferCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "transferCall",
                        "_to",
                        &self._to,
                        "_value",
                        &&self._value,
                    )
                }
            }
            ///Container type for the return parameters of the [`transfer(address,uint256)`](transferCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct transferReturn {
                pub _0: bool,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for transferReturn {
                #[inline]
                fn clone(&self) -> transferReturn {
                    transferReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for transferReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "transferReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Uint<256>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                        ::alloy::sol_types::private::U256,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<transferCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: transferCall) -> Self {
                            (value._to, value._value)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for transferCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {
                                _to: tuple.0,
                                _value: tuple.1,
                            }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (::alloy::sol_types::sol_data::Bool,);
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (bool,);
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<transferReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: transferReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for transferReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for transferCall {
                    type Parameters<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Uint<256>,
                    );
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = transferReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Bool,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "transfer(address,uint256)";
                    const SELECTOR: [u8; 4] = [169u8, 5u8, 156u8, 187u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self._to,
                            ),
                            <::alloy::sol_types::sol_data::Uint<
                                256,
                            > as alloy_sol_types::SolType>::tokenize(&self._value),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `transferFrom(address,address,uint256)` and selector `0x23b872dd`.
```solidity
function transferFrom(address _from, address _to, uint256 _value) external returns (bool);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct transferFromCall {
                pub _from: ::alloy::sol_types::private::Address,
                pub _to: ::alloy::sol_types::private::Address,
                pub _value: ::alloy::sol_types::private::U256,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for transferFromCall {
                #[inline]
                fn clone(&self) -> transferFromCall {
                    transferFromCall {
                        _from: ::core::clone::Clone::clone(&self._from),
                        _to: ::core::clone::Clone::clone(&self._to),
                        _value: ::core::clone::Clone::clone(&self._value),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for transferFromCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "transferFromCall",
                        "_from",
                        &self._from,
                        "_to",
                        &self._to,
                        "_value",
                        &&self._value,
                    )
                }
            }
            ///Container type for the return parameters of the [`transferFrom(address,address,uint256)`](transferFromCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct transferFromReturn {
                pub _0: bool,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for transferFromReturn {
                #[inline]
                fn clone(&self) -> transferFromReturn {
                    transferFromReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for transferFromReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "transferFromReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Uint<256>,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Address,
                        ::alloy::sol_types::private::Address,
                        ::alloy::sol_types::private::U256,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<transferFromCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: transferFromCall) -> Self {
                            (value._from, value._to, value._value)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for transferFromCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {
                                _from: tuple.0,
                                _to: tuple.1,
                                _value: tuple.2,
                            }
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (::alloy::sol_types::sol_data::Bool,);
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (bool,);
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<transferFromReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: transferFromReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for transferFromReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for transferFromCall {
                    type Parameters<'a> = (
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Address,
                        ::alloy::sol_types::sol_data::Uint<256>,
                    );
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = transferFromReturn;
                    type ReturnTuple<'a> = (::alloy::sol_types::sol_data::Bool,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "transferFrom(address,address,uint256)";
                    const SELECTOR: [u8; 4] = [35u8, 184u8, 114u8, 221u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self._from,
                            ),
                            <::alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                                &self._to,
                            ),
                            <::alloy::sol_types::sol_data::Uint<
                                256,
                            > as alloy_sol_types::SolType>::tokenize(&self._value),
                        )
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            ///Container for all the [`ERC20`](self) function calls.
            pub enum ERC20Calls {
                allowance(allowanceCall),
                approve(approveCall),
                balanceOf(balanceOfCall),
                decimals(decimalsCall),
                name(nameCall),
                symbol(symbolCall),
                totalSupply(totalSupplyCall),
                transfer(transferCall),
                transferFrom(transferFromCall),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for ERC20Calls {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        ERC20Calls::allowance(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "allowance",
                                &__self_0,
                            )
                        }
                        ERC20Calls::approve(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "approve",
                                &__self_0,
                            )
                        }
                        ERC20Calls::balanceOf(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "balanceOf",
                                &__self_0,
                            )
                        }
                        ERC20Calls::decimals(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "decimals",
                                &__self_0,
                            )
                        }
                        ERC20Calls::name(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "name",
                                &__self_0,
                            )
                        }
                        ERC20Calls::symbol(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "symbol",
                                &__self_0,
                            )
                        }
                        ERC20Calls::totalSupply(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "totalSupply",
                                &__self_0,
                            )
                        }
                        ERC20Calls::transfer(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "transfer",
                                &__self_0,
                            )
                        }
                        ERC20Calls::transferFrom(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "transferFrom",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl ERC20Calls {
                /// All the selectors of this enum.
                ///
                /// Note that the selectors might not be in the same order as the variants.
                /// No guarantees are made about the order of the selectors.
                ///
                /// Prefer using `SolInterface` methods instead.
                pub const SELECTORS: &'static [[u8; 4usize]] = &[
                    [6u8, 253u8, 222u8, 3u8],
                    [9u8, 94u8, 167u8, 179u8],
                    [24u8, 22u8, 13u8, 221u8],
                    [35u8, 184u8, 114u8, 221u8],
                    [49u8, 60u8, 229u8, 103u8],
                    [112u8, 160u8, 130u8, 49u8],
                    [149u8, 216u8, 155u8, 65u8],
                    [169u8, 5u8, 156u8, 187u8],
                    [221u8, 98u8, 237u8, 62u8],
                ];
            }
            #[automatically_derived]
            impl alloy_sol_types::SolInterface for ERC20Calls {
                const NAME: &'static str = "ERC20Calls";
                const MIN_DATA_LENGTH: usize = 0usize;
                const COUNT: usize = 9usize;
                #[inline]
                fn selector(&self) -> [u8; 4] {
                    match self {
                        Self::allowance(_) => {
                            <allowanceCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::approve(_) => {
                            <approveCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::balanceOf(_) => {
                            <balanceOfCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::decimals(_) => {
                            <decimalsCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::name(_) => <nameCall as alloy_sol_types::SolCall>::SELECTOR,
                        Self::symbol(_) => {
                            <symbolCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::totalSupply(_) => {
                            <totalSupplyCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::transfer(_) => {
                            <transferCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::transferFrom(_) => {
                            <transferFromCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                    }
                }
                #[inline]
                fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
                    Self::SELECTORS.get(i).copied()
                }
                #[inline]
                fn valid_selector(selector: [u8; 4]) -> bool {
                    Self::SELECTORS.binary_search(&selector).is_ok()
                }
                #[inline]
                #[allow(unsafe_code, non_snake_case)]
                fn abi_decode_raw(
                    selector: [u8; 4],
                    data: &[u8],
                    validate: bool,
                ) -> alloy_sol_types::Result<Self> {
                    static DECODE_SHIMS: &[fn(
                        &[u8],
                        bool,
                    ) -> alloy_sol_types::Result<ERC20Calls>] = &[
                        {
                            fn name(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<ERC20Calls> {
                                <nameCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(ERC20Calls::name)
                            }
                            name
                        },
                        {
                            fn approve(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<ERC20Calls> {
                                <approveCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(ERC20Calls::approve)
                            }
                            approve
                        },
                        {
                            fn totalSupply(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<ERC20Calls> {
                                <totalSupplyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(ERC20Calls::totalSupply)
                            }
                            totalSupply
                        },
                        {
                            fn transferFrom(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<ERC20Calls> {
                                <transferFromCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(ERC20Calls::transferFrom)
                            }
                            transferFrom
                        },
                        {
                            fn decimals(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<ERC20Calls> {
                                <decimalsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(ERC20Calls::decimals)
                            }
                            decimals
                        },
                        {
                            fn balanceOf(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<ERC20Calls> {
                                <balanceOfCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(ERC20Calls::balanceOf)
                            }
                            balanceOf
                        },
                        {
                            fn symbol(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<ERC20Calls> {
                                <symbolCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(ERC20Calls::symbol)
                            }
                            symbol
                        },
                        {
                            fn transfer(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<ERC20Calls> {
                                <transferCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(ERC20Calls::transfer)
                            }
                            transfer
                        },
                        {
                            fn allowance(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<ERC20Calls> {
                                <allowanceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(ERC20Calls::allowance)
                            }
                            allowance
                        },
                    ];
                    let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                        return Err(
                            alloy_sol_types::Error::unknown_selector(
                                <Self as alloy_sol_types::SolInterface>::NAME,
                                selector,
                            ),
                        );
                    };
                    (unsafe { DECODE_SHIMS.get_unchecked(idx) })(data, validate)
                }
                #[inline]
                fn abi_encoded_size(&self) -> usize {
                    match self {
                        Self::allowance(inner) => {
                            <allowanceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::approve(inner) => {
                            <approveCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::balanceOf(inner) => {
                            <balanceOfCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::decimals(inner) => {
                            <decimalsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::name(inner) => {
                            <nameCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::symbol(inner) => {
                            <symbolCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::totalSupply(inner) => {
                            <totalSupplyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::transfer(inner) => {
                            <transferCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::transferFrom(inner) => {
                            <transferFromCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                    }
                }
                #[inline]
                fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                    match self {
                        Self::allowance(inner) => {
                            <allowanceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::approve(inner) => {
                            <approveCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::balanceOf(inner) => {
                            <balanceOfCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::decimals(inner) => {
                            <decimalsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::name(inner) => {
                            <nameCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::symbol(inner) => {
                            <symbolCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::totalSupply(inner) => {
                            <totalSupplyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::transfer(inner) => {
                            <transferCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::transferFrom(inner) => {
                            <transferFromCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                    }
                }
            }
            ///Container for all the [`ERC20`](self) events.
            pub enum ERC20Events {
                Approval(Approval),
                Transfer(Transfer),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for ERC20Events {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        ERC20Events::Approval(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Approval",
                                &__self_0,
                            )
                        }
                        ERC20Events::Transfer(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Transfer",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl ERC20Events {
                /// All the selectors of this enum.
                ///
                /// Note that the selectors might not be in the same order as the variants.
                /// No guarantees are made about the order of the selectors.
                ///
                /// Prefer using `SolInterface` methods instead.
                pub const SELECTORS: &'static [[u8; 32usize]] = &[
                    [
                        140u8,
                        91u8,
                        225u8,
                        229u8,
                        235u8,
                        236u8,
                        125u8,
                        91u8,
                        209u8,
                        79u8,
                        113u8,
                        66u8,
                        125u8,
                        30u8,
                        132u8,
                        243u8,
                        221u8,
                        3u8,
                        20u8,
                        192u8,
                        247u8,
                        178u8,
                        41u8,
                        30u8,
                        91u8,
                        32u8,
                        10u8,
                        200u8,
                        199u8,
                        195u8,
                        185u8,
                        37u8,
                    ],
                    [
                        221u8,
                        242u8,
                        82u8,
                        173u8,
                        27u8,
                        226u8,
                        200u8,
                        155u8,
                        105u8,
                        194u8,
                        176u8,
                        104u8,
                        252u8,
                        55u8,
                        141u8,
                        170u8,
                        149u8,
                        43u8,
                        167u8,
                        241u8,
                        99u8,
                        196u8,
                        161u8,
                        22u8,
                        40u8,
                        245u8,
                        90u8,
                        77u8,
                        245u8,
                        35u8,
                        179u8,
                        239u8,
                    ],
                ];
            }
            #[automatically_derived]
            impl alloy_sol_types::SolEventInterface for ERC20Events {
                const NAME: &'static str = "ERC20Events";
                const COUNT: usize = 2usize;
                fn decode_raw_log(
                    topics: &[alloy_sol_types::Word],
                    data: &[u8],
                    validate: bool,
                ) -> alloy_sol_types::Result<Self> {
                    match topics.first().copied() {
                        Some(<Approval as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                            <Approval as alloy_sol_types::SolEvent>::decode_raw_log(
                                    topics,
                                    data,
                                    validate,
                                )
                                .map(Self::Approval)
                        }
                        Some(<Transfer as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                            <Transfer as alloy_sol_types::SolEvent>::decode_raw_log(
                                    topics,
                                    data,
                                    validate,
                                )
                                .map(Self::Transfer)
                        }
                        _ => {
                            alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                                name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                                log: alloy_sol_types::private::Box::new(
                                    alloy_sol_types::private::LogData::new_unchecked(
                                        topics.to_vec(),
                                        data.to_vec().into(),
                                    ),
                                ),
                            })
                        }
                    }
                }
            }
            #[automatically_derived]
            impl alloy_sol_types::private::IntoLogData for ERC20Events {
                fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                    match self {
                        Self::Approval(inner) => {
                            alloy_sol_types::private::IntoLogData::to_log_data(inner)
                        }
                        Self::Transfer(inner) => {
                            alloy_sol_types::private::IntoLogData::to_log_data(inner)
                        }
                    }
                }
                fn into_log_data(self) -> alloy_sol_types::private::LogData {
                    match self {
                        Self::Approval(inner) => {
                            alloy_sol_types::private::IntoLogData::into_log_data(inner)
                        }
                        Self::Transfer(inner) => {
                            alloy_sol_types::private::IntoLogData::into_log_data(inner)
                        }
                    }
                }
            }
            use ::alloy::contract as alloy_contract;
            /**Creates a new wrapper around an on-chain [`ERC20`](self) contract instance.

See the [wrapper's documentation](`ERC20Instance`) for more details.*/
            #[inline]
            pub const fn new<
                T: alloy_contract::private::Transport + ::core::clone::Clone,
                P: alloy_contract::private::Provider<T, N>,
                N: alloy_contract::private::Network,
            >(
                address: alloy_sol_types::private::Address,
                provider: P,
            ) -> ERC20Instance<T, P, N> {
                ERC20Instance::<T, P, N>::new(address, provider)
            }
            /**A [`ERC20`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`ERC20`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
            pub struct ERC20Instance<T, P, N = alloy_contract::private::Ethereum> {
                address: alloy_sol_types::private::Address,
                provider: P,
                _network_transport: ::core::marker::PhantomData<(N, T)>,
            }
            #[automatically_derived]
            impl<
                T: ::core::clone::Clone,
                P: ::core::clone::Clone,
                N: ::core::clone::Clone,
            > ::core::clone::Clone for ERC20Instance<T, P, N> {
                #[inline]
                fn clone(&self) -> ERC20Instance<T, P, N> {
                    ERC20Instance {
                        address: ::core::clone::Clone::clone(&self.address),
                        provider: ::core::clone::Clone::clone(&self.provider),
                        _network_transport: ::core::clone::Clone::clone(
                            &self._network_transport,
                        ),
                    }
                }
            }
            #[automatically_derived]
            impl<T, P, N> ::core::fmt::Debug for ERC20Instance<T, P, N> {
                #[inline]
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_tuple("ERC20Instance").field(&self.address).finish()
                }
            }
            /// Instantiation and getters/setters.
            #[automatically_derived]
            impl<
                T: alloy_contract::private::Transport + ::core::clone::Clone,
                P: alloy_contract::private::Provider<T, N>,
                N: alloy_contract::private::Network,
            > ERC20Instance<T, P, N> {
                /**Creates a new wrapper around an on-chain [`ERC20`](self) contract instance.

See the [wrapper's documentation](`ERC20Instance`) for more details.*/
                #[inline]
                pub const fn new(
                    address: alloy_sol_types::private::Address,
                    provider: P,
                ) -> Self {
                    Self {
                        address,
                        provider,
                        _network_transport: ::core::marker::PhantomData,
                    }
                }
                /// Returns a reference to the address.
                #[inline]
                pub const fn address(&self) -> &alloy_sol_types::private::Address {
                    &self.address
                }
                /// Sets the address.
                #[inline]
                pub fn set_address(
                    &mut self,
                    address: alloy_sol_types::private::Address,
                ) {
                    self.address = address;
                }
                /// Sets the address and returns `self`.
                pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
                    self.set_address(address);
                    self
                }
                /// Returns a reference to the provider.
                #[inline]
                pub const fn provider(&self) -> &P {
                    &self.provider
                }
            }
            impl<T, P: ::core::clone::Clone, N> ERC20Instance<T, &P, N> {
                /// Clones the provider and returns a new instance with the cloned provider.
                #[inline]
                pub fn with_cloned_provider(self) -> ERC20Instance<T, P, N> {
                    ERC20Instance {
                        address: self.address,
                        provider: ::core::clone::Clone::clone(&self.provider),
                        _network_transport: ::core::marker::PhantomData,
                    }
                }
            }
            /// Function calls.
            #[automatically_derived]
            impl<
                T: alloy_contract::private::Transport + ::core::clone::Clone,
                P: alloy_contract::private::Provider<T, N>,
                N: alloy_contract::private::Network,
            > ERC20Instance<T, P, N> {
                /// Creates a new call builder using this contract instance's provider and address.
                ///
                /// Note that the call can be any function call, not just those defined in this
                /// contract. Prefer using the other methods for building type-safe contract calls.
                pub fn call_builder<C: alloy_sol_types::SolCall>(
                    &self,
                    call: &C,
                ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
                    alloy_contract::SolCallBuilder::new_sol(
                        &self.provider,
                        &self.address,
                        call,
                    )
                }
                ///Creates a new call builder for the [`allowance`] function.
                pub fn allowance(
                    &self,
                    _owner: ::alloy::sol_types::private::Address,
                    _spender: ::alloy::sol_types::private::Address,
                ) -> alloy_contract::SolCallBuilder<T, &P, allowanceCall, N> {
                    self.call_builder(&allowanceCall { _owner, _spender })
                }
                ///Creates a new call builder for the [`approve`] function.
                pub fn approve(
                    &self,
                    _spender: ::alloy::sol_types::private::Address,
                    _value: ::alloy::sol_types::private::U256,
                ) -> alloy_contract::SolCallBuilder<T, &P, approveCall, N> {
                    self.call_builder(&approveCall { _spender, _value })
                }
                ///Creates a new call builder for the [`balanceOf`] function.
                pub fn balanceOf(
                    &self,
                    _owner: ::alloy::sol_types::private::Address,
                ) -> alloy_contract::SolCallBuilder<T, &P, balanceOfCall, N> {
                    self.call_builder(&balanceOfCall { _owner })
                }
                ///Creates a new call builder for the [`decimals`] function.
                pub fn decimals(
                    &self,
                ) -> alloy_contract::SolCallBuilder<T, &P, decimalsCall, N> {
                    self.call_builder(&decimalsCall {})
                }
                ///Creates a new call builder for the [`name`] function.
                pub fn name(
                    &self,
                ) -> alloy_contract::SolCallBuilder<T, &P, nameCall, N> {
                    self.call_builder(&nameCall {})
                }
                ///Creates a new call builder for the [`symbol`] function.
                pub fn symbol(
                    &self,
                ) -> alloy_contract::SolCallBuilder<T, &P, symbolCall, N> {
                    self.call_builder(&symbolCall {})
                }
                ///Creates a new call builder for the [`totalSupply`] function.
                pub fn totalSupply(
                    &self,
                ) -> alloy_contract::SolCallBuilder<T, &P, totalSupplyCall, N> {
                    self.call_builder(&totalSupplyCall {})
                }
                ///Creates a new call builder for the [`transfer`] function.
                pub fn transfer(
                    &self,
                    _to: ::alloy::sol_types::private::Address,
                    _value: ::alloy::sol_types::private::U256,
                ) -> alloy_contract::SolCallBuilder<T, &P, transferCall, N> {
                    self.call_builder(&transferCall { _to, _value })
                }
                ///Creates a new call builder for the [`transferFrom`] function.
                pub fn transferFrom(
                    &self,
                    _from: ::alloy::sol_types::private::Address,
                    _to: ::alloy::sol_types::private::Address,
                    _value: ::alloy::sol_types::private::U256,
                ) -> alloy_contract::SolCallBuilder<T, &P, transferFromCall, N> {
                    self.call_builder(
                        &transferFromCall {
                            _from,
                            _to,
                            _value,
                        },
                    )
                }
            }
            /// Event filters.
            #[automatically_derived]
            impl<
                T: alloy_contract::private::Transport + ::core::clone::Clone,
                P: alloy_contract::private::Provider<T, N>,
                N: alloy_contract::private::Network,
            > ERC20Instance<T, P, N> {
                /// Creates a new event filter using this contract instance's provider and address.
                ///
                /// Note that the type can be any event, not just those defined in this contract.
                /// Prefer using the other methods for building type-safe event filters.
                pub fn event_filter<E: alloy_sol_types::SolEvent>(
                    &self,
                ) -> alloy_contract::Event<T, &P, E, N> {
                    alloy_contract::Event::new_sol(&self.provider, &self.address)
                }
                ///Creates a new event filter for the [`Approval`] event.
                pub fn Approval_filter(
                    &self,
                ) -> alloy_contract::Event<T, &P, Approval, N> {
                    self.event_filter::<Approval>()
                }
                ///Creates a new event filter for the [`Transfer`] event.
                pub fn Transfer_filter(
                    &self,
                ) -> alloy_contract::Event<T, &P, Transfer, N> {
                    self.event_filter::<Transfer>()
                }
            }
        }
    }
    mod v2_builder {
        use alloy::{
            dyn_abi::{DynSolType, DynSolValue},
            primitives::U128,
        };
        use rand::Rng;
        use std::sync::Arc;
        use alloy::providers::Provider;
        use alloy::transports::Transport;
        use alloy::network::Network;
        use alloy::sol;
        use crate::pools::{Pool, PoolType};
        use alloy::primitives::Address;
        use std::time::Duration;
        use super::pool_structure::UniswapV2Pool;
        use crate::pools::gen::ERC20;
        const _: &'static [u8] = b"{\"abi\":[{\"type\":\"constructor\",\"inputs\":[{\"name\":\"pools\",\"type\":\"address[]\",\"internalType\":\"address[]\"}],\"stateMutability\":\"nonpayable\"}],\"bytecode\":{\"object\":\"0x608060405234801561001057600080fd5b50604051610d40380380610d4083398181016040528101906100329190610941565b6000815167ffffffffffffffff81111561004f5761004e6107a0565b5b60405190808252806020026020018201604052801561008857816020015b6100756106d1565b81526020019060019003908161006d5790505b50905060005b825181101561066f5760008382815181106100ac576100ab61098a565b5b602002602001015190506100c58161069e60201b60201c565b156100d05750610664565b6100d86106d1565b8173ffffffffffffffffffffffffffffffffffffffff16630dfe16816040518163ffffffff1660e01b8152600401602060405180830381865afa158015610123573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061014791906109b9565b816020019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250508173ffffffffffffffffffffffffffffffffffffffff1663d21220a76040518163ffffffff1660e01b8152600401602060405180830381865afa1580156101c9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101ed91906109b9565b816040019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505081816000019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505061026f816020015161069e60201b60201c565b1561027b575050610664565b61028e816040015161069e60201b60201c565b1561029a575050610664565b600080826020015173ffffffffffffffffffffffffffffffffffffffff16614e206040516024016040516020818303038152906040527f313ce567000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff838183161783525050505060405161034b9190610a57565b60006040518083038160008787f1925050503d8060008114610389576040519150601f19603f3d011682016040523d82523d6000602084013e61038e565b606091505b509150915081156103ff57600060208251036103ef57818060200190518101906103b89190610aa4565b905060008114806103c9575060ff81115b156103d8575050505050610664565b80846060019060ff16908160ff16815250506103f9565b5050505050610664565b50610408565b50505050610664565b600080846040015173ffffffffffffffffffffffffffffffffffffffff16614e206040516024016040516020818303038152906040527f313ce567000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff83818316178352505050506040516104b99190610a57565b60006040518083038160008787f1925050503d80600081146104f7576040519150601f19603f3d011682016040523d82523d6000602084013e6104fc565b606091505b50915091508115610571576000602082510361055f57818060200190518101906105269190610aa4565b90506000811480610537575060ff81115b156105485750505050505050610664565b80866080019060ff16908160ff168152505061056b565b50505050505050610664565b5061057c565b505050505050610664565b8573ffffffffffffffffffffffffffffffffffffffff16630902f1ac6040518163ffffffff1660e01b8152600401606060405180830381865afa1580156105c7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105eb9190610b53565b508660a0018760c001826dffffffffffffffffffffffffffff166dffffffffffffffffffffffffffff16815250826dffffffffffffffffffffffffffff166dffffffffffffffffffffffffffff168152505050848888815181106106525761065161098a565b5b60200260200101819052505050505050505b80600101905061008e565b506000816040516020016106839190610d1d565b60405160208183030381529060405290506020810180590381f35b6000808273ffffffffffffffffffffffffffffffffffffffff163b036106c757600190506106cc565b600090505b919050565b6040518060e00160405280600073ffffffffffffffffffffffffffffffffffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff168152602001600060ff168152602001600060ff16815260200160006dffffffffffffffffffffffffffff16815260200160006dffffffffffffffffffffffffffff1681525090565b6000604051905090565b600080fd5b600080fd5b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6107d88261078f565b810181811067ffffffffffffffff821117156107f7576107f66107a0565b5b80604052505050565b600061080a610776565b905061081682826107cf565b919050565b600067ffffffffffffffff821115610836576108356107a0565b5b602082029050602081019050919050565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006108778261084c565b9050919050565b6108878161086c565b811461089257600080fd5b50565b6000815190506108a48161087e565b92915050565b60006108bd6108b88461081b565b610800565b905080838252602082019050602084028301858111156108e0576108df610847565b5b835b8181101561090957806108f58882610895565b8452602084019350506020810190506108e2565b5050509392505050565b600082601f8301126109285761092761078a565b5b81516109388482602086016108aa565b91505092915050565b60006020828403121561095757610956610780565b5b600082015167ffffffffffffffff81111561097557610974610785565b5b61098184828501610913565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b6000602082840312156109cf576109ce610780565b5b60006109dd84828501610895565b91505092915050565b600081519050919050565b600081905092915050565b60005b83811015610a1a5780820151818401526020810190506109ff565b60008484015250505050565b6000610a31826109e6565b610a3b81856109f1565b9350610a4b8185602086016109fc565b80840191505092915050565b6000610a638284610a26565b915081905092915050565b6000819050919050565b610a8181610a6e565b8114610a8c57600080fd5b50565b600081519050610a9e81610a78565b92915050565b600060208284031215610aba57610ab9610780565b5b6000610ac884828501610a8f565b91505092915050565b60006dffffffffffffffffffffffffffff82169050919050565b610af481610ad1565b8114610aff57600080fd5b50565b600081519050610b1181610aeb565b92915050565b600063ffffffff82169050919050565b610b3081610b17565b8114610b3b57600080fd5b50565b600081519050610b4d81610b27565b92915050565b600080600060608486031215610b6c57610b6b610780565b5b6000610b7a86828701610b02565b9350506020610b8b86828701610b02565b9250506040610b9c86828701610b3e565b9150509250925092565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b610bdb8161086c565b82525050565b600060ff82169050919050565b610bf781610be1565b82525050565b610c0681610ad1565b82525050565b60e082016000820151610c226000850182610bd2565b506020820151610c356020850182610bd2565b506040820151610c486040850182610bd2565b506060820151610c5b6060850182610bee565b506080820151610c6e6080850182610bee565b5060a0820151610c8160a0850182610bfd565b5060c0820151610c9460c0850182610bfd565b50505050565b6000610ca68383610c0c565b60e08301905092915050565b6000602082019050919050565b6000610cca82610ba6565b610cd48185610bb1565b9350610cdf83610bc2565b8060005b83811015610d10578151610cf78882610c9a565b9750610d0283610cb2565b925050600181019050610ce3565b5085935050505092915050565b60006020820190508181036000830152610d378184610cbf565b90509291505056fe\",\"sourceMap\":\"549:3740:3:-:0;;;790:3298;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;836:29;883:5;:12;868:28;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;836:60;;912:9;907:2641;931:5;:12;927:1;:16;907:2641;;;964:19;986:5;992:1;986:8;;;;;;;;:::i;:::-;;;;;;;;964:30;;1013:27;1028:11;1013:14;;;:27;;:::i;:::-;1009:41;;;1042:8;;;1009:41;1065:24;;:::i;:::-;1171:11;1156:34;;;:36;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;1138:8;:15;;:54;;;;;;;;;;;1239:11;1224:34;;;:36;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;1206:8;:15;;:54;;;;;;;;;;;1294:11;1274:8;:17;;:31;;;;;;;;;;;1394;1409:8;:15;;;1394:14;;;:31;;:::i;:::-;1390:45;;;1427:8;;;;1390:45;1453:31;1468:8;:15;;;1453:14;;;:31;;:::i;:::-;1449:45;;;1486:8;;;;1449:45;1562:26;1606:31;1654:8;:15;;;:20;;1680:5;1708:37;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1654:109;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1544:219;;;;1782:21;1778:640;;;1823:22;1897:2;1868:18;:25;:31;1864:493;;1978:18;1942:111;;;;;;;;;;;;:::i;:::-;1923:130;;2098:1;2080:14;:19;:43;;;;2120:3;2103:14;:20;2080:43;2076:208;;;2151:8;;;;;;;2076:208;2246:14;2214:8;:23;;:47;;;;;;;;;;;1864:493;;;2330:8;;;;;;;1864:493;1805:566;1778:640;;;2395:8;;;;;;1778:640;2485:26;2529:31;2577:8;:15;;;:20;;2603:5;2631:37;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2577:109;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2467:219;;;;2705:21;2701:640;;;2746:22;2820:2;2791:18;:25;:31;2787:493;;2901:18;2865:111;;;;;;;;;;;;:::i;:::-;2846:130;;3021:1;3003:14;:19;:43;;;;3043:3;3026:14;:20;3003:43;2999:208;;;3074:8;;;;;;;;;2999:208;3169:14;3137:8;:23;;:47;;;;;;;;;;;2787:493;;;3253:8;;;;;;;;;2787:493;2728:566;2701:640;;;3318:8;;;;;;;;2701:640;3458:11;3426:69;;;:71;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;3383:114;3384:8;:17;;3403:8;:17;;3383:114;;;;;;;;;;;;;;;;;;3529:8;3512:11;3524:1;3512:14;;;;;;;;:::i;:::-;;;;;;;:25;;;;950:2598;;;;;;907:2641;945:3;;;;;907:2641;;;;3750:28;3792:11;3781:23;;;;;;;;:::i;:::-;;;;;;;;;;;;;3750:54;;4012:4;3995:15;3991:26;4061:9;4052:7;4048:23;4037:9;4030:42;4094:193;4157:4;4199:1;4177:6;:18;;;:23;4173:108;;4223:4;4216:11;;;;4173:108;4265:5;4258:12;;4094:193;;;;:::o;549:3740::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::o;7:75:4:-;40:6;73:2;67:9;57:19;;7:75;:::o;88:117::-;197:1;194;187:12;211:117;320:1;317;310:12;334:117;443:1;440;433:12;457:102;498:6;549:2;545:7;540:2;533:5;529:14;525:28;515:38;;457:102;;;:::o;565:180::-;613:77;610:1;603:88;710:4;707:1;700:15;734:4;731:1;724:15;751:281;834:27;856:4;834:27;:::i;:::-;826:6;822:40;964:6;952:10;949:22;928:18;916:10;913:34;910:62;907:88;;;975:18;;:::i;:::-;907:88;1015:10;1011:2;1004:22;794:238;751:281;;:::o;1038:129::-;1072:6;1099:20;;:::i;:::-;1089:30;;1128:33;1156:4;1148:6;1128:33;:::i;:::-;1038:129;;;:::o;1173:311::-;1250:4;1340:18;1332:6;1329:30;1326:56;;;1362:18;;:::i;:::-;1326:56;1412:4;1404:6;1400:17;1392:25;;1472:4;1466;1462:15;1454:23;;1173:311;;;:::o;1490:117::-;1599:1;1596;1589:12;1613:126;1650:7;1690:42;1683:5;1679:54;1668:65;;1613:126;;;:::o;1745:96::-;1782:7;1811:24;1829:5;1811:24;:::i;:::-;1800:35;;1745:96;;;:::o;1847:122::-;1920:24;1938:5;1920:24;:::i;:::-;1913:5;1910:35;1900:63;;1959:1;1956;1949:12;1900:63;1847:122;:::o;1975:143::-;2032:5;2063:6;2057:13;2048:22;;2079:33;2106:5;2079:33;:::i;:::-;1975:143;;;;:::o;2141:732::-;2248:5;2273:81;2289:64;2346:6;2289:64;:::i;:::-;2273:81;:::i;:::-;2264:90;;2374:5;2403:6;2396:5;2389:21;2437:4;2430:5;2426:16;2419:23;;2490:4;2482:6;2478:17;2470:6;2466:30;2519:3;2511:6;2508:15;2505:122;;;2538:79;;:::i;:::-;2505:122;2653:6;2636:231;2670:6;2665:3;2662:15;2636:231;;;2745:3;2774:48;2818:3;2806:10;2774:48;:::i;:::-;2769:3;2762:61;2852:4;2847:3;2843:14;2836:21;;2712:155;2696:4;2691:3;2687:14;2680:21;;2636:231;;;2640:21;2254:619;;2141:732;;;;;:::o;2896:385::-;2978:5;3027:3;3020:4;3012:6;3008:17;3004:27;2994:122;;3035:79;;:::i;:::-;2994:122;3145:6;3139:13;3170:105;3271:3;3263:6;3256:4;3248:6;3244:17;3170:105;:::i;:::-;3161:114;;2984:297;2896:385;;;;:::o;3287:554::-;3382:6;3431:2;3419:9;3410:7;3406:23;3402:32;3399:119;;;3437:79;;:::i;:::-;3399:119;3578:1;3567:9;3563:17;3557:24;3608:18;3600:6;3597:30;3594:117;;;3630:79;;:::i;:::-;3594:117;3735:89;3816:7;3807:6;3796:9;3792:22;3735:89;:::i;:::-;3725:99;;3528:306;3287:554;;;;:::o;3847:180::-;3895:77;3892:1;3885:88;3992:4;3989:1;3982:15;4016:4;4013:1;4006:15;4033:351;4103:6;4152:2;4140:9;4131:7;4127:23;4123:32;4120:119;;;4158:79;;:::i;:::-;4120:119;4278:1;4303:64;4359:7;4350:6;4339:9;4335:22;4303:64;:::i;:::-;4293:74;;4249:128;4033:351;;;;:::o;4390:98::-;4441:6;4475:5;4469:12;4459:22;;4390:98;;;:::o;4494:147::-;4595:11;4632:3;4617:18;;4494:147;;;;:::o;4647:248::-;4729:1;4739:113;4753:6;4750:1;4747:13;4739:113;;;4838:1;4833:3;4829:11;4823:18;4819:1;4814:3;4810:11;4803:39;4775:2;4772:1;4768:10;4763:15;;4739:113;;;4886:1;4877:6;4872:3;4868:16;4861:27;4709:186;4647:248;;;:::o;4901:386::-;5005:3;5033:38;5065:5;5033:38;:::i;:::-;5087:88;5168:6;5163:3;5087:88;:::i;:::-;5080:95;;5184:65;5242:6;5237:3;5230:4;5223:5;5219:16;5184:65;:::i;:::-;5274:6;5269:3;5265:16;5258:23;;5009:278;4901:386;;;;:::o;5293:271::-;5423:3;5445:93;5534:3;5525:6;5445:93;:::i;:::-;5438:100;;5555:3;5548:10;;5293:271;;;;:::o;5570:77::-;5607:7;5636:5;5625:16;;5570:77;;;:::o;5653:122::-;5726:24;5744:5;5726:24;:::i;:::-;5719:5;5716:35;5706:63;;5765:1;5762;5755:12;5706:63;5653:122;:::o;5781:143::-;5838:5;5869:6;5863:13;5854:22;;5885:33;5912:5;5885:33;:::i;:::-;5781:143;;;;:::o;5930:351::-;6000:6;6049:2;6037:9;6028:7;6024:23;6020:32;6017:119;;;6055:79;;:::i;:::-;6017:119;6175:1;6200:64;6256:7;6247:6;6236:9;6232:22;6200:64;:::i;:::-;6190:74;;6146:128;5930:351;;;;:::o;6287:114::-;6324:7;6364:30;6357:5;6353:42;6342:53;;6287:114;;;:::o;6407:122::-;6480:24;6498:5;6480:24;:::i;:::-;6473:5;6470:35;6460:63;;6519:1;6516;6509:12;6460:63;6407:122;:::o;6535:143::-;6592:5;6623:6;6617:13;6608:22;;6639:33;6666:5;6639:33;:::i;:::-;6535:143;;;;:::o;6684:93::-;6720:7;6760:10;6753:5;6749:22;6738:33;;6684:93;;;:::o;6783:120::-;6855:23;6872:5;6855:23;:::i;:::-;6848:5;6845:34;6835:62;;6893:1;6890;6883:12;6835:62;6783:120;:::o;6909:141::-;6965:5;6996:6;6990:13;6981:22;;7012:32;7038:5;7012:32;:::i;:::-;6909:141;;;;:::o;7056:661::-;7143:6;7151;7159;7208:2;7196:9;7187:7;7183:23;7179:32;7176:119;;;7214:79;;:::i;:::-;7176:119;7334:1;7359:64;7415:7;7406:6;7395:9;7391:22;7359:64;:::i;:::-;7349:74;;7305:128;7472:2;7498:64;7554:7;7545:6;7534:9;7530:22;7498:64;:::i;:::-;7488:74;;7443:129;7611:2;7637:63;7692:7;7683:6;7672:9;7668:22;7637:63;:::i;:::-;7627:73;;7582:128;7056:661;;;;;:::o;7723:140::-;7816:6;7850:5;7844:12;7834:22;;7723:140;;;:::o;7869:210::-;7994:11;8028:6;8023:3;8016:19;8068:4;8063:3;8059:14;8044:29;;7869:210;;;;:::o;8085:158::-;8178:4;8201:3;8193:11;;8231:4;8226:3;8222:14;8214:22;;8085:158;;;:::o;8249:108::-;8326:24;8344:5;8326:24;:::i;:::-;8321:3;8314:37;8249:108;;:::o;8363:86::-;8398:7;8438:4;8431:5;8427:16;8416:27;;8363:86;;;:::o;8455:102::-;8528:22;8544:5;8528:22;:::i;:::-;8523:3;8516:35;8455:102;;:::o;8563:108::-;8640:24;8658:5;8640:24;:::i;:::-;8635:3;8628:37;8563:108;;:::o;8741:1397::-;8880:4;8875:3;8871:14;8971:4;8964:5;8960:16;8954:23;8990:63;9047:4;9042:3;9038:14;9024:12;8990:63;:::i;:::-;8895:168;9147:4;9140:5;9136:16;9130:23;9166:63;9223:4;9218:3;9214:14;9200:12;9166:63;:::i;:::-;9073:166;9323:4;9316:5;9312:16;9306:23;9342:63;9399:4;9394:3;9390:14;9376:12;9342:63;:::i;:::-;9249:166;9507:4;9500:5;9496:16;9490:23;9526:59;9579:4;9574:3;9570:14;9556:12;9526:59;:::i;:::-;9425:170;9687:4;9680:5;9676:16;9670:23;9706:59;9759:4;9754:3;9750:14;9736:12;9706:59;:::i;:::-;9605:170;9861:4;9854:5;9850:16;9844:23;9880:63;9937:4;9932:3;9928:14;9914:12;9880:63;:::i;:::-;9785:168;10039:4;10032:5;10028:16;10022:23;10058:63;10115:4;10110:3;10106:14;10092:12;10058:63;:::i;:::-;9963:168;8849:1289;8741:1397;;:::o;10144:283::-;10265:10;10286:98;10380:3;10372:6;10286:98;:::i;:::-;10416:4;10411:3;10407:14;10393:28;;10144:283;;;;:::o;10433:139::-;10529:4;10561;10556:3;10552:14;10544:22;;10433:139;;;:::o;10646:940::-;10817:3;10846:80;10920:5;10846:80;:::i;:::-;10942:112;11047:6;11042:3;10942:112;:::i;:::-;10935:119;;11078:82;11154:5;11078:82;:::i;:::-;11183:7;11214:1;11199:362;11224:6;11221:1;11218:13;11199:362;;;11300:6;11294:13;11327:115;11438:3;11423:13;11327:115;:::i;:::-;11320:122;;11465:86;11544:6;11465:86;:::i;:::-;11455:96;;11259:302;11246:1;11243;11239:9;11234:14;;11199:362;;;11203:14;11577:3;11570:10;;10822:764;;;10646:940;;;;:::o;11592:477::-;11787:4;11825:2;11814:9;11810:18;11802:26;;11874:9;11868:4;11864:20;11860:1;11849:9;11845:17;11838:47;11902:160;12057:4;12048:6;11902:160;:::i;:::-;11894:168;;11592:477;;;;:::o\",\"linkReferences\":{}},\"deployedBytecode\":{\"object\":\"0x6080604052600080fdfea26469706673582212208ff086a93835751b13a5f6b2f6143f93ab943f071a44d99edcb8a9246a1ee83764736f6c63430008190033\",\"sourceMap\":\"549:3740:3:-:0;;;;;\",\"linkReferences\":{}},\"methodIdentifiers\":{},\"rawMetadata\":\"{\\\"compiler\\\":{\\\"version\\\":\\\"0.8.25+commit.b61c2a91\\\"},\\\"language\\\":\\\"Solidity\\\",\\\"output\\\":{\\\"abi\\\":[{\\\"inputs\\\":[{\\\"internalType\\\":\\\"address[]\\\",\\\"name\\\":\\\"pools\\\",\\\"type\\\":\\\"address[]\\\"}],\\\"stateMutability\\\":\\\"nonpayable\\\",\\\"type\\\":\\\"constructor\\\"}],\\\"devdoc\\\":{\\\"details\\\":\\\"This contract is not meant to be deployed. Instead, use a static call with the       deployment bytecode as payload.\\\",\\\"kind\\\":\\\"dev\\\",\\\"methods\\\":{},\\\"version\\\":1},\\\"userdoc\\\":{\\\"kind\\\":\\\"user\\\",\\\"methods\\\":{},\\\"version\\\":1}},\\\"settings\\\":{\\\"compilationTarget\\\":{\\\"src/V2DataSync.sol\\\":\\\"V2DataSync\\\"},\\\"evmVersion\\\":\\\"paris\\\",\\\"libraries\\\":{},\\\"metadata\\\":{\\\"bytecodeHash\\\":\\\"ipfs\\\"},\\\"optimizer\\\":{\\\"enabled\\\":false,\\\"runs\\\":200},\\\"remappings\\\":[\\\":forge-std/=lib/forge-std/src/\\\"]},\\\"sources\\\":{\\\"src/V2DataSync.sol\\\":{\\\"keccak256\\\":\\\"0x2696b5eb9b945bb1f3dd5c6a511e5fd6310acf86b3fd62a6de09529bf5f9b9a8\\\",\\\"license\\\":\\\"MIT\\\",\\\"urls\\\":[\\\"bzz-raw://acd1492dcf3fb1034e486eefdbf8d2367092006263d65a920748b9e706466ca4\\\",\\\"dweb:/ipfs/QmWsvgieJC5vw1HxNPpuRCtiNTCJH4oWBLSLqUL77qpiza\\\"]}},\\\"version\\\":1}\",\"metadata\":{\"compiler\":{\"version\":\"0.8.25+commit.b61c2a91\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"pools\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"remappings\":[\"forge-std/=lib/forge-std/src/\"],\"optimizer\":{\"enabled\":false,\"runs\":200},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"compilationTarget\":{\"src/V2DataSync.sol\":\"V2DataSync\"},\"evmVersion\":\"paris\",\"libraries\":{}},\"sources\":{\"src/V2DataSync.sol\":{\"keccak256\":\"0x2696b5eb9b945bb1f3dd5c6a511e5fd6310acf86b3fd62a6de09529bf5f9b9a8\",\"urls\":[\"bzz-raw://acd1492dcf3fb1034e486eefdbf8d2367092006263d65a920748b9e706466ca4\",\"dweb:/ipfs/QmWsvgieJC5vw1HxNPpuRCtiNTCJH4oWBLSLqUL77qpiza\"],\"license\":\"MIT\"}},\"version\":1},\"id\":3}";
        /**

Generated by the following Solidity interface...
```solidity
interface V2DataSync {
    constructor(address[] pools);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "pools",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "stateMutability": "nonpayable"
  }
]
```*/
        #[allow(non_camel_case_types, non_snake_case, clippy::style)]
        pub mod V2DataSync {
            use super::*;
            use ::alloy::sol_types as alloy_sol_types;
            /// The creation / init bytecode of the contract.
            ///
            /// ```text
            ///0x608060405234801561001057600080fd5b50604051610d40380380610d4083398181016040528101906100329190610941565b6000815167ffffffffffffffff81111561004f5761004e6107a0565b5b60405190808252806020026020018201604052801561008857816020015b6100756106d1565b81526020019060019003908161006d5790505b50905060005b825181101561066f5760008382815181106100ac576100ab61098a565b5b602002602001015190506100c58161069e60201b60201c565b156100d05750610664565b6100d86106d1565b8173ffffffffffffffffffffffffffffffffffffffff16630dfe16816040518163ffffffff1660e01b8152600401602060405180830381865afa158015610123573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061014791906109b9565b816020019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250508173ffffffffffffffffffffffffffffffffffffffff1663d21220a76040518163ffffffff1660e01b8152600401602060405180830381865afa1580156101c9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101ed91906109b9565b816040019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505081816000019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505061026f816020015161069e60201b60201c565b1561027b575050610664565b61028e816040015161069e60201b60201c565b1561029a575050610664565b600080826020015173ffffffffffffffffffffffffffffffffffffffff16614e206040516024016040516020818303038152906040527f313ce567000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff838183161783525050505060405161034b9190610a57565b60006040518083038160008787f1925050503d8060008114610389576040519150601f19603f3d011682016040523d82523d6000602084013e61038e565b606091505b509150915081156103ff57600060208251036103ef57818060200190518101906103b89190610aa4565b905060008114806103c9575060ff81115b156103d8575050505050610664565b80846060019060ff16908160ff16815250506103f9565b5050505050610664565b50610408565b50505050610664565b600080846040015173ffffffffffffffffffffffffffffffffffffffff16614e206040516024016040516020818303038152906040527f313ce567000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff83818316178352505050506040516104b99190610a57565b60006040518083038160008787f1925050503d80600081146104f7576040519150601f19603f3d011682016040523d82523d6000602084013e6104fc565b606091505b50915091508115610571576000602082510361055f57818060200190518101906105269190610aa4565b90506000811480610537575060ff81115b156105485750505050505050610664565b80866080019060ff16908160ff168152505061056b565b50505050505050610664565b5061057c565b505050505050610664565b8573ffffffffffffffffffffffffffffffffffffffff16630902f1ac6040518163ffffffff1660e01b8152600401606060405180830381865afa1580156105c7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105eb9190610b53565b508660a0018760c001826dffffffffffffffffffffffffffff166dffffffffffffffffffffffffffff16815250826dffffffffffffffffffffffffffff166dffffffffffffffffffffffffffff168152505050848888815181106106525761065161098a565b5b60200260200101819052505050505050505b80600101905061008e565b506000816040516020016106839190610d1d565b60405160208183030381529060405290506020810180590381f35b6000808273ffffffffffffffffffffffffffffffffffffffff163b036106c757600190506106cc565b600090505b919050565b6040518060e00160405280600073ffffffffffffffffffffffffffffffffffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff168152602001600060ff168152602001600060ff16815260200160006dffffffffffffffffffffffffffff16815260200160006dffffffffffffffffffffffffffff1681525090565b6000604051905090565b600080fd5b600080fd5b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6107d88261078f565b810181811067ffffffffffffffff821117156107f7576107f66107a0565b5b80604052505050565b600061080a610776565b905061081682826107cf565b919050565b600067ffffffffffffffff821115610836576108356107a0565b5b602082029050602081019050919050565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006108778261084c565b9050919050565b6108878161086c565b811461089257600080fd5b50565b6000815190506108a48161087e565b92915050565b60006108bd6108b88461081b565b610800565b905080838252602082019050602084028301858111156108e0576108df610847565b5b835b8181101561090957806108f58882610895565b8452602084019350506020810190506108e2565b5050509392505050565b600082601f8301126109285761092761078a565b5b81516109388482602086016108aa565b91505092915050565b60006020828403121561095757610956610780565b5b600082015167ffffffffffffffff81111561097557610974610785565b5b61098184828501610913565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b6000602082840312156109cf576109ce610780565b5b60006109dd84828501610895565b91505092915050565b600081519050919050565b600081905092915050565b60005b83811015610a1a5780820151818401526020810190506109ff565b60008484015250505050565b6000610a31826109e6565b610a3b81856109f1565b9350610a4b8185602086016109fc565b80840191505092915050565b6000610a638284610a26565b915081905092915050565b6000819050919050565b610a8181610a6e565b8114610a8c57600080fd5b50565b600081519050610a9e81610a78565b92915050565b600060208284031215610aba57610ab9610780565b5b6000610ac884828501610a8f565b91505092915050565b60006dffffffffffffffffffffffffffff82169050919050565b610af481610ad1565b8114610aff57600080fd5b50565b600081519050610b1181610aeb565b92915050565b600063ffffffff82169050919050565b610b3081610b17565b8114610b3b57600080fd5b50565b600081519050610b4d81610b27565b92915050565b600080600060608486031215610b6c57610b6b610780565b5b6000610b7a86828701610b02565b9350506020610b8b86828701610b02565b9250506040610b9c86828701610b3e565b9150509250925092565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b610bdb8161086c565b82525050565b600060ff82169050919050565b610bf781610be1565b82525050565b610c0681610ad1565b82525050565b60e082016000820151610c226000850182610bd2565b506020820151610c356020850182610bd2565b506040820151610c486040850182610bd2565b506060820151610c5b6060850182610bee565b506080820151610c6e6080850182610bee565b5060a0820151610c8160a0850182610bfd565b5060c0820151610c9460c0850182610bfd565b50505050565b6000610ca68383610c0c565b60e08301905092915050565b6000602082019050919050565b6000610cca82610ba6565b610cd48185610bb1565b9350610cdf83610bc2565b8060005b83811015610d10578151610cf78882610c9a565b9750610d0283610cb2565b925050600181019050610ce3565b5085935050505092915050565b60006020820190508181036000830152610d378184610cbf565b90509291505056fe
            /// ```
            #[rustfmt::skip]
            #[allow(clippy::all)]
            pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
                b"`\x80`@R4\x80\x15a\x00\x10W`\x00\x80\xfd[P`@Qa\r@8\x03\x80a\r@\x839\x81\x81\x01`@R\x81\x01\x90a\x002\x91\x90a\tAV[`\x00\x81Qg\xff\xff\xff\xff\xff\xff\xff\xff\x81\x11\x15a\x00OWa\x00Na\x07\xa0V[[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x00\x88W\x81` \x01[a\x00ua\x06\xd1V[\x81R` \x01\x90`\x01\x90\x03\x90\x81a\x00mW\x90P[P\x90P`\x00[\x82Q\x81\x10\x15a\x06oW`\x00\x83\x82\x81Q\x81\x10a\x00\xacWa\x00\xaba\t\x8aV[[` \x02` \x01\x01Q\x90Pa\x00\xc5\x81a\x06\x9e` \x1b` \x1cV[\x15a\x00\xd0WPa\x06dV[a\x00\xd8a\x06\xd1V[\x81s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16c\r\xfe\x16\x81`@Q\x81c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x01#W=`\x00\x80>=`\x00\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x01G\x91\x90a\t\xb9V[\x81` \x01\x90s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16\x90\x81s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16\x81RPP\x81s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16c\xd2\x12 \xa7`@Q\x81c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x01\xc9W=`\x00\x80>=`\x00\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x01\xed\x91\x90a\t\xb9V[\x81`@\x01\x90s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16\x90\x81s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16\x81RPP\x81\x81`\x00\x01\x90s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16\x90\x81s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16\x81RPPa\x02o\x81` \x01Qa\x06\x9e` \x1b` \x1cV[\x15a\x02{WPPa\x06dV[a\x02\x8e\x81`@\x01Qa\x06\x9e` \x1b` \x1cV[\x15a\x02\x9aWPPa\x06dV[`\x00\x80\x82` \x01Qs\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16aN `@Q`$\x01`@Q` \x81\x83\x03\x03\x81R\x90`@R\x7f1<\xe5g\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00{\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x19\x16` \x82\x01\x80Q{\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x83\x81\x83\x16\x17\x83RPPPP`@Qa\x03K\x91\x90a\nWV[`\x00`@Q\x80\x83\x03\x81`\x00\x87\x87\xf1\x92PPP=\x80`\x00\x81\x14a\x03\x89W`@Q\x91P`\x1f\x19`?=\x01\x16\x82\x01`@R=\x82R=`\x00` \x84\x01>a\x03\x8eV[``\x91P[P\x91P\x91P\x81\x15a\x03\xffW`\x00` \x82Q\x03a\x03\xefW\x81\x80` \x01\x90Q\x81\x01\x90a\x03\xb8\x91\x90a\n\xa4V[\x90P`\x00\x81\x14\x80a\x03\xc9WP`\xff\x81\x11[\x15a\x03\xd8WPPPPPa\x06dV[\x80\x84``\x01\x90`\xff\x16\x90\x81`\xff\x16\x81RPPa\x03\xf9V[PPPPPa\x06dV[Pa\x04\x08V[PPPPa\x06dV[`\x00\x80\x84`@\x01Qs\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16aN `@Q`$\x01`@Q` \x81\x83\x03\x03\x81R\x90`@R\x7f1<\xe5g\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00{\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x19\x16` \x82\x01\x80Q{\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x83\x81\x83\x16\x17\x83RPPPP`@Qa\x04\xb9\x91\x90a\nWV[`\x00`@Q\x80\x83\x03\x81`\x00\x87\x87\xf1\x92PPP=\x80`\x00\x81\x14a\x04\xf7W`@Q\x91P`\x1f\x19`?=\x01\x16\x82\x01`@R=\x82R=`\x00` \x84\x01>a\x04\xfcV[``\x91P[P\x91P\x91P\x81\x15a\x05qW`\x00` \x82Q\x03a\x05_W\x81\x80` \x01\x90Q\x81\x01\x90a\x05&\x91\x90a\n\xa4V[\x90P`\x00\x81\x14\x80a\x057WP`\xff\x81\x11[\x15a\x05HWPPPPPPPa\x06dV[\x80\x86`\x80\x01\x90`\xff\x16\x90\x81`\xff\x16\x81RPPa\x05kV[PPPPPPPa\x06dV[Pa\x05|V[PPPPPPa\x06dV[\x85s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16c\t\x02\xf1\xac`@Q\x81c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01```@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x05\xc7W=`\x00\x80>=`\x00\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x05\xeb\x91\x90a\x0bSV[P\x86`\xa0\x01\x87`\xc0\x01\x82m\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16m\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16\x81RP\x82m\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16m\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16\x81RPPP\x84\x88\x88\x81Q\x81\x10a\x06RWa\x06Qa\t\x8aV[[` \x02` \x01\x01\x81\x90RPPPPPPP[\x80`\x01\x01\x90Pa\x00\x8eV[P`\x00\x81`@Q` \x01a\x06\x83\x91\x90a\r\x1dV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x90P` \x81\x01\x80Y\x03\x81\xf3[`\x00\x80\x82s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16;\x03a\x06\xc7W`\x01\x90Pa\x06\xccV[`\x00\x90P[\x91\x90PV[`@Q\x80`\xe0\x01`@R\x80`\x00s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16\x81R` \x01`\x00s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16\x81R` \x01`\x00s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16\x81R` \x01`\x00`\xff\x16\x81R` \x01`\x00`\xff\x16\x81R` \x01`\x00m\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16\x81R` \x01`\x00m\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16\x81RP\x90V[`\x00`@Q\x90P\x90V[`\x00\x80\xfd[`\x00\x80\xfd[`\x00\x80\xfd[`\x00`\x1f\x19`\x1f\x83\x01\x16\x90P\x91\x90PV[\x7fNH{q\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00`\x00R`A`\x04R`$`\x00\xfd[a\x07\xd8\x82a\x07\x8fV[\x81\x01\x81\x81\x10g\xff\xff\xff\xff\xff\xff\xff\xff\x82\x11\x17\x15a\x07\xf7Wa\x07\xf6a\x07\xa0V[[\x80`@RPPPV[`\x00a\x08\na\x07vV[\x90Pa\x08\x16\x82\x82a\x07\xcfV[\x91\x90PV[`\x00g\xff\xff\xff\xff\xff\xff\xff\xff\x82\x11\x15a\x086Wa\x085a\x07\xa0V[[` \x82\x02\x90P` \x81\x01\x90P\x91\x90PV[`\x00\x80\xfd[`\x00s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x82\x16\x90P\x91\x90PV[`\x00a\x08w\x82a\x08LV[\x90P\x91\x90PV[a\x08\x87\x81a\x08lV[\x81\x14a\x08\x92W`\x00\x80\xfd[PV[`\x00\x81Q\x90Pa\x08\xa4\x81a\x08~V[\x92\x91PPV[`\x00a\x08\xbda\x08\xb8\x84a\x08\x1bV[a\x08\x00V[\x90P\x80\x83\x82R` \x82\x01\x90P` \x84\x02\x83\x01\x85\x81\x11\x15a\x08\xe0Wa\x08\xdfa\x08GV[[\x83[\x81\x81\x10\x15a\t\tW\x80a\x08\xf5\x88\x82a\x08\x95V[\x84R` \x84\x01\x93PP` \x81\x01\x90Pa\x08\xe2V[PPP\x93\x92PPPV[`\x00\x82`\x1f\x83\x01\x12a\t(Wa\t\'a\x07\x8aV[[\x81Qa\t8\x84\x82` \x86\x01a\x08\xaaV[\x91PP\x92\x91PPV[`\x00` \x82\x84\x03\x12\x15a\tWWa\tVa\x07\x80V[[`\x00\x82\x01Qg\xff\xff\xff\xff\xff\xff\xff\xff\x81\x11\x15a\tuWa\tta\x07\x85V[[a\t\x81\x84\x82\x85\x01a\t\x13V[\x91PP\x92\x91PPV[\x7fNH{q\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00`\x00R`2`\x04R`$`\x00\xfd[`\x00` \x82\x84\x03\x12\x15a\t\xcfWa\t\xcea\x07\x80V[[`\x00a\t\xdd\x84\x82\x85\x01a\x08\x95V[\x91PP\x92\x91PPV[`\x00\x81Q\x90P\x91\x90PV[`\x00\x81\x90P\x92\x91PPV[`\x00[\x83\x81\x10\x15a\n\x1aW\x80\x82\x01Q\x81\x84\x01R` \x81\x01\x90Pa\t\xffV[`\x00\x84\x84\x01RPPPPV[`\x00a\n1\x82a\t\xe6V[a\n;\x81\x85a\t\xf1V[\x93Pa\nK\x81\x85` \x86\x01a\t\xfcV[\x80\x84\x01\x91PP\x92\x91PPV[`\x00a\nc\x82\x84a\n&V[\x91P\x81\x90P\x92\x91PPV[`\x00\x81\x90P\x91\x90PV[a\n\x81\x81a\nnV[\x81\x14a\n\x8cW`\x00\x80\xfd[PV[`\x00\x81Q\x90Pa\n\x9e\x81a\nxV[\x92\x91PPV[`\x00` \x82\x84\x03\x12\x15a\n\xbaWa\n\xb9a\x07\x80V[[`\x00a\n\xc8\x84\x82\x85\x01a\n\x8fV[\x91PP\x92\x91PPV[`\x00m\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x82\x16\x90P\x91\x90PV[a\n\xf4\x81a\n\xd1V[\x81\x14a\n\xffW`\x00\x80\xfd[PV[`\x00\x81Q\x90Pa\x0b\x11\x81a\n\xebV[\x92\x91PPV[`\x00c\xff\xff\xff\xff\x82\x16\x90P\x91\x90PV[a\x0b0\x81a\x0b\x17V[\x81\x14a\x0b;W`\x00\x80\xfd[PV[`\x00\x81Q\x90Pa\x0bM\x81a\x0b\'V[\x92\x91PPV[`\x00\x80`\x00``\x84\x86\x03\x12\x15a\x0blWa\x0bka\x07\x80V[[`\x00a\x0bz\x86\x82\x87\x01a\x0b\x02V[\x93PP` a\x0b\x8b\x86\x82\x87\x01a\x0b\x02V[\x92PP`@a\x0b\x9c\x86\x82\x87\x01a\x0b>V[\x91PP\x92P\x92P\x92V[`\x00\x81Q\x90P\x91\x90PV[`\x00\x82\x82R` \x82\x01\x90P\x92\x91PPV[`\x00\x81\x90P` \x82\x01\x90P\x91\x90PV[a\x0b\xdb\x81a\x08lV[\x82RPPV[`\x00`\xff\x82\x16\x90P\x91\x90PV[a\x0b\xf7\x81a\x0b\xe1V[\x82RPPV[a\x0c\x06\x81a\n\xd1V[\x82RPPV[`\xe0\x82\x01`\x00\x82\x01Qa\x0c\"`\x00\x85\x01\x82a\x0b\xd2V[P` \x82\x01Qa\x0c5` \x85\x01\x82a\x0b\xd2V[P`@\x82\x01Qa\x0cH`@\x85\x01\x82a\x0b\xd2V[P``\x82\x01Qa\x0c[``\x85\x01\x82a\x0b\xeeV[P`\x80\x82\x01Qa\x0cn`\x80\x85\x01\x82a\x0b\xeeV[P`\xa0\x82\x01Qa\x0c\x81`\xa0\x85\x01\x82a\x0b\xfdV[P`\xc0\x82\x01Qa\x0c\x94`\xc0\x85\x01\x82a\x0b\xfdV[PPPPV[`\x00a\x0c\xa6\x83\x83a\x0c\x0cV[`\xe0\x83\x01\x90P\x92\x91PPV[`\x00` \x82\x01\x90P\x91\x90PV[`\x00a\x0c\xca\x82a\x0b\xa6V[a\x0c\xd4\x81\x85a\x0b\xb1V[\x93Pa\x0c\xdf\x83a\x0b\xc2V[\x80`\x00[\x83\x81\x10\x15a\r\x10W\x81Qa\x0c\xf7\x88\x82a\x0c\x9aV[\x97Pa\r\x02\x83a\x0c\xb2V[\x92PP`\x01\x81\x01\x90Pa\x0c\xe3V[P\x85\x93PPPP\x92\x91PPV[`\x00` \x82\x01\x90P\x81\x81\x03`\x00\x83\x01Ra\r7\x81\x84a\x0c\xbfV[\x90P\x92\x91PPV\xfe",
            );
            /// The runtime bytecode of the contract, as deployed on the network.
            ///
            /// ```text
            ///0x6080604052600080fdfea26469706673582212208ff086a93835751b13a5f6b2f6143f93ab943f071a44d99edcb8a9246a1ee83764736f6c63430008190033
            /// ```
            #[rustfmt::skip]
            #[allow(clippy::all)]
            pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
                b"`\x80`@R`\x00\x80\xfd\xfe\xa2dipfsX\"\x12 \x8f\xf0\x86\xa985u\x1b\x13\xa5\xf6\xb2\xf6\x14?\x93\xab\x94?\x07\x1aD\xd9\x9e\xdc\xb8\xa9$j\x1e\xe87dsolcC\x00\x08\x19\x003",
            );
            /**Constructor`.
```solidity
constructor(address[] pools);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct constructorCall {
                pub pools: ::alloy::sol_types::private::Vec<
                    ::alloy::sol_types::private::Address,
                >,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for constructorCall {
                #[inline]
                fn clone(&self) -> constructorCall {
                    constructorCall {
                        pools: ::core::clone::Clone::clone(&self.pools),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for constructorCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "constructorCall",
                        "pools",
                        &&self.pools,
                    )
                }
            }
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Array<
                            ::alloy::sol_types::sol_data::Address,
                        >,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Vec<
                            ::alloy::sol_types::private::Address,
                        >,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<constructorCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: constructorCall) -> Self {
                            (value.pools,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for constructorCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { pools: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolConstructor for constructorCall {
                    type Parameters<'a> = (
                        ::alloy::sol_types::sol_data::Array<
                            ::alloy::sol_types::sol_data::Address,
                        >,
                    );
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Array<
                                ::alloy::sol_types::sol_data::Address,
                            > as alloy_sol_types::SolType>::tokenize(&self.pools),
                        )
                    }
                }
            };
            use ::alloy::contract as alloy_contract;
            /**Creates a new wrapper around an on-chain [`V2DataSync`](self) contract instance.

See the [wrapper's documentation](`V2DataSyncInstance`) for more details.*/
            #[inline]
            pub const fn new<
                T: alloy_contract::private::Transport + ::core::clone::Clone,
                P: alloy_contract::private::Provider<T, N>,
                N: alloy_contract::private::Network,
            >(
                address: alloy_sol_types::private::Address,
                provider: P,
            ) -> V2DataSyncInstance<T, P, N> {
                V2DataSyncInstance::<T, P, N>::new(address, provider)
            }
            /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
            #[inline]
            pub fn deploy<
                T: alloy_contract::private::Transport + ::core::clone::Clone,
                P: alloy_contract::private::Provider<T, N>,
                N: alloy_contract::private::Network,
            >(
                provider: P,
                pools: ::alloy::sol_types::private::Vec<
                    ::alloy::sol_types::private::Address,
                >,
            ) -> impl ::core::future::Future<
                Output = alloy_contract::Result<V2DataSyncInstance<T, P, N>>,
            > {
                V2DataSyncInstance::<T, P, N>::deploy(provider, pools)
            }
            /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
            #[inline]
            pub fn deploy_builder<
                T: alloy_contract::private::Transport + ::core::clone::Clone,
                P: alloy_contract::private::Provider<T, N>,
                N: alloy_contract::private::Network,
            >(
                provider: P,
                pools: ::alloy::sol_types::private::Vec<
                    ::alloy::sol_types::private::Address,
                >,
            ) -> alloy_contract::RawCallBuilder<T, P, N> {
                V2DataSyncInstance::<T, P, N>::deploy_builder(provider, pools)
            }
            /**A [`V2DataSync`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`V2DataSync`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
            pub struct V2DataSyncInstance<T, P, N = alloy_contract::private::Ethereum> {
                address: alloy_sol_types::private::Address,
                provider: P,
                _network_transport: ::core::marker::PhantomData<(N, T)>,
            }
            #[automatically_derived]
            impl<
                T: ::core::clone::Clone,
                P: ::core::clone::Clone,
                N: ::core::clone::Clone,
            > ::core::clone::Clone for V2DataSyncInstance<T, P, N> {
                #[inline]
                fn clone(&self) -> V2DataSyncInstance<T, P, N> {
                    V2DataSyncInstance {
                        address: ::core::clone::Clone::clone(&self.address),
                        provider: ::core::clone::Clone::clone(&self.provider),
                        _network_transport: ::core::clone::Clone::clone(
                            &self._network_transport,
                        ),
                    }
                }
            }
            #[automatically_derived]
            impl<T, P, N> ::core::fmt::Debug for V2DataSyncInstance<T, P, N> {
                #[inline]
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_tuple("V2DataSyncInstance").field(&self.address).finish()
                }
            }
            /// Instantiation and getters/setters.
            #[automatically_derived]
            impl<
                T: alloy_contract::private::Transport + ::core::clone::Clone,
                P: alloy_contract::private::Provider<T, N>,
                N: alloy_contract::private::Network,
            > V2DataSyncInstance<T, P, N> {
                /**Creates a new wrapper around an on-chain [`V2DataSync`](self) contract instance.

See the [wrapper's documentation](`V2DataSyncInstance`) for more details.*/
                #[inline]
                pub const fn new(
                    address: alloy_sol_types::private::Address,
                    provider: P,
                ) -> Self {
                    Self {
                        address,
                        provider,
                        _network_transport: ::core::marker::PhantomData,
                    }
                }
                /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
                #[inline]
                pub async fn deploy(
                    provider: P,
                    pools: ::alloy::sol_types::private::Vec<
                        ::alloy::sol_types::private::Address,
                    >,
                ) -> alloy_contract::Result<V2DataSyncInstance<T, P, N>> {
                    let call_builder = Self::deploy_builder(provider, pools);
                    let contract_address = call_builder.deploy().await?;
                    Ok(Self::new(contract_address, call_builder.provider))
                }
                /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
                #[inline]
                pub fn deploy_builder(
                    provider: P,
                    pools: ::alloy::sol_types::private::Vec<
                        ::alloy::sol_types::private::Address,
                    >,
                ) -> alloy_contract::RawCallBuilder<T, P, N> {
                    alloy_contract::RawCallBuilder::new_raw_deploy(
                        provider,
                        [
                            &BYTECODE[..],
                            &alloy_sol_types::SolConstructor::abi_encode(
                                &constructorCall { pools },
                            )[..],
                        ]
                            .concat()
                            .into(),
                    )
                }
                /// Returns a reference to the address.
                #[inline]
                pub const fn address(&self) -> &alloy_sol_types::private::Address {
                    &self.address
                }
                /// Sets the address.
                #[inline]
                pub fn set_address(
                    &mut self,
                    address: alloy_sol_types::private::Address,
                ) {
                    self.address = address;
                }
                /// Sets the address and returns `self`.
                pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
                    self.set_address(address);
                    self
                }
                /// Returns a reference to the provider.
                #[inline]
                pub const fn provider(&self) -> &P {
                    &self.provider
                }
            }
            impl<T, P: ::core::clone::Clone, N> V2DataSyncInstance<T, &P, N> {
                /// Clones the provider and returns a new instance with the cloned provider.
                #[inline]
                pub fn with_cloned_provider(self) -> V2DataSyncInstance<T, P, N> {
                    V2DataSyncInstance {
                        address: self.address,
                        provider: ::core::clone::Clone::clone(&self.provider),
                        _network_transport: ::core::marker::PhantomData,
                    }
                }
            }
            /// Function calls.
            #[automatically_derived]
            impl<
                T: alloy_contract::private::Transport + ::core::clone::Clone,
                P: alloy_contract::private::Provider<T, N>,
                N: alloy_contract::private::Network,
            > V2DataSyncInstance<T, P, N> {
                /// Creates a new call builder using this contract instance's provider and address.
                ///
                /// Note that the call can be any function call, not just those defined in this
                /// contract. Prefer using the other methods for building type-safe contract calls.
                pub fn call_builder<C: alloy_sol_types::SolCall>(
                    &self,
                    call: &C,
                ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
                    alloy_contract::SolCallBuilder::new_sol(
                        &self.provider,
                        &self.address,
                        call,
                    )
                }
            }
            /// Event filters.
            #[automatically_derived]
            impl<
                T: alloy_contract::private::Transport + ::core::clone::Clone,
                P: alloy_contract::private::Provider<T, N>,
                N: alloy_contract::private::Network,
            > V2DataSyncInstance<T, P, N> {
                /// Creates a new event filter using this contract instance's provider and address.
                ///
                /// Note that the type can be any event, not just those defined in this contract.
                /// Prefer using the other methods for building type-safe event filters.
                pub fn event_filter<E: alloy_sol_types::SolEvent>(
                    &self,
                ) -> alloy_contract::Event<T, &P, E, N> {
                    alloy_contract::Event::new_sol(&self.provider, &self.address)
                }
            }
        }
        pub const INITIAL_BACKOFF: u64 = 1000;
        pub const MAX_RETRIES: u32 = 5;
        pub async fn build_pools<P, T, N>(
            provider: Arc<P>,
            addresses: Vec<Address>,
            pool_type: PoolType,
        ) -> Vec<Pool>
        where
            P: Provider<T, N> + Sync + 'static,
            T: Transport + Sync + Clone,
            N: Network,
        {
            let mut retry_count = 0;
            let mut backoff = INITIAL_BACKOFF;
            loop {
                match attempt_build_pools(provider.clone(), &addresses, pool_type).await
                {
                    Ok(pools) => return pools,
                    Err(e) => {
                        if retry_count >= MAX_RETRIES {
                            {
                                ::std::io::_eprint(
                                    format_args!("Max retries reached. Error: {0:?}\n", e),
                                );
                            };
                        }
                        let jitter = rand::thread_rng().gen_range(0..=100);
                        let sleep_duration = Duration::from_millis(backoff + jitter);
                        tokio::time::sleep(sleep_duration).await;
                        retry_count += 1;
                        backoff *= 2;
                    }
                }
            }
        }
        async fn attempt_build_pools<P, T, N>(
            provider: Arc<P>,
            addresses: &Vec<Address>,
            pool_type: PoolType,
        ) -> Result<Vec<Pool>, Box<dyn std::error::Error>>
        where
            P: Provider<T, N> + Sync + 'static,
            T: Transport + Sync + Clone,
            N: Network,
        {
            let v2_data: DynSolType = DynSolType::Array(
                Box::new(
                    DynSolType::Tuple(
                        <[_]>::into_vec(
                            #[rustc_box]
                            ::alloc::boxed::Box::new([
                                DynSolType::Address,
                                DynSolType::Address,
                                DynSolType::Address,
                                DynSolType::Uint(8),
                                DynSolType::Uint(8),
                                DynSolType::Uint(112),
                                DynSolType::Uint(112),
                            ]),
                        ),
                    ),
                ),
            );
            let data = V2DataSync::deploy_builder(provider.clone(), addresses.to_vec())
                .await?;
            let decoded_data = v2_data.abi_decode_sequence(&data)?;
            let mut pools = Vec::new();
            if let Some(pool_data_arr) = decoded_data.as_array() {
                for pool_data_tuple in pool_data_arr {
                    if let Some(pool_data) = pool_data_tuple.as_tuple() {
                        let pool = UniswapV2Pool::from(pool_data);
                        if pool.is_valid() {
                            pools.push(pool);
                        }
                    }
                }
            }
            for pool in &mut pools {
                let token0_contract = ERC20::new(pool.token0, provider.clone());
                if let Ok(ERC20::symbolReturn { _0: name }) = token0_contract
                    .symbol()
                    .call()
                    .await
                {
                    pool.token0_name = name;
                }
                let token1_contract = ERC20::new(pool.token1, provider.clone());
                if let Ok(ERC20::symbolReturn { _0: name }) = token1_contract
                    .symbol()
                    .call()
                    .await
                {
                    pool.token1_name = name;
                }
            }
            let pools = pools
                .into_iter()
                .map(|pool| Pool::new_v2(pool_type, pool))
                .collect();
            Ok(pools)
        }
        impl From<&[DynSolValue]> for UniswapV2Pool {
            fn from(data: &[DynSolValue]) -> Self {
                Self {
                    address: data[0].as_address().unwrap(),
                    token0: data[1].as_address().unwrap(),
                    token1: data[2].as_address().unwrap(),
                    token0_decimals: data[3].as_uint().unwrap().0.to::<u8>(),
                    token1_decimals: data[4].as_uint().unwrap().0.to::<u8>(),
                    token0_reserves: data[5].as_uint().unwrap().0.to::<U128>(),
                    token1_reserves: data[6].as_uint().unwrap().0.to::<U128>(),
                    ..Default::default()
                }
            }
        }
    }
    mod v3_builder {
        use alloy::{
            dyn_abi::{DynSolType, DynSolValue},
            primitives::U128,
        };
        use rand::Rng;
        use std::sync::Arc;
        use alloy::providers::Provider;
        use alloy::transports::Transport;
        use alloy::network::Network;
        use alloy::sol;
        use crate::pools::{Pool, PoolType};
        use alloy::primitives::Address;
        use std::time::Duration;
        use super::pool_structure::UniswapV3Pool;
        use crate::pools::gen::ERC20;
        const _: &'static [u8] = b"{\"abi\":[{\"type\":\"constructor\",\"inputs\":[{\"name\":\"pools\",\"type\":\"address[]\",\"internalType\":\"address[]\"},{\"name\":\"dexType\",\"type\":\"uint8\",\"internalType\":\"enum V3DataSync.DexType\"}],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"PANCAKESWAP\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint8\",\"internalType\":\"enum V3DataSync.DexType\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"UNISWAP\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint8\",\"internalType\":\"enum V3DataSync.DexType\"}],\"stateMutability\":\"view\"}],\"bytecode\":{\"object\":\"0x608060405234801561001057600080fd5b506040516119453803806119458339818101604052810190610032919061110c565b6000825167ffffffffffffffff81111561004f5761004e610f46565b5b60405190808252806020026020018201604052801561008857816020015b610075610e44565b81526020019060019003908161006d5790505b50905060005b8351811015610de25760008482815181106100ac576100ab611168565b5b602002602001015190506100c581610e1160201b60201c565b156100d05750610dd7565b6100d8610e44565b81816000019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250506000600181111561012457610123611197565b5b85600181111561013757610136611197565b5b036102935760008290508073ffffffffffffffffffffffffffffffffffffffff16630dfe16816040518163ffffffff1660e01b8152600401602060405180830381865afa15801561018c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101b091906111c6565b826020019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250508073ffffffffffffffffffffffffffffffffffffffff1663d21220a76040518163ffffffff1660e01b8152600401602060405180830381865afa158015610232573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061025691906111c6565b826060019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250505061041d565b6001808111156102a6576102a5611197565b5b8560018111156102b9576102b8611197565b5b036104155760008290508073ffffffffffffffffffffffffffffffffffffffff16630dfe16816040518163ffffffff1660e01b8152600401602060405180830381865afa15801561030e573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061033291906111c6565b826020019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250508073ffffffffffffffffffffffffffffffffffffffff1663d21220a76040518163ffffffff1660e01b8152600401602060405180830381865afa1580156103b4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103d891906111c6565b826060019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250505061041c565b5050610dd7565b5b6104308160200151610e1160201b60201c565b1561043c575050610dd7565b61044f8160600151610e1160201b60201c565b1561045b575050610dd7565b600080826020015173ffffffffffffffffffffffffffffffffffffffff16614e206040516024016040516020818303038152906040527f313ce567000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff838183161783525050505060405161050c9190611264565b60006040518083038160008787f1925050503d806000811461054a576040519150601f19603f3d011682016040523d82523d6000602084013e61054f565b606091505b509150915081156105c057600060208251036105b0578180602001905181019061057991906112b1565b9050600081148061058a575060ff81115b15610599575050505050610dd7565b80846040019060ff16908160ff16815250506105ba565b5050505050610dd7565b506105c9565b50505050610dd7565b600080846060015173ffffffffffffffffffffffffffffffffffffffff16614e206040516024016040516020818303038152906040527f313ce567000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff838183161783525050505060405161067a9190611264565b60006040518083038160008787f1925050503d80600081146106b8576040519150601f19603f3d011682016040523d82523d6000602084013e6106bd565b606091505b50915091508115610732576000602082510361072057818060200190518101906106e791906112b1565b905060008114806106f8575060ff81115b156107095750505050505050610dd7565b80866080019060ff16908160ff168152505061072c565b50505050505050610dd7565b5061073d565b505050505050610dd7565b6000600181111561075157610750611197565b5b89600181111561076457610763611197565b5b03610a795760008690506000808273ffffffffffffffffffffffffffffffffffffffff16633850c7bd6040518163ffffffff1660e01b815260040160e060405180830381865afa1580156107bc573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107e091906113ee565b50505050509150915060008373ffffffffffffffffffffffffffffffffffffffff1663f30dba93836040518263ffffffff1660e01b8152600401610824919061149f565b61010060405180830381865afa158015610842573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061086691906115b0565b5050505050509150508373ffffffffffffffffffffffffffffffffffffffff16631a6865026040518163ffffffff1660e01b8152600401602060405180830381865afa1580156108ba573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108de9190611666565b8960a001906fffffffffffffffffffffffffffffffff1690816fffffffffffffffffffffffffffffffff16815250508373ffffffffffffffffffffffffffffffffffffffff1663d0c93a7c6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610958573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061097c9190611693565b89610100019060020b908160020b815250508373ffffffffffffffffffffffffffffffffffffffff1663ddca3f436040518163ffffffff1660e01b8152600401602060405180830381865afa1580156109d9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109fd91906116fb565b89610120019062ffffff16908162ffffff1681525050828960c0019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff1681525050818960e0019060020b908160020b8152505080896101400190600f0b9081600f0b8152505050505050610db1565b600180811115610a8c57610a8b611197565b5b896001811115610a9f57610a9e611197565b5b03610db05760008690506000808273ffffffffffffffffffffffffffffffffffffffff16633850c7bd6040518163ffffffff1660e01b815260040160e060405180830381865afa158015610af7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b1b91906113ee565b50505050509150915060008373ffffffffffffffffffffffffffffffffffffffff1663f30dba93836040518263ffffffff1660e01b8152600401610b5f919061149f565b61010060405180830381865afa158015610b7d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ba191906115b0565b5050505050509150508373ffffffffffffffffffffffffffffffffffffffff16631a6865026040518163ffffffff1660e01b8152600401602060405180830381865afa158015610bf5573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c199190611666565b8960a001906fffffffffffffffffffffffffffffffff1690816fffffffffffffffffffffffffffffffff16815250508373ffffffffffffffffffffffffffffffffffffffff1663d0c93a7c6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610c93573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610cb79190611693565b89610100019060020b908160020b815250508373ffffffffffffffffffffffffffffffffffffffff1663ddca3f436040518163ffffffff1660e01b8152600401602060405180830381865afa158015610d14573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d3891906116fb565b89610120019062ffffff16908162ffffff1681525050828960c0019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff1681525050818960e0019060020b908160020b8152505080896101400190600f0b9081600f0b81525050505050505b5b84888881518110610dc557610dc4611168565b5b60200260200101819052505050505050505b80600101905061008e565b50600081604051602001610df69190611922565b60405160208183030381529060405290506020810180590381f35b6000808273ffffffffffffffffffffffffffffffffffffffff163b03610e3a5760019050610e3f565b600090505b919050565b604051806101600160405280600073ffffffffffffffffffffffffffffffffffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff168152602001600060ff168152602001600073ffffffffffffffffffffffffffffffffffffffff168152602001600060ff16815260200160006fffffffffffffffffffffffffffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff168152602001600060020b8152602001600060020b8152602001600062ffffff1681526020016000600f0b81525090565b6000604051905090565b600080fd5b600080fd5b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b610f7e82610f35565b810181811067ffffffffffffffff82111715610f9d57610f9c610f46565b5b80604052505050565b6000610fb0610f1c565b9050610fbc8282610f75565b919050565b600067ffffffffffffffff821115610fdc57610fdb610f46565b5b602082029050602081019050919050565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b600061101d82610ff2565b9050919050565b61102d81611012565b811461103857600080fd5b50565b60008151905061104a81611024565b92915050565b600061106361105e84610fc1565b610fa6565b9050808382526020820190506020840283018581111561108657611085610fed565b5b835b818110156110af578061109b888261103b565b845260208401935050602081019050611088565b5050509392505050565b600082601f8301126110ce576110cd610f30565b5b81516110de848260208601611050565b91505092915050565b600281106110f457600080fd5b50565b600081519050611106816110e7565b92915050565b6000806040838503121561112357611122610f26565b5b600083015167ffffffffffffffff81111561114157611140610f2b565b5b61114d858286016110b9565b925050602061115e858286016110f7565b9150509250929050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b6000602082840312156111dc576111db610f26565b5b60006111ea8482850161103b565b91505092915050565b600081519050919050565b600081905092915050565b60005b8381101561122757808201518184015260208101905061120c565b60008484015250505050565b600061123e826111f3565b61124881856111fe565b9350611258818560208601611209565b80840191505092915050565b60006112708284611233565b915081905092915050565b6000819050919050565b61128e8161127b565b811461129957600080fd5b50565b6000815190506112ab81611285565b92915050565b6000602082840312156112c7576112c6610f26565b5b60006112d58482850161129c565b91505092915050565b6112e781610ff2565b81146112f257600080fd5b50565b600081519050611304816112de565b92915050565b60008160020b9050919050565b6113208161130a565b811461132b57600080fd5b50565b60008151905061133d81611317565b92915050565b600061ffff82169050919050565b61135a81611343565b811461136557600080fd5b50565b60008151905061137781611351565b92915050565b600060ff82169050919050565b6113938161137d565b811461139e57600080fd5b50565b6000815190506113b08161138a565b92915050565b60008115159050919050565b6113cb816113b6565b81146113d657600080fd5b50565b6000815190506113e8816113c2565b92915050565b600080600080600080600060e0888a03121561140d5761140c610f26565b5b600061141b8a828b016112f5565b975050602061142c8a828b0161132e565b965050604061143d8a828b01611368565b955050606061144e8a828b01611368565b945050608061145f8a828b01611368565b93505060a06114708a828b016113a1565b92505060c06114818a828b016113d9565b91505092959891949750929550565b6114998161130a565b82525050565b60006020820190506114b46000830184611490565b92915050565b60006fffffffffffffffffffffffffffffffff82169050919050565b6114df816114ba565b81146114ea57600080fd5b50565b6000815190506114fc816114d6565b92915050565b600081600f0b9050919050565b61151881611502565b811461152357600080fd5b50565b6000815190506115358161150f565b92915050565b60008160060b9050919050565b6115518161153b565b811461155c57600080fd5b50565b60008151905061156e81611548565b92915050565b600063ffffffff82169050919050565b61158d81611574565b811461159857600080fd5b50565b6000815190506115aa81611584565b92915050565b600080600080600080600080610100898b0312156115d1576115d0610f26565b5b60006115df8b828c016114ed565b98505060206115f08b828c01611526565b97505060406116018b828c0161129c565b96505060606116128b828c0161129c565b95505060806116238b828c0161155f565b94505060a06116348b828c016112f5565b93505060c06116458b828c0161159b565b92505060e06116568b828c016113d9565b9150509295985092959890939650565b60006020828403121561167c5761167b610f26565b5b600061168a848285016114ed565b91505092915050565b6000602082840312156116a9576116a8610f26565b5b60006116b78482850161132e565b91505092915050565b600062ffffff82169050919050565b6116d8816116c0565b81146116e357600080fd5b50565b6000815190506116f5816116cf565b92915050565b60006020828403121561171157611710610f26565b5b600061171f848285016116e6565b91505092915050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b61175d81611012565b82525050565b61176c8161137d565b82525050565b61177b816114ba565b82525050565b61178a81610ff2565b82525050565b6117998161130a565b82525050565b6117a8816116c0565b82525050565b6117b781611502565b82525050565b610160820160008201516117d46000850182611754565b5060208201516117e76020850182611754565b5060408201516117fa6040850182611763565b50606082015161180d6060850182611754565b5060808201516118206080850182611763565b5060a082015161183360a0850182611772565b5060c082015161184660c0850182611781565b5060e082015161185960e0850182611790565b5061010082015161186e610100850182611790565b5061012082015161188361012085018261179f565b506101408201516118986101408501826117ae565b50505050565b60006118aa83836117bd565b6101608301905092915050565b6000602082019050919050565b60006118cf82611728565b6118d98185611733565b93506118e483611744565b8060005b838110156119155781516118fc888261189e565b9750611907836118b7565b9250506001810190506118e8565b5085935050505092915050565b6000602082019050818103600083015261193c81846118c4565b90509291505056fe\",\"sourceMap\":\"2195:5152:3:-:0;;;2716:4430;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;2779:29;2826:5;:12;2811:28;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;2779:60;;2855:9;2850:3949;2874:5;:12;2870:1;:16;2850:3949;;;2907:19;2929:5;2935:1;2929:8;;;;;;;;:::i;:::-;;;;;;;;2907:30;;2956:27;2971:11;2956:14;;;:27;;:::i;:::-;2952:41;;;2985:8;;;2952:41;3008:24;;:::i;:::-;3067:11;3047:8;:17;;:31;;;;;;;;;;;3108:15;3097:26;;;;;;;;:::i;:::-;;:7;:26;;;;;;;;:::i;:::-;;;3093:509;;3143:19;3180:11;3143:49;;3228:4;:11;;;:13;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;3210:8;:15;;:31;;;;;;;;;;;3277:4;:11;;;:13;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;3259:8;:15;;:31;;;;;;;;;;;3125:180;3093:509;;;3326:19;3315:30;;;;;;;;:::i;:::-;;:7;:30;;;;;;;;:::i;:::-;;;3311:291;;3365:19;3402:11;3365:49;;3450:4;:11;;;:13;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;3432:8;:15;;:31;;;;;;;;;;;3499:4;:11;;;:13;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;3481:8;:15;;:31;;;;;;;;;;;3347:180;3311:291;;;3551:8;;;;3311:291;3093:509;3689:31;3704:8;:15;;;3689:14;;;:31;;:::i;:::-;3685:45;;;3722:8;;;;3685:45;3748:31;3763:8;:15;;;3748:14;;;:31;;:::i;:::-;3744:45;;;3781:8;;;;3744:45;3856:26;3900:31;3948:8;:15;;;:20;;3974:5;4002:37;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3948:109;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3838:219;;;;4076:21;4072:640;;;4117:22;4191:2;4162:18;:25;:31;4158:493;;4272:18;4236:111;;;;;;;;;;;;:::i;:::-;4217:130;;4392:1;4374:14;:19;:43;;;;4414:3;4397:14;:20;4374:43;4370:208;;;4445:8;;;;;;;4370:208;4540:14;4508:8;:23;;:47;;;;;;;;;;;4158:493;;;4624:8;;;;;;;4158:493;4099:566;4072:640;;;4689:8;;;;;;4072:640;4744:26;4788:31;4836:8;:15;;;:20;;4862:5;4890:37;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4836:109;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4726:219;;;;4964:21;4960:639;;;5005:22;5078:2;5049:18;:25;:31;5045:493;;5159:18;5123:111;;;;;;;;;;;;:::i;:::-;5104:130;;5279:1;5261:14;:19;:43;;;;5301:3;5284:14;:20;5261:43;5257:208;;;5332:8;;;;;;;;;5257:208;5427:14;5395:8;:23;;:47;;;;;;;;;;;5045:493;;;5511:8;;;;;;;;;5045:493;4987:565;4960:639;;;5576:8;;;;;;;;4960:639;5628:15;5617:26;;;;;;;;:::i;:::-;;:7;:26;;;;;;;;:::i;:::-;;;5613:1136;;5663:19;5700:11;5663:49;;5731:20;5753:10;5777:4;:10;;;:12;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;5730:59;;;;;;;;;5810:19;5845:4;:10;;;5856:4;5845:16;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;5807:54;;;;;;;;;5900:4;:14;;;:16;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;5879:8;:18;;:37;;;;;;;;;;;5957:4;:16;;;:18;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;5934:8;:20;;:41;;;;;;;;;;;6008:4;:8;;;:10;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;5993:8;:12;;:25;;;;;;;;;;;6057:12;6036:8;:18;;:33;;;;;;;;;;;6103:4;6087:8;:13;;:20;;;;;;;;;;;6149:12;6125:8;:21;;:36;;;;;;;;;;;5645:531;;;;5613:1136;;;6197:19;6186:30;;;;;;;;:::i;:::-;;:7;:30;;;;;;;;:::i;:::-;;;6182:567;;6236:19;6273:11;6236:49;;6304:20;6326:10;6350:4;:10;;;:12;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;6303:59;;;;;;;;;6383:19;6418:4;:10;;;6429:4;6418:16;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;6380:54;;;;;;;;;6473:4;:14;;;:16;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;6452:8;:18;;:37;;;;;;;;;;;6530:4;:16;;;:18;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;6507:8;:20;;:41;;;;;;;;;;;6581:4;:8;;;:10;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;6566:8;:12;;:25;;;;;;;;;;;6630:12;6609:8;:18;;:33;;;;;;;;;;;6676:4;6660:8;:13;;:20;;;;;;;;;;;6722:12;6698:8;:21;;:36;;;;;;;;;;;6218:531;;;;6182:567;5613:1136;6780:8;6763:11;6775:1;6763:14;;;;;;;;:::i;:::-;;;;;;;:25;;;;2893:3906;;;;;;2850:3949;2888:3;;;;;2850:3949;;;;6809:28;6851:11;6840:23;;;;;;;;:::i;:::-;;;;;;;;;;;;;6809:54;;7070:4;7053:15;7049:26;7119:9;7110:7;7106:23;7095:9;7088:42;7152:193;7215:4;7257:1;7235:6;:18;;;:23;7231:108;;7281:4;7274:11;;;;7231:108;7323:5;7316:12;;7152:193;;;;:::o;2195:5152::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::o;7:75:4:-;40:6;73:2;67:9;57:19;;7:75;:::o;88:117::-;197:1;194;187:12;211:117;320:1;317;310:12;334:117;443:1;440;433:12;457:102;498:6;549:2;545:7;540:2;533:5;529:14;525:28;515:38;;457:102;;;:::o;565:180::-;613:77;610:1;603:88;710:4;707:1;700:15;734:4;731:1;724:15;751:281;834:27;856:4;834:27;:::i;:::-;826:6;822:40;964:6;952:10;949:22;928:18;916:10;913:34;910:62;907:88;;;975:18;;:::i;:::-;907:88;1015:10;1011:2;1004:22;794:238;751:281;;:::o;1038:129::-;1072:6;1099:20;;:::i;:::-;1089:30;;1128:33;1156:4;1148:6;1128:33;:::i;:::-;1038:129;;;:::o;1173:311::-;1250:4;1340:18;1332:6;1329:30;1326:56;;;1362:18;;:::i;:::-;1326:56;1412:4;1404:6;1400:17;1392:25;;1472:4;1466;1462:15;1454:23;;1173:311;;;:::o;1490:117::-;1599:1;1596;1589:12;1613:126;1650:7;1690:42;1683:5;1679:54;1668:65;;1613:126;;;:::o;1745:96::-;1782:7;1811:24;1829:5;1811:24;:::i;:::-;1800:35;;1745:96;;;:::o;1847:122::-;1920:24;1938:5;1920:24;:::i;:::-;1913:5;1910:35;1900:63;;1959:1;1956;1949:12;1900:63;1847:122;:::o;1975:143::-;2032:5;2063:6;2057:13;2048:22;;2079:33;2106:5;2079:33;:::i;:::-;1975:143;;;;:::o;2141:732::-;2248:5;2273:81;2289:64;2346:6;2289:64;:::i;:::-;2273:81;:::i;:::-;2264:90;;2374:5;2403:6;2396:5;2389:21;2437:4;2430:5;2426:16;2419:23;;2490:4;2482:6;2478:17;2470:6;2466:30;2519:3;2511:6;2508:15;2505:122;;;2538:79;;:::i;:::-;2505:122;2653:6;2636:231;2670:6;2665:3;2662:15;2636:231;;;2745:3;2774:48;2818:3;2806:10;2774:48;:::i;:::-;2769:3;2762:61;2852:4;2847:3;2843:14;2836:21;;2712:155;2696:4;2691:3;2687:14;2680:21;;2636:231;;;2640:21;2254:619;;2141:732;;;;;:::o;2896:385::-;2978:5;3027:3;3020:4;3012:6;3008:17;3004:27;2994:122;;3035:79;;:::i;:::-;2994:122;3145:6;3139:13;3170:105;3271:3;3263:6;3256:4;3248:6;3244:17;3170:105;:::i;:::-;3161:114;;2984:297;2896:385;;;;:::o;3287:111::-;3372:1;3365:5;3362:12;3352:40;;3388:1;3385;3378:12;3352:40;3287:111;:::o;3404:167::-;3473:5;3504:6;3498:13;3489:22;;3520:45;3559:5;3520:45;:::i;:::-;3404:167;;;;:::o;3577:734::-;3693:6;3701;3750:2;3738:9;3729:7;3725:23;3721:32;3718:119;;;3756:79;;:::i;:::-;3718:119;3897:1;3886:9;3882:17;3876:24;3927:18;3919:6;3916:30;3913:117;;;3949:79;;:::i;:::-;3913:117;4054:89;4135:7;4126:6;4115:9;4111:22;4054:89;:::i;:::-;4044:99;;3847:306;4192:2;4218:76;4286:7;4277:6;4266:9;4262:22;4218:76;:::i;:::-;4208:86;;4163:141;3577:734;;;;;:::o;4317:180::-;4365:77;4362:1;4355:88;4462:4;4459:1;4452:15;4486:4;4483:1;4476:15;4503:180;4551:77;4548:1;4541:88;4648:4;4645:1;4638:15;4672:4;4669:1;4662:15;4689:351;4759:6;4808:2;4796:9;4787:7;4783:23;4779:32;4776:119;;;4814:79;;:::i;:::-;4776:119;4934:1;4959:64;5015:7;5006:6;4995:9;4991:22;4959:64;:::i;:::-;4949:74;;4905:128;4689:351;;;;:::o;5046:98::-;5097:6;5131:5;5125:12;5115:22;;5046:98;;;:::o;5150:147::-;5251:11;5288:3;5273:18;;5150:147;;;;:::o;5303:248::-;5385:1;5395:113;5409:6;5406:1;5403:13;5395:113;;;5494:1;5489:3;5485:11;5479:18;5475:1;5470:3;5466:11;5459:39;5431:2;5428:1;5424:10;5419:15;;5395:113;;;5542:1;5533:6;5528:3;5524:16;5517:27;5365:186;5303:248;;;:::o;5557:386::-;5661:3;5689:38;5721:5;5689:38;:::i;:::-;5743:88;5824:6;5819:3;5743:88;:::i;:::-;5736:95;;5840:65;5898:6;5893:3;5886:4;5879:5;5875:16;5840:65;:::i;:::-;5930:6;5925:3;5921:16;5914:23;;5665:278;5557:386;;;;:::o;5949:271::-;6079:3;6101:93;6190:3;6181:6;6101:93;:::i;:::-;6094:100;;6211:3;6204:10;;5949:271;;;;:::o;6226:77::-;6263:7;6292:5;6281:16;;6226:77;;;:::o;6309:122::-;6382:24;6400:5;6382:24;:::i;:::-;6375:5;6372:35;6362:63;;6421:1;6418;6411:12;6362:63;6309:122;:::o;6437:143::-;6494:5;6525:6;6519:13;6510:22;;6541:33;6568:5;6541:33;:::i;:::-;6437:143;;;;:::o;6586:351::-;6656:6;6705:2;6693:9;6684:7;6680:23;6676:32;6673:119;;;6711:79;;:::i;:::-;6673:119;6831:1;6856:64;6912:7;6903:6;6892:9;6888:22;6856:64;:::i;:::-;6846:74;;6802:128;6586:351;;;;:::o;6943:122::-;7016:24;7034:5;7016:24;:::i;:::-;7009:5;7006:35;6996:63;;7055:1;7052;7045:12;6996:63;6943:122;:::o;7071:143::-;7128:5;7159:6;7153:13;7144:22;;7175:33;7202:5;7175:33;:::i;:::-;7071:143;;;;:::o;7220:90::-;7255:7;7298:5;7295:1;7284:20;7273:31;;7220:90;;;:::o;7316:118::-;7387:22;7403:5;7387:22;:::i;:::-;7380:5;7377:33;7367:61;;7424:1;7421;7414:12;7367:61;7316:118;:::o;7440:139::-;7495:5;7526:6;7520:13;7511:22;;7542:31;7567:5;7542:31;:::i;:::-;7440:139;;;;:::o;7585:89::-;7621:7;7661:6;7654:5;7650:18;7639:29;;7585:89;;;:::o;7680:120::-;7752:23;7769:5;7752:23;:::i;:::-;7745:5;7742:34;7732:62;;7790:1;7787;7780:12;7732:62;7680:120;:::o;7806:141::-;7862:5;7893:6;7887:13;7878:22;;7909:32;7935:5;7909:32;:::i;:::-;7806:141;;;;:::o;7953:86::-;7988:7;8028:4;8021:5;8017:16;8006:27;;7953:86;;;:::o;8045:118::-;8116:22;8132:5;8116:22;:::i;:::-;8109:5;8106:33;8096:61;;8153:1;8150;8143:12;8096:61;8045:118;:::o;8169:139::-;8224:5;8255:6;8249:13;8240:22;;8271:31;8296:5;8271:31;:::i;:::-;8169:139;;;;:::o;8314:90::-;8348:7;8391:5;8384:13;8377:21;8366:32;;8314:90;;;:::o;8410:116::-;8480:21;8495:5;8480:21;:::i;:::-;8473:5;8470:32;8460:60;;8516:1;8513;8506:12;8460:60;8410:116;:::o;8532:137::-;8586:5;8617:6;8611:13;8602:22;;8633:30;8657:5;8633:30;:::i;:::-;8532:137;;;;:::o;8675:1271::-;8789:6;8797;8805;8813;8821;8829;8837;8886:3;8874:9;8865:7;8861:23;8857:33;8854:120;;;8893:79;;:::i;:::-;8854:120;9013:1;9038:64;9094:7;9085:6;9074:9;9070:22;9038:64;:::i;:::-;9028:74;;8984:128;9151:2;9177:62;9231:7;9222:6;9211:9;9207:22;9177:62;:::i;:::-;9167:72;;9122:127;9288:2;9314:63;9369:7;9360:6;9349:9;9345:22;9314:63;:::i;:::-;9304:73;;9259:128;9426:2;9452:63;9507:7;9498:6;9487:9;9483:22;9452:63;:::i;:::-;9442:73;;9397:128;9564:3;9591:63;9646:7;9637:6;9626:9;9622:22;9591:63;:::i;:::-;9581:73;;9535:129;9703:3;9730:62;9784:7;9775:6;9764:9;9760:22;9730:62;:::i;:::-;9720:72;;9674:128;9841:3;9868:61;9921:7;9912:6;9901:9;9897:22;9868:61;:::i;:::-;9858:71;;9812:127;8675:1271;;;;;;;;;;:::o;9952:112::-;10035:22;10051:5;10035:22;:::i;:::-;10030:3;10023:35;9952:112;;:::o;10070:214::-;10159:4;10197:2;10186:9;10182:18;10174:26;;10210:67;10274:1;10263:9;10259:17;10250:6;10210:67;:::i;:::-;10070:214;;;;:::o;10290:118::-;10327:7;10367:34;10360:5;10356:46;10345:57;;10290:118;;;:::o;10414:122::-;10487:24;10505:5;10487:24;:::i;:::-;10480:5;10477:35;10467:63;;10526:1;10523;10516:12;10467:63;10414:122;:::o;10542:143::-;10599:5;10630:6;10624:13;10615:22;;10646:33;10673:5;10646:33;:::i;:::-;10542:143;;;;:::o;10691:92::-;10727:7;10771:5;10767:2;10756:21;10745:32;;10691:92;;;:::o;10789:120::-;10861:23;10878:5;10861:23;:::i;:::-;10854:5;10851:34;10841:62;;10899:1;10896;10889:12;10841:62;10789:120;:::o;10915:141::-;10971:5;11002:6;10996:13;10987:22;;11018:32;11044:5;11018:32;:::i;:::-;10915:141;;;;:::o;11062:90::-;11097:7;11140:5;11137:1;11126:20;11115:31;;11062:90;;;:::o;11158:118::-;11229:22;11245:5;11229:22;:::i;:::-;11222:5;11219:33;11209:61;;11266:1;11263;11256:12;11209:61;11158:118;:::o;11282:139::-;11337:5;11368:6;11362:13;11353:22;;11384:31;11409:5;11384:31;:::i;:::-;11282:139;;;;:::o;11427:93::-;11463:7;11503:10;11496:5;11492:22;11481:33;;11427:93;;;:::o;11526:120::-;11598:23;11615:5;11598:23;:::i;:::-;11591:5;11588:34;11578:62;;11636:1;11633;11626:12;11578:62;11526:120;:::o;11652:141::-;11708:5;11739:6;11733:13;11724:22;;11755:32;11781:5;11755:32;:::i;:::-;11652:141;;;;:::o;11799:1434::-;11925:6;11933;11941;11949;11957;11965;11973;11981;12030:3;12018:9;12009:7;12005:23;12001:33;11998:120;;;12037:79;;:::i;:::-;11998:120;12157:1;12182:64;12238:7;12229:6;12218:9;12214:22;12182:64;:::i;:::-;12172:74;;12128:128;12295:2;12321:63;12376:7;12367:6;12356:9;12352:22;12321:63;:::i;:::-;12311:73;;12266:128;12433:2;12459:64;12515:7;12506:6;12495:9;12491:22;12459:64;:::i;:::-;12449:74;;12404:129;12572:2;12598:64;12654:7;12645:6;12634:9;12630:22;12598:64;:::i;:::-;12588:74;;12543:129;12711:3;12738:62;12792:7;12783:6;12772:9;12768:22;12738:62;:::i;:::-;12728:72;;12682:128;12849:3;12876:64;12932:7;12923:6;12912:9;12908:22;12876:64;:::i;:::-;12866:74;;12820:130;12989:3;13016:63;13071:7;13062:6;13051:9;13047:22;13016:63;:::i;:::-;13006:73;;12960:129;13128:3;13155:61;13208:7;13199:6;13188:9;13184:22;13155:61;:::i;:::-;13145:71;;13099:127;11799:1434;;;;;;;;;;;:::o;13239:351::-;13309:6;13358:2;13346:9;13337:7;13333:23;13329:32;13326:119;;;13364:79;;:::i;:::-;13326:119;13484:1;13509:64;13565:7;13556:6;13545:9;13541:22;13509:64;:::i;:::-;13499:74;;13455:128;13239:351;;;;:::o;13596:347::-;13664:6;13713:2;13701:9;13692:7;13688:23;13684:32;13681:119;;;13719:79;;:::i;:::-;13681:119;13839:1;13864:62;13918:7;13909:6;13898:9;13894:22;13864:62;:::i;:::-;13854:72;;13810:126;13596:347;;;;:::o;13949:91::-;13985:7;14025:8;14018:5;14014:20;14003:31;;13949:91;;;:::o;14046:120::-;14118:23;14135:5;14118:23;:::i;:::-;14111:5;14108:34;14098:62;;14156:1;14153;14146:12;14098:62;14046:120;:::o;14172:141::-;14228:5;14259:6;14253:13;14244:22;;14275:32;14301:5;14275:32;:::i;:::-;14172:141;;;;:::o;14319:349::-;14388:6;14437:2;14425:9;14416:7;14412:23;14408:32;14405:119;;;14443:79;;:::i;:::-;14405:119;14563:1;14588:63;14643:7;14634:6;14623:9;14619:22;14588:63;:::i;:::-;14578:73;;14534:127;14319:349;;;;:::o;14674:140::-;14767:6;14801:5;14795:12;14785:22;;14674:140;;;:::o;14820:210::-;14945:11;14979:6;14974:3;14967:19;15019:4;15014:3;15010:14;14995:29;;14820:210;;;;:::o;15036:158::-;15129:4;15152:3;15144:11;;15182:4;15177:3;15173:14;15165:22;;15036:158;;;:::o;15200:108::-;15277:24;15295:5;15277:24;:::i;:::-;15272:3;15265:37;15200:108;;:::o;15314:102::-;15387:22;15403:5;15387:22;:::i;:::-;15382:3;15375:35;15314:102;;:::o;15422:108::-;15499:24;15517:5;15499:24;:::i;:::-;15494:3;15487:37;15422:108;;:::o;15536:::-;15613:24;15631:5;15613:24;:::i;:::-;15608:3;15601:37;15536:108;;:::o;15650:102::-;15723:22;15739:5;15723:22;:::i;:::-;15718:3;15711:35;15650:102;;:::o;15758:105::-;15833:23;15850:5;15833:23;:::i;:::-;15828:3;15821:36;15758:105;;:::o;15869:::-;15944:23;15961:5;15944:23;:::i;:::-;15939:3;15932:36;15869:105;;:::o;16044:2111::-;16183:6;16178:3;16174:16;16276:4;16269:5;16265:16;16259:23;16295:63;16352:4;16347:3;16343:14;16329:12;16295:63;:::i;:::-;16200:168;16452:4;16445:5;16441:16;16435:23;16471:63;16528:4;16523:3;16519:14;16505:12;16471:63;:::i;:::-;16378:166;16636:4;16629:5;16625:16;16619:23;16655:59;16708:4;16703:3;16699:14;16685:12;16655:59;:::i;:::-;16554:170;16808:4;16801:5;16797:16;16791:23;16827:63;16884:4;16879:3;16875:14;16861:12;16827:63;:::i;:::-;16734:166;16992:4;16985:5;16981:16;16975:23;17011:59;17064:4;17059:3;17055:14;17041:12;17011:59;:::i;:::-;16910:170;17167:4;17160:5;17156:16;17150:23;17186:63;17243:4;17238:3;17234:14;17220:12;17186:63;:::i;:::-;17090:169;17346:4;17339:5;17335:16;17329:23;17365:63;17422:4;17417:3;17413:14;17399:12;17365:63;:::i;:::-;17269:169;17520:4;17513:5;17509:16;17503:23;17539:59;17592:4;17587:3;17583:14;17569:12;17539:59;:::i;:::-;17448:160;17697:6;17690:5;17686:18;17680:25;17718:61;17771:6;17766:3;17762:16;17748:12;17718:61;:::i;:::-;17618:171;17870:6;17863:5;17859:18;17853:25;17891:63;17946:6;17941:3;17937:16;17923:12;17891:63;:::i;:::-;17799:165;18054:6;18047:5;18043:18;18037:25;18075:63;18130:6;18125:3;18121:16;18107:12;18075:63;:::i;:::-;17974:174;16152:2003;16044:2111;;:::o;18161:285::-;18282:10;18303:98;18397:3;18389:6;18303:98;:::i;:::-;18433:6;18428:3;18424:16;18410:30;;18161:285;;;;:::o;18452:139::-;18548:4;18580;18575:3;18571:14;18563:22;;18452:139;;;:::o;18665:940::-;18836:3;18865:80;18939:5;18865:80;:::i;:::-;18961:112;19066:6;19061:3;18961:112;:::i;:::-;18954:119;;19097:82;19173:5;19097:82;:::i;:::-;19202:7;19233:1;19218:362;19243:6;19240:1;19237:13;19218:362;;;19319:6;19313:13;19346:115;19457:3;19442:13;19346:115;:::i;:::-;19339:122;;19484:86;19563:6;19484:86;:::i;:::-;19474:96;;19278:302;19265:1;19262;19258:9;19253:14;;19218:362;;;19222:14;19596:3;19589:10;;18841:764;;;18665:940;;;;:::o;19611:477::-;19806:4;19844:2;19833:9;19829:18;19821:26;;19893:9;19887:4;19883:20;19879:1;19868:9;19864:17;19857:47;19921:160;20076:4;20067:6;19921:160;:::i;:::-;19913:168;;19611:477;;;;:::o\",\"linkReferences\":{}},\"deployedBytecode\":{\"object\":\"0x6080604052348015600f57600080fd5b506004361060325760003560e01c806304626335146037578063c745d9e7146051575b600080fd5b603d606b565b6040516048919060e3565b60405180910390f35b60576070565b6040516062919060e3565b60405180910390f35b600181565b600081565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b6002811060b25760b16075565b5b50565b600081905060c18260a4565b919050565b600060cf8260b5565b9050919050565b60dd8160c6565b82525050565b600060208201905060f6600083018460d6565b9291505056fea2646970667358221220b1878bb6ce0e72a907552a31213ed53bf15a55904d63f7fb66950a3f8e36963964736f6c63430008190033\",\"sourceMap\":\"2195:5152:3:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2652:57;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;2597:49;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;2652:57;2690:19;2652:57;:::o;2597:49::-;2631:15;2597:49;:::o;7:180:4:-;55:77;52:1;45:88;152:4;149:1;142:15;176:4;173:1;166:15;193:117;278:1;271:5;268:12;258:46;;284:18;;:::i;:::-;258:46;193:117;:::o;316:135::-;365:7;394:5;383:16;;400:45;439:5;400:45;:::i;:::-;316:135;;;:::o;457:::-;517:9;550:36;580:5;550:36;:::i;:::-;537:49;;457:135;;;:::o;598:151::-;695:47;736:5;695:47;:::i;:::-;690:3;683:60;598:151;;:::o;755:242::-;858:4;896:2;885:9;881:18;873:26;;909:81;987:1;976:9;972:17;963:6;909:81;:::i;:::-;755:242;;;;:::o\",\"linkReferences\":{}},\"methodIdentifiers\":{\"PANCAKESWAP()\":\"04626335\",\"UNISWAP()\":\"c745d9e7\"},\"rawMetadata\":\"{\\\"compiler\\\":{\\\"version\\\":\\\"0.8.25+commit.b61c2a91\\\"},\\\"language\\\":\\\"Solidity\\\",\\\"output\\\":{\\\"abi\\\":[{\\\"inputs\\\":[{\\\"internalType\\\":\\\"address[]\\\",\\\"name\\\":\\\"pools\\\",\\\"type\\\":\\\"address[]\\\"},{\\\"internalType\\\":\\\"enum V3DataSync.DexType\\\",\\\"name\\\":\\\"dexType\\\",\\\"type\\\":\\\"uint8\\\"}],\\\"stateMutability\\\":\\\"nonpayable\\\",\\\"type\\\":\\\"constructor\\\"},{\\\"inputs\\\":[],\\\"name\\\":\\\"PANCAKESWAP\\\",\\\"outputs\\\":[{\\\"internalType\\\":\\\"enum V3DataSync.DexType\\\",\\\"name\\\":\\\"\\\",\\\"type\\\":\\\"uint8\\\"}],\\\"stateMutability\\\":\\\"view\\\",\\\"type\\\":\\\"function\\\"},{\\\"inputs\\\":[],\\\"name\\\":\\\"UNISWAP\\\",\\\"outputs\\\":[{\\\"internalType\\\":\\\"enum V3DataSync.DexType\\\",\\\"name\\\":\\\"\\\",\\\"type\\\":\\\"uint8\\\"}],\\\"stateMutability\\\":\\\"view\\\",\\\"type\\\":\\\"function\\\"}],\\\"devdoc\\\":{\\\"kind\\\":\\\"dev\\\",\\\"methods\\\":{},\\\"version\\\":1},\\\"userdoc\\\":{\\\"kind\\\":\\\"user\\\",\\\"methods\\\":{},\\\"version\\\":1}},\\\"settings\\\":{\\\"compilationTarget\\\":{\\\"src/V3DataSync.sol\\\":\\\"V3DataSync\\\"},\\\"evmVersion\\\":\\\"paris\\\",\\\"libraries\\\":{},\\\"metadata\\\":{\\\"bytecodeHash\\\":\\\"ipfs\\\"},\\\"optimizer\\\":{\\\"enabled\\\":false,\\\"runs\\\":200},\\\"remappings\\\":[\\\":forge-std/=lib/forge-std/src/\\\"]},\\\"sources\\\":{\\\"src/V3DataSync.sol\\\":{\\\"keccak256\\\":\\\"0x8cc45bf2d9ef5336a90d1259e933754a8d7986e2ce7a63af75eb5370cf8c6bc4\\\",\\\"license\\\":\\\"MIT\\\",\\\"urls\\\":[\\\"bzz-raw://bdd12caedfbcaa0c3f8e94e02a4cf587a5cd45d892cdb8db8231ca83c98e40fa\\\",\\\"dweb:/ipfs/Qmdb1kxWBPocX9Q1bGF6M3w2rubCmxjUp6X3okLjpZkNot\\\"]}},\\\"version\\\":1}\",\"metadata\":{\"compiler\":{\"version\":\"0.8.25+commit.b61c2a91\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"pools\",\"type\":\"address[]\"},{\"internalType\":\"enum V3DataSync.DexType\",\"name\":\"dexType\",\"type\":\"uint8\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"PANCAKESWAP\",\"outputs\":[{\"internalType\":\"enum V3DataSync.DexType\",\"name\":\"\",\"type\":\"uint8\"}]},{\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"UNISWAP\",\"outputs\":[{\"internalType\":\"enum V3DataSync.DexType\",\"name\":\"\",\"type\":\"uint8\"}]}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"remappings\":[\"forge-std/=lib/forge-std/src/\"],\"optimizer\":{\"enabled\":false,\"runs\":200},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"compilationTarget\":{\"src/V3DataSync.sol\":\"V3DataSync\"},\"evmVersion\":\"paris\",\"libraries\":{}},\"sources\":{\"src/V3DataSync.sol\":{\"keccak256\":\"0x8cc45bf2d9ef5336a90d1259e933754a8d7986e2ce7a63af75eb5370cf8c6bc4\",\"urls\":[\"bzz-raw://bdd12caedfbcaa0c3f8e94e02a4cf587a5cd45d892cdb8db8231ca83c98e40fa\",\"dweb:/ipfs/Qmdb1kxWBPocX9Q1bGF6M3w2rubCmxjUp6X3okLjpZkNot\"],\"license\":\"MIT\"}},\"version\":1},\"id\":3}";
        /**

Generated by the following Solidity interface...
```solidity
interface V3DataSync {
    type DexType is uint8;

    constructor(address[] pools, DexType dexType);

    function PANCAKESWAP() external view returns (DexType);
    function UNISWAP() external view returns (DexType);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "pools",
        "type": "address[]",
        "internalType": "address[]"
      },
      {
        "name": "dexType",
        "type": "uint8",
        "internalType": "enum V3DataSync.DexType"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "PANCAKESWAP",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint8",
        "internalType": "enum V3DataSync.DexType"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "UNISWAP",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint8",
        "internalType": "enum V3DataSync.DexType"
      }
    ],
    "stateMutability": "view"
  }
]
```*/
        #[allow(non_camel_case_types, non_snake_case, clippy::style)]
        pub mod V3DataSync {
            use super::*;
            use ::alloy::sol_types as alloy_sol_types;
            /// The creation / init bytecode of the contract.
            ///
            /// ```text
            ///0x608060405234801561001057600080fd5b506040516119453803806119458339818101604052810190610032919061110c565b6000825167ffffffffffffffff81111561004f5761004e610f46565b5b60405190808252806020026020018201604052801561008857816020015b610075610e44565b81526020019060019003908161006d5790505b50905060005b8351811015610de25760008482815181106100ac576100ab611168565b5b602002602001015190506100c581610e1160201b60201c565b156100d05750610dd7565b6100d8610e44565b81816000019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250506000600181111561012457610123611197565b5b85600181111561013757610136611197565b5b036102935760008290508073ffffffffffffffffffffffffffffffffffffffff16630dfe16816040518163ffffffff1660e01b8152600401602060405180830381865afa15801561018c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101b091906111c6565b826020019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250508073ffffffffffffffffffffffffffffffffffffffff1663d21220a76040518163ffffffff1660e01b8152600401602060405180830381865afa158015610232573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061025691906111c6565b826060019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250505061041d565b6001808111156102a6576102a5611197565b5b8560018111156102b9576102b8611197565b5b036104155760008290508073ffffffffffffffffffffffffffffffffffffffff16630dfe16816040518163ffffffff1660e01b8152600401602060405180830381865afa15801561030e573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061033291906111c6565b826020019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250508073ffffffffffffffffffffffffffffffffffffffff1663d21220a76040518163ffffffff1660e01b8152600401602060405180830381865afa1580156103b4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103d891906111c6565b826060019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250505061041c565b5050610dd7565b5b6104308160200151610e1160201b60201c565b1561043c575050610dd7565b61044f8160600151610e1160201b60201c565b1561045b575050610dd7565b600080826020015173ffffffffffffffffffffffffffffffffffffffff16614e206040516024016040516020818303038152906040527f313ce567000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff838183161783525050505060405161050c9190611264565b60006040518083038160008787f1925050503d806000811461054a576040519150601f19603f3d011682016040523d82523d6000602084013e61054f565b606091505b509150915081156105c057600060208251036105b0578180602001905181019061057991906112b1565b9050600081148061058a575060ff81115b15610599575050505050610dd7565b80846040019060ff16908160ff16815250506105ba565b5050505050610dd7565b506105c9565b50505050610dd7565b600080846060015173ffffffffffffffffffffffffffffffffffffffff16614e206040516024016040516020818303038152906040527f313ce567000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff838183161783525050505060405161067a9190611264565b60006040518083038160008787f1925050503d80600081146106b8576040519150601f19603f3d011682016040523d82523d6000602084013e6106bd565b606091505b50915091508115610732576000602082510361072057818060200190518101906106e791906112b1565b905060008114806106f8575060ff81115b156107095750505050505050610dd7565b80866080019060ff16908160ff168152505061072c565b50505050505050610dd7565b5061073d565b505050505050610dd7565b6000600181111561075157610750611197565b5b89600181111561076457610763611197565b5b03610a795760008690506000808273ffffffffffffffffffffffffffffffffffffffff16633850c7bd6040518163ffffffff1660e01b815260040160e060405180830381865afa1580156107bc573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107e091906113ee565b50505050509150915060008373ffffffffffffffffffffffffffffffffffffffff1663f30dba93836040518263ffffffff1660e01b8152600401610824919061149f565b61010060405180830381865afa158015610842573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061086691906115b0565b5050505050509150508373ffffffffffffffffffffffffffffffffffffffff16631a6865026040518163ffffffff1660e01b8152600401602060405180830381865afa1580156108ba573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108de9190611666565b8960a001906fffffffffffffffffffffffffffffffff1690816fffffffffffffffffffffffffffffffff16815250508373ffffffffffffffffffffffffffffffffffffffff1663d0c93a7c6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610958573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061097c9190611693565b89610100019060020b908160020b815250508373ffffffffffffffffffffffffffffffffffffffff1663ddca3f436040518163ffffffff1660e01b8152600401602060405180830381865afa1580156109d9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109fd91906116fb565b89610120019062ffffff16908162ffffff1681525050828960c0019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff1681525050818960e0019060020b908160020b8152505080896101400190600f0b9081600f0b8152505050505050610db1565b600180811115610a8c57610a8b611197565b5b896001811115610a9f57610a9e611197565b5b03610db05760008690506000808273ffffffffffffffffffffffffffffffffffffffff16633850c7bd6040518163ffffffff1660e01b815260040160e060405180830381865afa158015610af7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b1b91906113ee565b50505050509150915060008373ffffffffffffffffffffffffffffffffffffffff1663f30dba93836040518263ffffffff1660e01b8152600401610b5f919061149f565b61010060405180830381865afa158015610b7d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ba191906115b0565b5050505050509150508373ffffffffffffffffffffffffffffffffffffffff16631a6865026040518163ffffffff1660e01b8152600401602060405180830381865afa158015610bf5573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c199190611666565b8960a001906fffffffffffffffffffffffffffffffff1690816fffffffffffffffffffffffffffffffff16815250508373ffffffffffffffffffffffffffffffffffffffff1663d0c93a7c6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610c93573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610cb79190611693565b89610100019060020b908160020b815250508373ffffffffffffffffffffffffffffffffffffffff1663ddca3f436040518163ffffffff1660e01b8152600401602060405180830381865afa158015610d14573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d3891906116fb565b89610120019062ffffff16908162ffffff1681525050828960c0019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff1681525050818960e0019060020b908160020b8152505080896101400190600f0b9081600f0b81525050505050505b5b84888881518110610dc557610dc4611168565b5b60200260200101819052505050505050505b80600101905061008e565b50600081604051602001610df69190611922565b60405160208183030381529060405290506020810180590381f35b6000808273ffffffffffffffffffffffffffffffffffffffff163b03610e3a5760019050610e3f565b600090505b919050565b604051806101600160405280600073ffffffffffffffffffffffffffffffffffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff168152602001600060ff168152602001600073ffffffffffffffffffffffffffffffffffffffff168152602001600060ff16815260200160006fffffffffffffffffffffffffffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff168152602001600060020b8152602001600060020b8152602001600062ffffff1681526020016000600f0b81525090565b6000604051905090565b600080fd5b600080fd5b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b610f7e82610f35565b810181811067ffffffffffffffff82111715610f9d57610f9c610f46565b5b80604052505050565b6000610fb0610f1c565b9050610fbc8282610f75565b919050565b600067ffffffffffffffff821115610fdc57610fdb610f46565b5b602082029050602081019050919050565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b600061101d82610ff2565b9050919050565b61102d81611012565b811461103857600080fd5b50565b60008151905061104a81611024565b92915050565b600061106361105e84610fc1565b610fa6565b9050808382526020820190506020840283018581111561108657611085610fed565b5b835b818110156110af578061109b888261103b565b845260208401935050602081019050611088565b5050509392505050565b600082601f8301126110ce576110cd610f30565b5b81516110de848260208601611050565b91505092915050565b600281106110f457600080fd5b50565b600081519050611106816110e7565b92915050565b6000806040838503121561112357611122610f26565b5b600083015167ffffffffffffffff81111561114157611140610f2b565b5b61114d858286016110b9565b925050602061115e858286016110f7565b9150509250929050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b6000602082840312156111dc576111db610f26565b5b60006111ea8482850161103b565b91505092915050565b600081519050919050565b600081905092915050565b60005b8381101561122757808201518184015260208101905061120c565b60008484015250505050565b600061123e826111f3565b61124881856111fe565b9350611258818560208601611209565b80840191505092915050565b60006112708284611233565b915081905092915050565b6000819050919050565b61128e8161127b565b811461129957600080fd5b50565b6000815190506112ab81611285565b92915050565b6000602082840312156112c7576112c6610f26565b5b60006112d58482850161129c565b91505092915050565b6112e781610ff2565b81146112f257600080fd5b50565b600081519050611304816112de565b92915050565b60008160020b9050919050565b6113208161130a565b811461132b57600080fd5b50565b60008151905061133d81611317565b92915050565b600061ffff82169050919050565b61135a81611343565b811461136557600080fd5b50565b60008151905061137781611351565b92915050565b600060ff82169050919050565b6113938161137d565b811461139e57600080fd5b50565b6000815190506113b08161138a565b92915050565b60008115159050919050565b6113cb816113b6565b81146113d657600080fd5b50565b6000815190506113e8816113c2565b92915050565b600080600080600080600060e0888a03121561140d5761140c610f26565b5b600061141b8a828b016112f5565b975050602061142c8a828b0161132e565b965050604061143d8a828b01611368565b955050606061144e8a828b01611368565b945050608061145f8a828b01611368565b93505060a06114708a828b016113a1565b92505060c06114818a828b016113d9565b91505092959891949750929550565b6114998161130a565b82525050565b60006020820190506114b46000830184611490565b92915050565b60006fffffffffffffffffffffffffffffffff82169050919050565b6114df816114ba565b81146114ea57600080fd5b50565b6000815190506114fc816114d6565b92915050565b600081600f0b9050919050565b61151881611502565b811461152357600080fd5b50565b6000815190506115358161150f565b92915050565b60008160060b9050919050565b6115518161153b565b811461155c57600080fd5b50565b60008151905061156e81611548565b92915050565b600063ffffffff82169050919050565b61158d81611574565b811461159857600080fd5b50565b6000815190506115aa81611584565b92915050565b600080600080600080600080610100898b0312156115d1576115d0610f26565b5b60006115df8b828c016114ed565b98505060206115f08b828c01611526565b97505060406116018b828c0161129c565b96505060606116128b828c0161129c565b95505060806116238b828c0161155f565b94505060a06116348b828c016112f5565b93505060c06116458b828c0161159b565b92505060e06116568b828c016113d9565b9150509295985092959890939650565b60006020828403121561167c5761167b610f26565b5b600061168a848285016114ed565b91505092915050565b6000602082840312156116a9576116a8610f26565b5b60006116b78482850161132e565b91505092915050565b600062ffffff82169050919050565b6116d8816116c0565b81146116e357600080fd5b50565b6000815190506116f5816116cf565b92915050565b60006020828403121561171157611710610f26565b5b600061171f848285016116e6565b91505092915050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b61175d81611012565b82525050565b61176c8161137d565b82525050565b61177b816114ba565b82525050565b61178a81610ff2565b82525050565b6117998161130a565b82525050565b6117a8816116c0565b82525050565b6117b781611502565b82525050565b610160820160008201516117d46000850182611754565b5060208201516117e76020850182611754565b5060408201516117fa6040850182611763565b50606082015161180d6060850182611754565b5060808201516118206080850182611763565b5060a082015161183360a0850182611772565b5060c082015161184660c0850182611781565b5060e082015161185960e0850182611790565b5061010082015161186e610100850182611790565b5061012082015161188361012085018261179f565b506101408201516118986101408501826117ae565b50505050565b60006118aa83836117bd565b6101608301905092915050565b6000602082019050919050565b60006118cf82611728565b6118d98185611733565b93506118e483611744565b8060005b838110156119155781516118fc888261189e565b9750611907836118b7565b9250506001810190506118e8565b5085935050505092915050565b6000602082019050818103600083015261193c81846118c4565b90509291505056fe
            /// ```
            #[rustfmt::skip]
            #[allow(clippy::all)]
            pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
                b"`\x80`@R4\x80\x15a\x00\x10W`\x00\x80\xfd[P`@Qa\x19E8\x03\x80a\x19E\x839\x81\x81\x01`@R\x81\x01\x90a\x002\x91\x90a\x11\x0cV[`\x00\x82Qg\xff\xff\xff\xff\xff\xff\xff\xff\x81\x11\x15a\x00OWa\x00Na\x0fFV[[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x00\x88W\x81` \x01[a\x00ua\x0eDV[\x81R` \x01\x90`\x01\x90\x03\x90\x81a\x00mW\x90P[P\x90P`\x00[\x83Q\x81\x10\x15a\r\xe2W`\x00\x84\x82\x81Q\x81\x10a\x00\xacWa\x00\xaba\x11hV[[` \x02` \x01\x01Q\x90Pa\x00\xc5\x81a\x0e\x11` \x1b` \x1cV[\x15a\x00\xd0WPa\r\xd7V[a\x00\xd8a\x0eDV[\x81\x81`\x00\x01\x90s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16\x90\x81s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16\x81RPP`\x00`\x01\x81\x11\x15a\x01$Wa\x01#a\x11\x97V[[\x85`\x01\x81\x11\x15a\x017Wa\x016a\x11\x97V[[\x03a\x02\x93W`\x00\x82\x90P\x80s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16c\r\xfe\x16\x81`@Q\x81c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x01\x8cW=`\x00\x80>=`\x00\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x01\xb0\x91\x90a\x11\xc6V[\x82` \x01\x90s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16\x90\x81s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16\x81RPP\x80s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16c\xd2\x12 \xa7`@Q\x81c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x022W=`\x00\x80>=`\x00\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x02V\x91\x90a\x11\xc6V[\x82``\x01\x90s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16\x90\x81s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16\x81RPPPa\x04\x1dV[`\x01\x80\x81\x11\x15a\x02\xa6Wa\x02\xa5a\x11\x97V[[\x85`\x01\x81\x11\x15a\x02\xb9Wa\x02\xb8a\x11\x97V[[\x03a\x04\x15W`\x00\x82\x90P\x80s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16c\r\xfe\x16\x81`@Q\x81c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x03\x0eW=`\x00\x80>=`\x00\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x032\x91\x90a\x11\xc6V[\x82` \x01\x90s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16\x90\x81s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16\x81RPP\x80s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16c\xd2\x12 \xa7`@Q\x81c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x03\xb4W=`\x00\x80>=`\x00\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x03\xd8\x91\x90a\x11\xc6V[\x82``\x01\x90s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16\x90\x81s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16\x81RPPPa\x04\x1cV[PPa\r\xd7V[[a\x040\x81` \x01Qa\x0e\x11` \x1b` \x1cV[\x15a\x04<WPPa\r\xd7V[a\x04O\x81``\x01Qa\x0e\x11` \x1b` \x1cV[\x15a\x04[WPPa\r\xd7V[`\x00\x80\x82` \x01Qs\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16aN `@Q`$\x01`@Q` \x81\x83\x03\x03\x81R\x90`@R\x7f1<\xe5g\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00{\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x19\x16` \x82\x01\x80Q{\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x83\x81\x83\x16\x17\x83RPPPP`@Qa\x05\x0c\x91\x90a\x12dV[`\x00`@Q\x80\x83\x03\x81`\x00\x87\x87\xf1\x92PPP=\x80`\x00\x81\x14a\x05JW`@Q\x91P`\x1f\x19`?=\x01\x16\x82\x01`@R=\x82R=`\x00` \x84\x01>a\x05OV[``\x91P[P\x91P\x91P\x81\x15a\x05\xc0W`\x00` \x82Q\x03a\x05\xb0W\x81\x80` \x01\x90Q\x81\x01\x90a\x05y\x91\x90a\x12\xb1V[\x90P`\x00\x81\x14\x80a\x05\x8aWP`\xff\x81\x11[\x15a\x05\x99WPPPPPa\r\xd7V[\x80\x84`@\x01\x90`\xff\x16\x90\x81`\xff\x16\x81RPPa\x05\xbaV[PPPPPa\r\xd7V[Pa\x05\xc9V[PPPPa\r\xd7V[`\x00\x80\x84``\x01Qs\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16aN `@Q`$\x01`@Q` \x81\x83\x03\x03\x81R\x90`@R\x7f1<\xe5g\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00{\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x19\x16` \x82\x01\x80Q{\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x83\x81\x83\x16\x17\x83RPPPP`@Qa\x06z\x91\x90a\x12dV[`\x00`@Q\x80\x83\x03\x81`\x00\x87\x87\xf1\x92PPP=\x80`\x00\x81\x14a\x06\xb8W`@Q\x91P`\x1f\x19`?=\x01\x16\x82\x01`@R=\x82R=`\x00` \x84\x01>a\x06\xbdV[``\x91P[P\x91P\x91P\x81\x15a\x072W`\x00` \x82Q\x03a\x07 W\x81\x80` \x01\x90Q\x81\x01\x90a\x06\xe7\x91\x90a\x12\xb1V[\x90P`\x00\x81\x14\x80a\x06\xf8WP`\xff\x81\x11[\x15a\x07\tWPPPPPPPa\r\xd7V[\x80\x86`\x80\x01\x90`\xff\x16\x90\x81`\xff\x16\x81RPPa\x07,V[PPPPPPPa\r\xd7V[Pa\x07=V[PPPPPPa\r\xd7V[`\x00`\x01\x81\x11\x15a\x07QWa\x07Pa\x11\x97V[[\x89`\x01\x81\x11\x15a\x07dWa\x07ca\x11\x97V[[\x03a\nyW`\x00\x86\x90P`\x00\x80\x82s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16c8P\xc7\xbd`@Q\x81c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01`\xe0`@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x07\xbcW=`\x00\x80>=`\x00\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x07\xe0\x91\x90a\x13\xeeV[PPPPP\x91P\x91P`\x00\x83s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16c\xf3\r\xba\x93\x83`@Q\x82c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01a\x08$\x91\x90a\x14\x9fV[a\x01\x00`@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x08BW=`\x00\x80>=`\x00\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x08f\x91\x90a\x15\xb0V[PPPPPP\x91PP\x83s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16c\x1ahe\x02`@Q\x81c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x08\xbaW=`\x00\x80>=`\x00\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x08\xde\x91\x90a\x16fV[\x89`\xa0\x01\x90o\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16\x90\x81o\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16\x81RPP\x83s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16c\xd0\xc9:|`@Q\x81c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\tXW=`\x00\x80>=`\x00\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\t|\x91\x90a\x16\x93V[\x89a\x01\x00\x01\x90`\x02\x0b\x90\x81`\x02\x0b\x81RPP\x83s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16c\xdd\xca?C`@Q\x81c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\t\xd9W=`\x00\x80>=`\x00\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\t\xfd\x91\x90a\x16\xfbV[\x89a\x01 \x01\x90b\xff\xff\xff\x16\x90\x81b\xff\xff\xff\x16\x81RPP\x82\x89`\xc0\x01\x90s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16\x90\x81s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16\x81RPP\x81\x89`\xe0\x01\x90`\x02\x0b\x90\x81`\x02\x0b\x81RPP\x80\x89a\x01@\x01\x90`\x0f\x0b\x90\x81`\x0f\x0b\x81RPPPPPPa\r\xb1V[`\x01\x80\x81\x11\x15a\n\x8cWa\n\x8ba\x11\x97V[[\x89`\x01\x81\x11\x15a\n\x9fWa\n\x9ea\x11\x97V[[\x03a\r\xb0W`\x00\x86\x90P`\x00\x80\x82s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16c8P\xc7\xbd`@Q\x81c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01`\xe0`@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\n\xf7W=`\x00\x80>=`\x00\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0b\x1b\x91\x90a\x13\xeeV[PPPPP\x91P\x91P`\x00\x83s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16c\xf3\r\xba\x93\x83`@Q\x82c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01a\x0b_\x91\x90a\x14\x9fV[a\x01\x00`@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x0b}W=`\x00\x80>=`\x00\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0b\xa1\x91\x90a\x15\xb0V[PPPPPP\x91PP\x83s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16c\x1ahe\x02`@Q\x81c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x0b\xf5W=`\x00\x80>=`\x00\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0c\x19\x91\x90a\x16fV[\x89`\xa0\x01\x90o\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16\x90\x81o\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16\x81RPP\x83s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16c\xd0\xc9:|`@Q\x81c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x0c\x93W=`\x00\x80>=`\x00\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0c\xb7\x91\x90a\x16\x93V[\x89a\x01\x00\x01\x90`\x02\x0b\x90\x81`\x02\x0b\x81RPP\x83s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16c\xdd\xca?C`@Q\x81c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\r\x14W=`\x00\x80>=`\x00\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\r8\x91\x90a\x16\xfbV[\x89a\x01 \x01\x90b\xff\xff\xff\x16\x90\x81b\xff\xff\xff\x16\x81RPP\x82\x89`\xc0\x01\x90s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16\x90\x81s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16\x81RPP\x81\x89`\xe0\x01\x90`\x02\x0b\x90\x81`\x02\x0b\x81RPP\x80\x89a\x01@\x01\x90`\x0f\x0b\x90\x81`\x0f\x0b\x81RPPPPPP[[\x84\x88\x88\x81Q\x81\x10a\r\xc5Wa\r\xc4a\x11hV[[` \x02` \x01\x01\x81\x90RPPPPPPP[\x80`\x01\x01\x90Pa\x00\x8eV[P`\x00\x81`@Q` \x01a\r\xf6\x91\x90a\x19\"V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x90P` \x81\x01\x80Y\x03\x81\xf3[`\x00\x80\x82s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16;\x03a\x0e:W`\x01\x90Pa\x0e?V[`\x00\x90P[\x91\x90PV[`@Q\x80a\x01`\x01`@R\x80`\x00s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16\x81R` \x01`\x00s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16\x81R` \x01`\x00`\xff\x16\x81R` \x01`\x00s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16\x81R` \x01`\x00`\xff\x16\x81R` \x01`\x00o\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16\x81R` \x01`\x00s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16\x81R` \x01`\x00`\x02\x0b\x81R` \x01`\x00`\x02\x0b\x81R` \x01`\x00b\xff\xff\xff\x16\x81R` \x01`\x00`\x0f\x0b\x81RP\x90V[`\x00`@Q\x90P\x90V[`\x00\x80\xfd[`\x00\x80\xfd[`\x00\x80\xfd[`\x00`\x1f\x19`\x1f\x83\x01\x16\x90P\x91\x90PV[\x7fNH{q\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00`\x00R`A`\x04R`$`\x00\xfd[a\x0f~\x82a\x0f5V[\x81\x01\x81\x81\x10g\xff\xff\xff\xff\xff\xff\xff\xff\x82\x11\x17\x15a\x0f\x9dWa\x0f\x9ca\x0fFV[[\x80`@RPPPV[`\x00a\x0f\xb0a\x0f\x1cV[\x90Pa\x0f\xbc\x82\x82a\x0fuV[\x91\x90PV[`\x00g\xff\xff\xff\xff\xff\xff\xff\xff\x82\x11\x15a\x0f\xdcWa\x0f\xdba\x0fFV[[` \x82\x02\x90P` \x81\x01\x90P\x91\x90PV[`\x00\x80\xfd[`\x00s\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x82\x16\x90P\x91\x90PV[`\x00a\x10\x1d\x82a\x0f\xf2V[\x90P\x91\x90PV[a\x10-\x81a\x10\x12V[\x81\x14a\x108W`\x00\x80\xfd[PV[`\x00\x81Q\x90Pa\x10J\x81a\x10$V[\x92\x91PPV[`\x00a\x10ca\x10^\x84a\x0f\xc1V[a\x0f\xa6V[\x90P\x80\x83\x82R` \x82\x01\x90P` \x84\x02\x83\x01\x85\x81\x11\x15a\x10\x86Wa\x10\x85a\x0f\xedV[[\x83[\x81\x81\x10\x15a\x10\xafW\x80a\x10\x9b\x88\x82a\x10;V[\x84R` \x84\x01\x93PP` \x81\x01\x90Pa\x10\x88V[PPP\x93\x92PPPV[`\x00\x82`\x1f\x83\x01\x12a\x10\xceWa\x10\xcda\x0f0V[[\x81Qa\x10\xde\x84\x82` \x86\x01a\x10PV[\x91PP\x92\x91PPV[`\x02\x81\x10a\x10\xf4W`\x00\x80\xfd[PV[`\x00\x81Q\x90Pa\x11\x06\x81a\x10\xe7V[\x92\x91PPV[`\x00\x80`@\x83\x85\x03\x12\x15a\x11#Wa\x11\"a\x0f&V[[`\x00\x83\x01Qg\xff\xff\xff\xff\xff\xff\xff\xff\x81\x11\x15a\x11AWa\x11@a\x0f+V[[a\x11M\x85\x82\x86\x01a\x10\xb9V[\x92PP` a\x11^\x85\x82\x86\x01a\x10\xf7V[\x91PP\x92P\x92\x90PV[\x7fNH{q\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00`\x00R`2`\x04R`$`\x00\xfd[\x7fNH{q\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00`\x00R`!`\x04R`$`\x00\xfd[`\x00` \x82\x84\x03\x12\x15a\x11\xdcWa\x11\xdba\x0f&V[[`\x00a\x11\xea\x84\x82\x85\x01a\x10;V[\x91PP\x92\x91PPV[`\x00\x81Q\x90P\x91\x90PV[`\x00\x81\x90P\x92\x91PPV[`\x00[\x83\x81\x10\x15a\x12\'W\x80\x82\x01Q\x81\x84\x01R` \x81\x01\x90Pa\x12\x0cV[`\x00\x84\x84\x01RPPPPV[`\x00a\x12>\x82a\x11\xf3V[a\x12H\x81\x85a\x11\xfeV[\x93Pa\x12X\x81\x85` \x86\x01a\x12\tV[\x80\x84\x01\x91PP\x92\x91PPV[`\x00a\x12p\x82\x84a\x123V[\x91P\x81\x90P\x92\x91PPV[`\x00\x81\x90P\x91\x90PV[a\x12\x8e\x81a\x12{V[\x81\x14a\x12\x99W`\x00\x80\xfd[PV[`\x00\x81Q\x90Pa\x12\xab\x81a\x12\x85V[\x92\x91PPV[`\x00` \x82\x84\x03\x12\x15a\x12\xc7Wa\x12\xc6a\x0f&V[[`\x00a\x12\xd5\x84\x82\x85\x01a\x12\x9cV[\x91PP\x92\x91PPV[a\x12\xe7\x81a\x0f\xf2V[\x81\x14a\x12\xf2W`\x00\x80\xfd[PV[`\x00\x81Q\x90Pa\x13\x04\x81a\x12\xdeV[\x92\x91PPV[`\x00\x81`\x02\x0b\x90P\x91\x90PV[a\x13 \x81a\x13\nV[\x81\x14a\x13+W`\x00\x80\xfd[PV[`\x00\x81Q\x90Pa\x13=\x81a\x13\x17V[\x92\x91PPV[`\x00a\xff\xff\x82\x16\x90P\x91\x90PV[a\x13Z\x81a\x13CV[\x81\x14a\x13eW`\x00\x80\xfd[PV[`\x00\x81Q\x90Pa\x13w\x81a\x13QV[\x92\x91PPV[`\x00`\xff\x82\x16\x90P\x91\x90PV[a\x13\x93\x81a\x13}V[\x81\x14a\x13\x9eW`\x00\x80\xfd[PV[`\x00\x81Q\x90Pa\x13\xb0\x81a\x13\x8aV[\x92\x91PPV[`\x00\x81\x15\x15\x90P\x91\x90PV[a\x13\xcb\x81a\x13\xb6V[\x81\x14a\x13\xd6W`\x00\x80\xfd[PV[`\x00\x81Q\x90Pa\x13\xe8\x81a\x13\xc2V[\x92\x91PPV[`\x00\x80`\x00\x80`\x00\x80`\x00`\xe0\x88\x8a\x03\x12\x15a\x14\rWa\x14\x0ca\x0f&V[[`\x00a\x14\x1b\x8a\x82\x8b\x01a\x12\xf5V[\x97PP` a\x14,\x8a\x82\x8b\x01a\x13.V[\x96PP`@a\x14=\x8a\x82\x8b\x01a\x13hV[\x95PP``a\x14N\x8a\x82\x8b\x01a\x13hV[\x94PP`\x80a\x14_\x8a\x82\x8b\x01a\x13hV[\x93PP`\xa0a\x14p\x8a\x82\x8b\x01a\x13\xa1V[\x92PP`\xc0a\x14\x81\x8a\x82\x8b\x01a\x13\xd9V[\x91PP\x92\x95\x98\x91\x94\x97P\x92\x95PV[a\x14\x99\x81a\x13\nV[\x82RPPV[`\x00` \x82\x01\x90Pa\x14\xb4`\x00\x83\x01\x84a\x14\x90V[\x92\x91PPV[`\x00o\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x82\x16\x90P\x91\x90PV[a\x14\xdf\x81a\x14\xbaV[\x81\x14a\x14\xeaW`\x00\x80\xfd[PV[`\x00\x81Q\x90Pa\x14\xfc\x81a\x14\xd6V[\x92\x91PPV[`\x00\x81`\x0f\x0b\x90P\x91\x90PV[a\x15\x18\x81a\x15\x02V[\x81\x14a\x15#W`\x00\x80\xfd[PV[`\x00\x81Q\x90Pa\x155\x81a\x15\x0fV[\x92\x91PPV[`\x00\x81`\x06\x0b\x90P\x91\x90PV[a\x15Q\x81a\x15;V[\x81\x14a\x15\\W`\x00\x80\xfd[PV[`\x00\x81Q\x90Pa\x15n\x81a\x15HV[\x92\x91PPV[`\x00c\xff\xff\xff\xff\x82\x16\x90P\x91\x90PV[a\x15\x8d\x81a\x15tV[\x81\x14a\x15\x98W`\x00\x80\xfd[PV[`\x00\x81Q\x90Pa\x15\xaa\x81a\x15\x84V[\x92\x91PPV[`\x00\x80`\x00\x80`\x00\x80`\x00\x80a\x01\x00\x89\x8b\x03\x12\x15a\x15\xd1Wa\x15\xd0a\x0f&V[[`\x00a\x15\xdf\x8b\x82\x8c\x01a\x14\xedV[\x98PP` a\x15\xf0\x8b\x82\x8c\x01a\x15&V[\x97PP`@a\x16\x01\x8b\x82\x8c\x01a\x12\x9cV[\x96PP``a\x16\x12\x8b\x82\x8c\x01a\x12\x9cV[\x95PP`\x80a\x16#\x8b\x82\x8c\x01a\x15_V[\x94PP`\xa0a\x164\x8b\x82\x8c\x01a\x12\xf5V[\x93PP`\xc0a\x16E\x8b\x82\x8c\x01a\x15\x9bV[\x92PP`\xe0a\x16V\x8b\x82\x8c\x01a\x13\xd9V[\x91PP\x92\x95\x98P\x92\x95\x98\x90\x93\x96PV[`\x00` \x82\x84\x03\x12\x15a\x16|Wa\x16{a\x0f&V[[`\x00a\x16\x8a\x84\x82\x85\x01a\x14\xedV[\x91PP\x92\x91PPV[`\x00` \x82\x84\x03\x12\x15a\x16\xa9Wa\x16\xa8a\x0f&V[[`\x00a\x16\xb7\x84\x82\x85\x01a\x13.V[\x91PP\x92\x91PPV[`\x00b\xff\xff\xff\x82\x16\x90P\x91\x90PV[a\x16\xd8\x81a\x16\xc0V[\x81\x14a\x16\xe3W`\x00\x80\xfd[PV[`\x00\x81Q\x90Pa\x16\xf5\x81a\x16\xcfV[\x92\x91PPV[`\x00` \x82\x84\x03\x12\x15a\x17\x11Wa\x17\x10a\x0f&V[[`\x00a\x17\x1f\x84\x82\x85\x01a\x16\xe6V[\x91PP\x92\x91PPV[`\x00\x81Q\x90P\x91\x90PV[`\x00\x82\x82R` \x82\x01\x90P\x92\x91PPV[`\x00\x81\x90P` \x82\x01\x90P\x91\x90PV[a\x17]\x81a\x10\x12V[\x82RPPV[a\x17l\x81a\x13}V[\x82RPPV[a\x17{\x81a\x14\xbaV[\x82RPPV[a\x17\x8a\x81a\x0f\xf2V[\x82RPPV[a\x17\x99\x81a\x13\nV[\x82RPPV[a\x17\xa8\x81a\x16\xc0V[\x82RPPV[a\x17\xb7\x81a\x15\x02V[\x82RPPV[a\x01`\x82\x01`\x00\x82\x01Qa\x17\xd4`\x00\x85\x01\x82a\x17TV[P` \x82\x01Qa\x17\xe7` \x85\x01\x82a\x17TV[P`@\x82\x01Qa\x17\xfa`@\x85\x01\x82a\x17cV[P``\x82\x01Qa\x18\r``\x85\x01\x82a\x17TV[P`\x80\x82\x01Qa\x18 `\x80\x85\x01\x82a\x17cV[P`\xa0\x82\x01Qa\x183`\xa0\x85\x01\x82a\x17rV[P`\xc0\x82\x01Qa\x18F`\xc0\x85\x01\x82a\x17\x81V[P`\xe0\x82\x01Qa\x18Y`\xe0\x85\x01\x82a\x17\x90V[Pa\x01\x00\x82\x01Qa\x18na\x01\x00\x85\x01\x82a\x17\x90V[Pa\x01 \x82\x01Qa\x18\x83a\x01 \x85\x01\x82a\x17\x9fV[Pa\x01@\x82\x01Qa\x18\x98a\x01@\x85\x01\x82a\x17\xaeV[PPPPV[`\x00a\x18\xaa\x83\x83a\x17\xbdV[a\x01`\x83\x01\x90P\x92\x91PPV[`\x00` \x82\x01\x90P\x91\x90PV[`\x00a\x18\xcf\x82a\x17(V[a\x18\xd9\x81\x85a\x173V[\x93Pa\x18\xe4\x83a\x17DV[\x80`\x00[\x83\x81\x10\x15a\x19\x15W\x81Qa\x18\xfc\x88\x82a\x18\x9eV[\x97Pa\x19\x07\x83a\x18\xb7V[\x92PP`\x01\x81\x01\x90Pa\x18\xe8V[P\x85\x93PPPP\x92\x91PPV[`\x00` \x82\x01\x90P\x81\x81\x03`\x00\x83\x01Ra\x19<\x81\x84a\x18\xc4V[\x90P\x92\x91PPV\xfe",
            );
            /// The runtime bytecode of the contract, as deployed on the network.
            ///
            /// ```text
            ///0x6080604052348015600f57600080fd5b506004361060325760003560e01c806304626335146037578063c745d9e7146051575b600080fd5b603d606b565b6040516048919060e3565b60405180910390f35b60576070565b6040516062919060e3565b60405180910390f35b600181565b600081565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b6002811060b25760b16075565b5b50565b600081905060c18260a4565b919050565b600060cf8260b5565b9050919050565b60dd8160c6565b82525050565b600060208201905060f6600083018460d6565b9291505056fea2646970667358221220b1878bb6ce0e72a907552a31213ed53bf15a55904d63f7fb66950a3f8e36963964736f6c63430008190033
            /// ```
            #[rustfmt::skip]
            #[allow(clippy::all)]
            pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
                b"`\x80`@R4\x80\x15`\x0fW`\x00\x80\xfd[P`\x046\x10`2W`\x005`\xe0\x1c\x80c\x04bc5\x14`7W\x80c\xc7E\xd9\xe7\x14`QW[`\x00\x80\xfd[`=`kV[`@Q`H\x91\x90`\xe3V[`@Q\x80\x91\x03\x90\xf3[`W`pV[`@Q`b\x91\x90`\xe3V[`@Q\x80\x91\x03\x90\xf3[`\x01\x81V[`\x00\x81V[\x7fNH{q\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00`\x00R`!`\x04R`$`\x00\xfd[`\x02\x81\x10`\xb2W`\xb1`uV[[PV[`\x00\x81\x90P`\xc1\x82`\xa4V[\x91\x90PV[`\x00`\xcf\x82`\xb5V[\x90P\x91\x90PV[`\xdd\x81`\xc6V[\x82RPPV[`\x00` \x82\x01\x90P`\xf6`\x00\x83\x01\x84`\xd6V[\x92\x91PPV\xfe\xa2dipfsX\"\x12 \xb1\x87\x8b\xb6\xce\x0er\xa9\x07U*1!>\xd5;\xf1ZU\x90Mc\xf7\xfbf\x95\n?\x8e6\x969dsolcC\x00\x08\x19\x003",
            );
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct DexType(u8);
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for DexType {
                #[inline]
                fn clone(&self) -> DexType {
                    DexType(::core::clone::Clone::clone(&self.0))
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for DexType {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "DexType",
                        &&self.0,
                    )
                }
            }
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                #[automatically_derived]
                impl alloy_sol_types::private::SolTypeValue<DexType> for u8 {
                    #[inline]
                    fn stv_to_tokens(
                        &self,
                    ) -> <::alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::Token<'_> {
                        alloy_sol_types::private::SolTypeValue::<
                            ::alloy::sol_types::sol_data::Uint<8>,
                        >::stv_to_tokens(self)
                    }
                    #[inline]
                    fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                        <::alloy::sol_types::sol_data::Uint<
                            8,
                        > as alloy_sol_types::SolType>::tokenize(self)
                            .0
                    }
                    #[inline]
                    fn stv_abi_encode_packed_to(
                        &self,
                        out: &mut alloy_sol_types::private::Vec<u8>,
                    ) {
                        <::alloy::sol_types::sol_data::Uint<
                            8,
                        > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
                    }
                    #[inline]
                    fn stv_abi_packed_encoded_size(&self) -> usize {
                        <::alloy::sol_types::sol_data::Uint<
                            8,
                        > as alloy_sol_types::SolType>::abi_encoded_size(self)
                    }
                }
                #[automatically_derived]
                impl DexType {
                    /// The Solidity type name.
                    pub const NAME: &'static str = "@ name";
                    /// Convert from the underlying value type.
                    #[inline]
                    pub const fn from(value: u8) -> Self {
                        Self(value)
                    }
                    /// Return the underlying value.
                    #[inline]
                    pub const fn into(self) -> u8 {
                        self.0
                    }
                    /// Return the single encoding of this value, delegating to the
                    /// underlying type.
                    #[inline]
                    pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                        <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
                    }
                    /// Return the packed encoding of this value, delegating to the
                    /// underlying type.
                    #[inline]
                    pub fn abi_encode_packed(
                        &self,
                    ) -> alloy_sol_types::private::Vec<u8> {
                        <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolType for DexType {
                    type RustType = u8;
                    type Token<'a> = <::alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SOL_NAME: &'static str = Self::NAME;
                    const ENCODED_SIZE: Option<usize> = <::alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::ENCODED_SIZE;
                    const PACKED_ENCODED_SIZE: Option<usize> = <::alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
                    #[inline]
                    fn valid_token(token: &Self::Token<'_>) -> bool {
                        Self::type_check(token).is_ok()
                    }
                    #[inline]
                    fn type_check(
                        token: &Self::Token<'_>,
                    ) -> alloy_sol_types::Result<()> {
                        <::alloy::sol_types::sol_data::Uint<
                            8,
                        > as alloy_sol_types::SolType>::type_check(token)
                    }
                    #[inline]
                    fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                        <::alloy::sol_types::sol_data::Uint<
                            8,
                        > as alloy_sol_types::SolType>::detokenize(token)
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::EventTopic for DexType {
                    #[inline]
                    fn topic_preimage_length(rust: &Self::RustType) -> usize {
                        <::alloy::sol_types::sol_data::Uint<
                            8,
                        > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
                    }
                    #[inline]
                    fn encode_topic_preimage(
                        rust: &Self::RustType,
                        out: &mut alloy_sol_types::private::Vec<u8>,
                    ) {
                        <::alloy::sol_types::sol_data::Uint<
                            8,
                        > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                            rust,
                            out,
                        )
                    }
                    #[inline]
                    fn encode_topic(
                        rust: &Self::RustType,
                    ) -> alloy_sol_types::abi::token::WordToken {
                        <::alloy::sol_types::sol_data::Uint<
                            8,
                        > as alloy_sol_types::EventTopic>::encode_topic(rust)
                    }
                }
            };
            /**Constructor`.
```solidity
constructor(address[] pools, DexType dexType);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct constructorCall {
                pub pools: ::alloy::sol_types::private::Vec<
                    ::alloy::sol_types::private::Address,
                >,
                pub dexType: <DexType as ::alloy::sol_types::SolType>::RustType,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for constructorCall {
                #[inline]
                fn clone(&self) -> constructorCall {
                    constructorCall {
                        pools: ::core::clone::Clone::clone(&self.pools),
                        dexType: ::core::clone::Clone::clone(&self.dexType),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for constructorCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "constructorCall",
                        "pools",
                        &self.pools,
                        "dexType",
                        &&self.dexType,
                    )
                }
            }
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (
                        ::alloy::sol_types::sol_data::Array<
                            ::alloy::sol_types::sol_data::Address,
                        >,
                        DexType,
                    );
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        ::alloy::sol_types::private::Vec<
                            ::alloy::sol_types::private::Address,
                        >,
                        <DexType as ::alloy::sol_types::SolType>::RustType,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<constructorCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: constructorCall) -> Self {
                            (value.pools, value.dexType)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for constructorCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {
                                pools: tuple.0,
                                dexType: tuple.1,
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolConstructor for constructorCall {
                    type Parameters<'a> = (
                        ::alloy::sol_types::sol_data::Array<
                            ::alloy::sol_types::sol_data::Address,
                        >,
                        DexType,
                    );
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        (
                            <::alloy::sol_types::sol_data::Array<
                                ::alloy::sol_types::sol_data::Address,
                            > as alloy_sol_types::SolType>::tokenize(&self.pools),
                            <DexType as alloy_sol_types::SolType>::tokenize(
                                &self.dexType,
                            ),
                        )
                    }
                }
            };
            /**Function with signature `PANCAKESWAP()` and selector `0x04626335`.
```solidity
function PANCAKESWAP() external view returns (DexType);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct PANCAKESWAPCall {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for PANCAKESWAPCall {
                #[inline]
                fn clone(&self) -> PANCAKESWAPCall {
                    PANCAKESWAPCall {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for PANCAKESWAPCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "PANCAKESWAPCall")
                }
            }
            ///Container type for the return parameters of the [`PANCAKESWAP()`](PANCAKESWAPCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct PANCAKESWAPReturn {
                pub _0: <DexType as ::alloy::sol_types::SolType>::RustType,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for PANCAKESWAPReturn {
                #[inline]
                fn clone(&self) -> PANCAKESWAPReturn {
                    PANCAKESWAPReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for PANCAKESWAPReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "PANCAKESWAPReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<PANCAKESWAPCall>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: PANCAKESWAPCall) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for PANCAKESWAPCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (DexType,);
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        <DexType as ::alloy::sol_types::SolType>::RustType,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<PANCAKESWAPReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: PANCAKESWAPReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for PANCAKESWAPReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for PANCAKESWAPCall {
                    type Parameters<'a> = ();
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = PANCAKESWAPReturn;
                    type ReturnTuple<'a> = (DexType,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "PANCAKESWAP()";
                    const SELECTOR: [u8; 4] = [4u8, 98u8, 99u8, 53u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            /**Function with signature `UNISWAP()` and selector `0xc745d9e7`.
```solidity
function UNISWAP() external view returns (DexType);
```*/
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct UNISWAPCall {}
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for UNISWAPCall {
                #[inline]
                fn clone(&self) -> UNISWAPCall {
                    UNISWAPCall {}
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for UNISWAPCall {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "UNISWAPCall")
                }
            }
            ///Container type for the return parameters of the [`UNISWAP()`](UNISWAPCall) function.
            #[allow(non_camel_case_types, non_snake_case)]
            pub struct UNISWAPReturn {
                pub _0: <DexType as ::alloy::sol_types::SolType>::RustType,
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::clone::Clone for UNISWAPReturn {
                #[inline]
                fn clone(&self) -> UNISWAPReturn {
                    UNISWAPReturn {
                        _0: ::core::clone::Clone::clone(&self._0),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_camel_case_types, non_snake_case)]
            impl ::core::fmt::Debug for UNISWAPReturn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "UNISWAPReturn",
                        "_0",
                        &&self._0,
                    )
                }
            }
            #[allow(non_camel_case_types, non_snake_case, clippy::style)]
            const _: () = {
                use ::alloy::sol_types as alloy_sol_types;
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = ();
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = ();
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UNISWAPCall> for UnderlyingRustTuple<'_> {
                        fn from(value: UNISWAPCall) -> Self {
                            ()
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>> for UNISWAPCall {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self {}
                        }
                    }
                }
                {
                    #[doc(hidden)]
                    type UnderlyingSolTuple<'a> = (DexType,);
                    #[doc(hidden)]
                    type UnderlyingRustTuple<'a> = (
                        <DexType as ::alloy::sol_types::SolType>::RustType,
                    );
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UNISWAPReturn>
                    for UnderlyingRustTuple<'_> {
                        fn from(value: UNISWAPReturn) -> Self {
                            (value._0,)
                        }
                    }
                    #[automatically_derived]
                    #[doc(hidden)]
                    impl ::core::convert::From<UnderlyingRustTuple<'_>>
                    for UNISWAPReturn {
                        fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                            Self { _0: tuple.0 }
                        }
                    }
                }
                #[automatically_derived]
                impl alloy_sol_types::SolCall for UNISWAPCall {
                    type Parameters<'a> = ();
                    type Token<'a> = <Self::Parameters<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    type Return = UNISWAPReturn;
                    type ReturnTuple<'a> = (DexType,);
                    type ReturnToken<'a> = <Self::ReturnTuple<
                        'a,
                    > as alloy_sol_types::SolType>::Token<'a>;
                    const SIGNATURE: &'static str = "UNISWAP()";
                    const SELECTOR: [u8; 4] = [199u8, 69u8, 217u8, 231u8];
                    #[inline]
                    fn new<'a>(
                        tuple: <Self::Parameters<
                            'a,
                        > as alloy_sol_types::SolType>::RustType,
                    ) -> Self {
                        tuple.into()
                    }
                    #[inline]
                    fn tokenize(&self) -> Self::Token<'_> {
                        ()
                    }
                    #[inline]
                    fn abi_decode_returns(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<Self::Return> {
                        <Self::ReturnTuple<
                            '_,
                        > as alloy_sol_types::SolType>::abi_decode_sequence(
                                data,
                                validate,
                            )
                            .map(Into::into)
                    }
                }
            };
            ///Container for all the [`V3DataSync`](self) function calls.
            pub enum V3DataSyncCalls {
                PANCAKESWAP(PANCAKESWAPCall),
                UNISWAP(UNISWAPCall),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for V3DataSyncCalls {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        V3DataSyncCalls::PANCAKESWAP(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "PANCAKESWAP",
                                &__self_0,
                            )
                        }
                        V3DataSyncCalls::UNISWAP(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "UNISWAP",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl V3DataSyncCalls {
                /// All the selectors of this enum.
                ///
                /// Note that the selectors might not be in the same order as the variants.
                /// No guarantees are made about the order of the selectors.
                ///
                /// Prefer using `SolInterface` methods instead.
                pub const SELECTORS: &'static [[u8; 4usize]] = &[
                    [4u8, 98u8, 99u8, 53u8],
                    [199u8, 69u8, 217u8, 231u8],
                ];
            }
            #[automatically_derived]
            impl alloy_sol_types::SolInterface for V3DataSyncCalls {
                const NAME: &'static str = "V3DataSyncCalls";
                const MIN_DATA_LENGTH: usize = 0usize;
                const COUNT: usize = 2usize;
                #[inline]
                fn selector(&self) -> [u8; 4] {
                    match self {
                        Self::PANCAKESWAP(_) => {
                            <PANCAKESWAPCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                        Self::UNISWAP(_) => {
                            <UNISWAPCall as alloy_sol_types::SolCall>::SELECTOR
                        }
                    }
                }
                #[inline]
                fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
                    Self::SELECTORS.get(i).copied()
                }
                #[inline]
                fn valid_selector(selector: [u8; 4]) -> bool {
                    Self::SELECTORS.binary_search(&selector).is_ok()
                }
                #[inline]
                #[allow(unsafe_code, non_snake_case)]
                fn abi_decode_raw(
                    selector: [u8; 4],
                    data: &[u8],
                    validate: bool,
                ) -> alloy_sol_types::Result<Self> {
                    static DECODE_SHIMS: &[fn(
                        &[u8],
                        bool,
                    ) -> alloy_sol_types::Result<V3DataSyncCalls>] = &[
                        {
                            fn PANCAKESWAP(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<V3DataSyncCalls> {
                                <PANCAKESWAPCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(V3DataSyncCalls::PANCAKESWAP)
                            }
                            PANCAKESWAP
                        },
                        {
                            fn UNISWAP(
                                data: &[u8],
                                validate: bool,
                            ) -> alloy_sol_types::Result<V3DataSyncCalls> {
                                <UNISWAPCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                        data,
                                        validate,
                                    )
                                    .map(V3DataSyncCalls::UNISWAP)
                            }
                            UNISWAP
                        },
                    ];
                    let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                        return Err(
                            alloy_sol_types::Error::unknown_selector(
                                <Self as alloy_sol_types::SolInterface>::NAME,
                                selector,
                            ),
                        );
                    };
                    (unsafe { DECODE_SHIMS.get_unchecked(idx) })(data, validate)
                }
                #[inline]
                fn abi_encoded_size(&self) -> usize {
                    match self {
                        Self::PANCAKESWAP(inner) => {
                            <PANCAKESWAPCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                        Self::UNISWAP(inner) => {
                            <UNISWAPCall as alloy_sol_types::SolCall>::abi_encoded_size(
                                inner,
                            )
                        }
                    }
                }
                #[inline]
                fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                    match self {
                        Self::PANCAKESWAP(inner) => {
                            <PANCAKESWAPCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                        Self::UNISWAP(inner) => {
                            <UNISWAPCall as alloy_sol_types::SolCall>::abi_encode_raw(
                                inner,
                                out,
                            )
                        }
                    }
                }
            }
            use ::alloy::contract as alloy_contract;
            /**Creates a new wrapper around an on-chain [`V3DataSync`](self) contract instance.

See the [wrapper's documentation](`V3DataSyncInstance`) for more details.*/
            #[inline]
            pub const fn new<
                T: alloy_contract::private::Transport + ::core::clone::Clone,
                P: alloy_contract::private::Provider<T, N>,
                N: alloy_contract::private::Network,
            >(
                address: alloy_sol_types::private::Address,
                provider: P,
            ) -> V3DataSyncInstance<T, P, N> {
                V3DataSyncInstance::<T, P, N>::new(address, provider)
            }
            /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
            #[inline]
            pub fn deploy<
                T: alloy_contract::private::Transport + ::core::clone::Clone,
                P: alloy_contract::private::Provider<T, N>,
                N: alloy_contract::private::Network,
            >(
                provider: P,
                pools: ::alloy::sol_types::private::Vec<
                    ::alloy::sol_types::private::Address,
                >,
                dexType: <DexType as ::alloy::sol_types::SolType>::RustType,
            ) -> impl ::core::future::Future<
                Output = alloy_contract::Result<V3DataSyncInstance<T, P, N>>,
            > {
                V3DataSyncInstance::<T, P, N>::deploy(provider, pools, dexType)
            }
            /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
            #[inline]
            pub fn deploy_builder<
                T: alloy_contract::private::Transport + ::core::clone::Clone,
                P: alloy_contract::private::Provider<T, N>,
                N: alloy_contract::private::Network,
            >(
                provider: P,
                pools: ::alloy::sol_types::private::Vec<
                    ::alloy::sol_types::private::Address,
                >,
                dexType: <DexType as ::alloy::sol_types::SolType>::RustType,
            ) -> alloy_contract::RawCallBuilder<T, P, N> {
                V3DataSyncInstance::<T, P, N>::deploy_builder(provider, pools, dexType)
            }
            /**A [`V3DataSync`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`V3DataSync`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
            pub struct V3DataSyncInstance<T, P, N = alloy_contract::private::Ethereum> {
                address: alloy_sol_types::private::Address,
                provider: P,
                _network_transport: ::core::marker::PhantomData<(N, T)>,
            }
            #[automatically_derived]
            impl<
                T: ::core::clone::Clone,
                P: ::core::clone::Clone,
                N: ::core::clone::Clone,
            > ::core::clone::Clone for V3DataSyncInstance<T, P, N> {
                #[inline]
                fn clone(&self) -> V3DataSyncInstance<T, P, N> {
                    V3DataSyncInstance {
                        address: ::core::clone::Clone::clone(&self.address),
                        provider: ::core::clone::Clone::clone(&self.provider),
                        _network_transport: ::core::clone::Clone::clone(
                            &self._network_transport,
                        ),
                    }
                }
            }
            #[automatically_derived]
            impl<T, P, N> ::core::fmt::Debug for V3DataSyncInstance<T, P, N> {
                #[inline]
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_tuple("V3DataSyncInstance").field(&self.address).finish()
                }
            }
            /// Instantiation and getters/setters.
            #[automatically_derived]
            impl<
                T: alloy_contract::private::Transport + ::core::clone::Clone,
                P: alloy_contract::private::Provider<T, N>,
                N: alloy_contract::private::Network,
            > V3DataSyncInstance<T, P, N> {
                /**Creates a new wrapper around an on-chain [`V3DataSync`](self) contract instance.

See the [wrapper's documentation](`V3DataSyncInstance`) for more details.*/
                #[inline]
                pub const fn new(
                    address: alloy_sol_types::private::Address,
                    provider: P,
                ) -> Self {
                    Self {
                        address,
                        provider,
                        _network_transport: ::core::marker::PhantomData,
                    }
                }
                /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
                #[inline]
                pub async fn deploy(
                    provider: P,
                    pools: ::alloy::sol_types::private::Vec<
                        ::alloy::sol_types::private::Address,
                    >,
                    dexType: <DexType as ::alloy::sol_types::SolType>::RustType,
                ) -> alloy_contract::Result<V3DataSyncInstance<T, P, N>> {
                    let call_builder = Self::deploy_builder(provider, pools, dexType);
                    let contract_address = call_builder.deploy().await?;
                    Ok(Self::new(contract_address, call_builder.provider))
                }
                /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
                #[inline]
                pub fn deploy_builder(
                    provider: P,
                    pools: ::alloy::sol_types::private::Vec<
                        ::alloy::sol_types::private::Address,
                    >,
                    dexType: <DexType as ::alloy::sol_types::SolType>::RustType,
                ) -> alloy_contract::RawCallBuilder<T, P, N> {
                    alloy_contract::RawCallBuilder::new_raw_deploy(
                        provider,
                        [
                            &BYTECODE[..],
                            &alloy_sol_types::SolConstructor::abi_encode(
                                &constructorCall { pools, dexType },
                            )[..],
                        ]
                            .concat()
                            .into(),
                    )
                }
                /// Returns a reference to the address.
                #[inline]
                pub const fn address(&self) -> &alloy_sol_types::private::Address {
                    &self.address
                }
                /// Sets the address.
                #[inline]
                pub fn set_address(
                    &mut self,
                    address: alloy_sol_types::private::Address,
                ) {
                    self.address = address;
                }
                /// Sets the address and returns `self`.
                pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
                    self.set_address(address);
                    self
                }
                /// Returns a reference to the provider.
                #[inline]
                pub const fn provider(&self) -> &P {
                    &self.provider
                }
            }
            impl<T, P: ::core::clone::Clone, N> V3DataSyncInstance<T, &P, N> {
                /// Clones the provider and returns a new instance with the cloned provider.
                #[inline]
                pub fn with_cloned_provider(self) -> V3DataSyncInstance<T, P, N> {
                    V3DataSyncInstance {
                        address: self.address,
                        provider: ::core::clone::Clone::clone(&self.provider),
                        _network_transport: ::core::marker::PhantomData,
                    }
                }
            }
            /// Function calls.
            #[automatically_derived]
            impl<
                T: alloy_contract::private::Transport + ::core::clone::Clone,
                P: alloy_contract::private::Provider<T, N>,
                N: alloy_contract::private::Network,
            > V3DataSyncInstance<T, P, N> {
                /// Creates a new call builder using this contract instance's provider and address.
                ///
                /// Note that the call can be any function call, not just those defined in this
                /// contract. Prefer using the other methods for building type-safe contract calls.
                pub fn call_builder<C: alloy_sol_types::SolCall>(
                    &self,
                    call: &C,
                ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
                    alloy_contract::SolCallBuilder::new_sol(
                        &self.provider,
                        &self.address,
                        call,
                    )
                }
                ///Creates a new call builder for the [`PANCAKESWAP`] function.
                pub fn PANCAKESWAP(
                    &self,
                ) -> alloy_contract::SolCallBuilder<T, &P, PANCAKESWAPCall, N> {
                    self.call_builder(&PANCAKESWAPCall {})
                }
                ///Creates a new call builder for the [`UNISWAP`] function.
                pub fn UNISWAP(
                    &self,
                ) -> alloy_contract::SolCallBuilder<T, &P, UNISWAPCall, N> {
                    self.call_builder(&UNISWAPCall {})
                }
            }
            /// Event filters.
            #[automatically_derived]
            impl<
                T: alloy_contract::private::Transport + ::core::clone::Clone,
                P: alloy_contract::private::Provider<T, N>,
                N: alloy_contract::private::Network,
            > V3DataSyncInstance<T, P, N> {
                /// Creates a new event filter using this contract instance's provider and address.
                ///
                /// Note that the type can be any event, not just those defined in this contract.
                /// Prefer using the other methods for building type-safe event filters.
                pub fn event_filter<E: alloy_sol_types::SolEvent>(
                    &self,
                ) -> alloy_contract::Event<T, &P, E, N> {
                    alloy_contract::Event::new_sol(&self.provider, &self.address)
                }
            }
        }
        pub const INITIAL_BACKOFF: u64 = 1000;
        pub const MAX_RETRIES: u32 = 5;
        pub async fn build_pools<P, T, N>(
            provider: Arc<P>,
            addresses: Vec<Address>,
            pool_type: PoolType,
        ) -> Vec<Pool>
        where
            P: Provider<T, N> + Sync + 'static,
            T: Transport + Sync + Clone,
            N: Network,
        {
            let mut retry_count = 0;
            let mut backoff = INITIAL_BACKOFF;
            loop {
                match attempt_build_pools(provider.clone(), &addresses, pool_type).await
                {
                    Ok(pools) => return pools,
                    Err(e) => {
                        if retry_count >= MAX_RETRIES {
                            {
                                ::std::io::_eprint(
                                    format_args!("Max retries reached. Error: {0:?}\n", e),
                                );
                            };
                        }
                        let jitter = rand::thread_rng().gen_range(0..=100);
                        let sleep_duration = Duration::from_millis(backoff + jitter);
                        tokio::time::sleep(sleep_duration).await;
                        retry_count += 1;
                        backoff *= 2;
                    }
                }
            }
        }
        async fn attempt_build_pools<P, T, N>(
            provider: Arc<P>,
            addresses: &Vec<Address>,
            pool_type: PoolType,
        ) -> Result<Vec<Pool>, Box<dyn std::error::Error>>
        where
            P: Provider<T, N> + Sync + 'static,
            T: Transport + Sync + Clone,
            N: Network,
        {
            let v3_data = DynSolType::Array(
                Box::new(
                    DynSolType::Tuple(
                        <[_]>::into_vec(
                            #[rustc_box]
                            ::alloc::boxed::Box::new([
                                DynSolType::Address,
                                DynSolType::Address,
                                DynSolType::Uint(8),
                                DynSolType::Address,
                                DynSolType::Uint(8),
                                DynSolType::Uint(128),
                                DynSolType::Uint(160),
                                DynSolType::Int(24),
                                DynSolType::Int(24),
                                DynSolType::Uint(24),
                                DynSolType::Int(128),
                            ]),
                        ),
                    ),
                ),
            );
            let protocol = if pool_type == PoolType::UniswapV3 { 0_u8 } else { 1_u8 };
            let data = V3DataSync::deploy_builder(
                    provider.clone(),
                    addresses.to_vec(),
                    protocol,
                )
                .await?;
            let decoded_data = v3_data.abi_decode_sequence(&data)?;
            let mut pools = Vec::new();
            if let Some(pool_data_arr) = decoded_data.as_array() {
                for pool_data_tuple in pool_data_arr {
                    if let Some(pool_data) = pool_data_tuple.as_tuple() {
                        let pool = UniswapV3Pool::from(pool_data);
                        if pool.is_valid() {
                            pools.push(pool);
                        }
                    }
                }
            }
            for pool in &mut pools {
                let token0_contract = ERC20::new(pool.token0, provider.clone());
                if let Ok(ERC20::symbolReturn { _0: name }) = token0_contract
                    .symbol()
                    .call()
                    .await
                {
                    pool.token0_name = name;
                }
                let token1_contract = ERC20::new(pool.token1, provider.clone());
                if let Ok(ERC20::symbolReturn { _0: name }) = token1_contract
                    .symbol()
                    .call()
                    .await
                {
                    pool.token1_name = name;
                }
            }
            let pools = pools
                .into_iter()
                .map(|pool| Pool::new_v3(pool_type, pool))
                .collect();
            Ok(pools)
        }
        impl From<&[DynSolValue]> for UniswapV3Pool {
            fn from(data: &[DynSolValue]) -> Self {
                Self {
                    address: data[0].as_address().unwrap(),
                    token0: data[1].as_address().unwrap(),
                    token0_decimals: data[2].as_uint().unwrap().0.to::<u8>(),
                    token1: data[3].as_address().unwrap(),
                    token1_decimals: data[4].as_uint().unwrap().0.to::<u8>(),
                    liquidity: data[5].as_uint().unwrap().0.to::<U128>(),
                    sqrt_price: data[6].as_uint().unwrap().0,
                    tick: data[7].as_int().unwrap().0.as_i32(),
                    tick_spacing: data[8].as_int().unwrap().0.as_i32(),
                    fee: data[9].as_uint().unwrap().0.to::<u32>(),
                    ..Default::default()
                }
            }
        }
    }
    pub mod uniswap {
        pub use uniswap_v2_fetcher::UniswapV2Fetcher;
        pub use uniswap_v3_fetcher::UniswapV3Fetcher;
        mod uniswap_v2_fetcher {
            use alloy::primitives::{address, Address};
            use crate::pools::gen::UniswapV2Factory;
            use alloy_sol_types::SolEvent;
            use crate::pools::PoolFetcher;
            use alloy::primitives::Log;
            use crate::pools::PoolType;
            use crate::Chain;
            pub struct UniswapV2Fetcher;
            impl PoolFetcher for UniswapV2Fetcher {
                fn pool_type(&self) -> PoolType {
                    PoolType::UniswapV2
                }
                fn factory_address(&self, chain: Chain) -> Address {
                    match chain {
                        Chain::Ethereum => {
                            ::alloy_primitives::Address::new({
                                const STRINGS: &[&'static [u8]] = &[
                                    "5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f".as_bytes(),
                                ];
                                const LEN: usize = ::hex_literal::len(STRINGS);
                                const RES: [u8; LEN] = ::hex_literal::decode(STRINGS);
                                RES
                            })
                        }
                        Chain::Base => {
                            ::alloy_primitives::Address::new({
                                const STRINGS: &[&'static [u8]] = &[
                                    "8909Dc15e40173Ff4699343b6eB8132c65e18eC6".as_bytes(),
                                ];
                                const LEN: usize = ::hex_literal::len(STRINGS);
                                const RES: [u8; LEN] = ::hex_literal::decode(STRINGS);
                                RES
                            })
                        }
                    }
                }
                fn pair_created_signature(&self) -> &str {
                    UniswapV2Factory::PairCreated::SIGNATURE
                }
                fn log_to_address(&self, log: &Log) -> Address {
                    let decoded_log = UniswapV2Factory::PairCreated::decode_log(
                            log,
                            false,
                        )
                        .unwrap();
                    decoded_log.data.pair
                }
            }
        }
        mod uniswap_v3_fetcher {
            use crate::pools::gen::UniswapV3Factory;
            use alloy::primitives::{address, Address};
            use alloy_sol_types::SolEvent;
            use crate::pools::PoolFetcher;
            use alloy::primitives::Log;
            use crate::pools::PoolType;
            use crate::Chain;
            pub struct UniswapV3Fetcher;
            impl PoolFetcher for UniswapV3Fetcher {
                fn pool_type(&self) -> PoolType {
                    PoolType::UniswapV3
                }
                fn factory_address(&self, chain: Chain) -> Address {
                    match chain {
                        Chain::Ethereum => {
                            ::alloy_primitives::Address::new({
                                const STRINGS: &[&'static [u8]] = &[
                                    "1F98431c8aD98523631AE4a59f267346ea31F984".as_bytes(),
                                ];
                                const LEN: usize = ::hex_literal::len(STRINGS);
                                const RES: [u8; LEN] = ::hex_literal::decode(STRINGS);
                                RES
                            })
                        }
                        Chain::Base => {
                            ::alloy_primitives::Address::new({
                                const STRINGS: &[&'static [u8]] = &[
                                    "33128a8fC17869897dcE68Ed026d694621f6FDfD".as_bytes(),
                                ];
                                const LEN: usize = ::hex_literal::len(STRINGS);
                                const RES: [u8; LEN] = ::hex_literal::decode(STRINGS);
                                RES
                            })
                        }
                    }
                }
                fn pair_created_signature(&self) -> &str {
                    UniswapV3Factory::PoolCreated::SIGNATURE
                }
                fn log_to_address(&self, log: &Log) -> Address {
                    let decoded_log = UniswapV3Factory::PoolCreated::decode_log(
                            log,
                            false,
                        )
                        .unwrap();
                    decoded_log.data.pool
                }
            }
        }
    }
    pub mod sushiswap {
        pub use sushiswap_v2_fetcher::SushiSwapV2Fetcher;
        pub use sushiswap_v3_fetcher::SushiSwapV3Fetcher;
        mod sushiswap_v2_fetcher {
            use crate::pools::gen::SushiSwapV2Factory;
            use alloy::primitives::{address, Address};
            use alloy_sol_types::SolEvent;
            use crate::pools::PoolFetcher;
            use alloy::primitives::Log;
            use crate::pools::PoolType;
            use crate::Chain;
            pub struct SushiSwapV2Fetcher;
            impl PoolFetcher for SushiSwapV2Fetcher {
                fn pool_type(&self) -> PoolType {
                    PoolType::SushiSwapV2
                }
                fn factory_address(&self, chain: Chain) -> Address {
                    match chain {
                        Chain::Ethereum => {
                            ::alloy_primitives::Address::new({
                                const STRINGS: &[&'static [u8]] = &[
                                    "C0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac".as_bytes(),
                                ];
                                const LEN: usize = ::hex_literal::len(STRINGS);
                                const RES: [u8; LEN] = ::hex_literal::decode(STRINGS);
                                RES
                            })
                        }
                        Chain::Base => {
                            ::alloy_primitives::Address::new({
                                const STRINGS: &[&'static [u8]] = &[
                                    "71524B4f93c58fcbF659783284E38825f0622859".as_bytes(),
                                ];
                                const LEN: usize = ::hex_literal::len(STRINGS);
                                const RES: [u8; LEN] = ::hex_literal::decode(STRINGS);
                                RES
                            })
                        }
                    }
                }
                fn pair_created_signature(&self) -> &str {
                    SushiSwapV2Factory::PairCreated::SIGNATURE
                }
                fn log_to_address(&self, log: &Log) -> Address {
                    let decoded_log = SushiSwapV2Factory::PairCreated::decode_log(
                            log,
                            false,
                        )
                        .unwrap();
                    decoded_log.data.pair
                }
            }
        }
        mod sushiswap_v3_fetcher {
            use crate::pools::gen::SushiSwapV3Factory;
            use alloy::primitives::{address, Address};
            use alloy_sol_types::SolEvent;
            use crate::pools::PoolFetcher;
            use alloy::primitives::Log;
            use crate::pools::PoolType;
            use crate::Chain;
            pub struct SushiSwapV3Fetcher;
            impl PoolFetcher for SushiSwapV3Fetcher {
                fn pool_type(&self) -> PoolType {
                    PoolType::SushiSwapV3
                }
                fn factory_address(&self, chain: Chain) -> Address {
                    match chain {
                        Chain::Ethereum => {
                            ::alloy_primitives::Address::new({
                                const STRINGS: &[&'static [u8]] = &[
                                    "bACEB8eC6b9355Dfc0269C18bac9d6E2Bdc29C4F".as_bytes(),
                                ];
                                const LEN: usize = ::hex_literal::len(STRINGS);
                                const RES: [u8; LEN] = ::hex_literal::decode(STRINGS);
                                RES
                            })
                        }
                        Chain::Base => {
                            ::alloy_primitives::Address::new({
                                const STRINGS: &[&'static [u8]] = &[
                                    "c35DADB65012eC5796536bD9864eD8773aBc74C4".as_bytes(),
                                ];
                                const LEN: usize = ::hex_literal::len(STRINGS);
                                const RES: [u8; LEN] = ::hex_literal::decode(STRINGS);
                                RES
                            })
                        }
                    }
                }
                fn pair_created_signature(&self) -> &str {
                    SushiSwapV3Factory::PoolCreated::SIGNATURE
                }
                fn log_to_address(&self, log: &Log) -> Address {
                    let decoded_log = SushiSwapV3Factory::PoolCreated::decode_log(
                            log,
                            false,
                        )
                        .unwrap();
                    decoded_log.data.pool
                }
            }
        }
    }
    pub mod pancake_swap {
        pub use pancakeswap_v2_fetcher::PancakeSwapV2Fetcher;
        pub use pancakeswap_v3_fetcher::PancakeSwapV3Fetcher;
        mod pancakeswap_v2_fetcher {
            use alloy::primitives::{address, Address};
            use alloy_sol_types::SolEvent;
            use crate::pools::gen::PancakeSwapV2Factory;
            use crate::pools::PoolFetcher;
            use alloy::primitives::Log;
            use crate::pools::PoolType;
            use crate::Chain;
            pub struct PancakeSwapV2Fetcher;
            impl PoolFetcher for PancakeSwapV2Fetcher {
                fn pool_type(&self) -> PoolType {
                    PoolType::PancakeSwapV2
                }
                fn factory_address(&self, chain: Chain) -> Address {
                    match chain {
                        Chain::Ethereum => {
                            ::alloy_primitives::Address::new({
                                const STRINGS: &[&'static [u8]] = &[
                                    "1097053Fd2ea711dad45caCcc45EfF7548fCB362".as_bytes(),
                                ];
                                const LEN: usize = ::hex_literal::len(STRINGS);
                                const RES: [u8; LEN] = ::hex_literal::decode(STRINGS);
                                RES
                            })
                        }
                        Chain::Base => {
                            ::alloy_primitives::Address::new({
                                const STRINGS: &[&'static [u8]] = &[
                                    "02a84c1b3BBD7401a5f7fa98a384EBC70bB5749E".as_bytes(),
                                ];
                                const LEN: usize = ::hex_literal::len(STRINGS);
                                const RES: [u8; LEN] = ::hex_literal::decode(STRINGS);
                                RES
                            })
                        }
                    }
                }
                fn pair_created_signature(&self) -> &str {
                    PancakeSwapV2Factory::PairCreated::SIGNATURE
                }
                fn log_to_address(&self, log: &Log) -> Address {
                    let decoded_log = PancakeSwapV2Factory::PairCreated::decode_log(
                            log,
                            false,
                        )
                        .unwrap();
                    decoded_log.data.pair
                }
            }
        }
        mod pancakeswap_v3_fetcher {
            use crate::pools::gen::PancakeSwapV3Factory;
            use alloy::primitives::{address, Address};
            use alloy_sol_types::SolEvent;
            use crate::pools::PoolFetcher;
            use alloy::primitives::Log;
            use crate::pools::PoolType;
            use crate::Chain;
            pub struct PancakeSwapV3Fetcher;
            impl PoolFetcher for PancakeSwapV3Fetcher {
                fn pool_type(&self) -> PoolType {
                    PoolType::PancakeSwapV3
                }
                fn factory_address(&self, chain: Chain) -> Address {
                    match chain {
                        Chain::Ethereum => {
                            ::alloy_primitives::Address::new({
                                const STRINGS: &[&'static [u8]] = &[
                                    "0BFbCF9fa4f9C56B0F40a671Ad40E0805A091865".as_bytes(),
                                ];
                                const LEN: usize = ::hex_literal::len(STRINGS);
                                const RES: [u8; LEN] = ::hex_literal::decode(STRINGS);
                                RES
                            })
                        }
                        Chain::Base => {
                            ::alloy_primitives::Address::new({
                                const STRINGS: &[&'static [u8]] = &[
                                    "0BFbCF9fa4f9C56B0F40a671Ad40E0805A091865".as_bytes(),
                                ];
                                const LEN: usize = ::hex_literal::len(STRINGS);
                                const RES: [u8; LEN] = ::hex_literal::decode(STRINGS);
                                RES
                            })
                        }
                    }
                }
                fn pair_created_signature(&self) -> &str {
                    PancakeSwapV3Factory::PoolCreated::SIGNATURE
                }
                fn log_to_address(&self, log: &Log) -> Address {
                    let decoded_log = PancakeSwapV3Factory::PoolCreated::decode_log(
                            log,
                            false,
                        )
                        .unwrap();
                    decoded_log.data.pool
                }
            }
        }
    }
    pub mod aerodome {
        pub use aerodome_fetcher::AerodomeFetcher;
        mod aerodome_fetcher {
            use alloy::primitives::{address, Address};
            use alloy_sol_types::SolEvent;
            use crate::pools::gen::AerodomeV2Factory;
            use crate::pools::PoolFetcher;
            use alloy::primitives::Log;
            use crate::pools::PoolType;
            use crate::Chain;
            pub struct AerodomeFetcher;
            impl PoolFetcher for AerodomeFetcher {
                fn pool_type(&self) -> PoolType {
                    PoolType::Aerodome
                }
                fn factory_address(&self, chain: Chain) -> Address {
                    match chain {
                        Chain::Base => {
                            ::alloy_primitives::Address::new({
                                const STRINGS: &[&'static [u8]] = &[
                                    "	420DD381b31aEf6683db6B902084cB0FFECe40Da".as_bytes(),
                                ];
                                const LEN: usize = ::hex_literal::len(STRINGS);
                                const RES: [u8; LEN] = ::hex_literal::decode(STRINGS);
                                RES
                            })
                        }
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!("Aerodome not supported on this chain"),
                            );
                        }
                    }
                }
                fn pair_created_signature(&self) -> &str {
                    AerodomeV2Factory::PoolCreated::SIGNATURE
                }
                fn log_to_address(&self, log: &Log) -> Address {
                    let decoded_log = AerodomeV2Factory::PoolCreated::decode_log(
                            log,
                            false,
                        )
                        .unwrap();
                    decoded_log.data.pool
                }
            }
        }
    }
    /// Enumerates the supported pool types
    pub enum PoolType {
        UniswapV2,
        SushiSwapV2,
        PancakeSwapV2,
        UniswapV3,
        SushiSwapV3,
        PancakeSwapV3,
        Aerodome,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PoolType {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    PoolType::UniswapV2 => "UniswapV2",
                    PoolType::SushiSwapV2 => "SushiSwapV2",
                    PoolType::PancakeSwapV2 => "PancakeSwapV2",
                    PoolType::UniswapV3 => "UniswapV3",
                    PoolType::SushiSwapV3 => "SushiSwapV3",
                    PoolType::PancakeSwapV3 => "PancakeSwapV3",
                    PoolType::Aerodome => "Aerodome",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for PoolType {
        #[inline]
        fn clone(&self) -> PoolType {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for PoolType {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for PoolType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for PoolType {
        #[inline]
        fn eq(&self, other: &PoolType) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for PoolType {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for PoolType {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_discr, state)
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for PoolType {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    PoolType::UniswapV2 => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "PoolType",
                            0u32,
                            "UniswapV2",
                        )
                    }
                    PoolType::SushiSwapV2 => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "PoolType",
                            1u32,
                            "SushiSwapV2",
                        )
                    }
                    PoolType::PancakeSwapV2 => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "PoolType",
                            2u32,
                            "PancakeSwapV2",
                        )
                    }
                    PoolType::UniswapV3 => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "PoolType",
                            3u32,
                            "UniswapV3",
                        )
                    }
                    PoolType::SushiSwapV3 => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "PoolType",
                            4u32,
                            "SushiSwapV3",
                        )
                    }
                    PoolType::PancakeSwapV3 => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "PoolType",
                            5u32,
                            "PancakeSwapV3",
                        )
                    }
                    PoolType::Aerodome => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "PoolType",
                            6u32,
                            "Aerodome",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for PoolType {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 7",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "UniswapV2" => _serde::__private::Ok(__Field::__field0),
                            "SushiSwapV2" => _serde::__private::Ok(__Field::__field1),
                            "PancakeSwapV2" => _serde::__private::Ok(__Field::__field2),
                            "UniswapV3" => _serde::__private::Ok(__Field::__field3),
                            "SushiSwapV3" => _serde::__private::Ok(__Field::__field4),
                            "PancakeSwapV3" => _serde::__private::Ok(__Field::__field5),
                            "Aerodome" => _serde::__private::Ok(__Field::__field6),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"UniswapV2" => _serde::__private::Ok(__Field::__field0),
                            b"SushiSwapV2" => _serde::__private::Ok(__Field::__field1),
                            b"PancakeSwapV2" => _serde::__private::Ok(__Field::__field2),
                            b"UniswapV3" => _serde::__private::Ok(__Field::__field3),
                            b"SushiSwapV3" => _serde::__private::Ok(__Field::__field4),
                            b"PancakeSwapV3" => _serde::__private::Ok(__Field::__field5),
                            b"Aerodome" => _serde::__private::Ok(__Field::__field6),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<PoolType>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = PoolType;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum PoolType",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(PoolType::UniswapV2)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(PoolType::SushiSwapV2)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(PoolType::PancakeSwapV2)
                            }
                            (__Field::__field3, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(PoolType::UniswapV3)
                            }
                            (__Field::__field4, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(PoolType::SushiSwapV3)
                            }
                            (__Field::__field5, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(PoolType::PancakeSwapV3)
                            }
                            (__Field::__field6, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(PoolType::Aerodome)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "UniswapV2",
                    "SushiSwapV2",
                    "PancakeSwapV2",
                    "UniswapV3",
                    "SushiSwapV3",
                    "PancakeSwapV3",
                    "Aerodome",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "PoolType",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<PoolType>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    /// Represents a populated pool from any of the supported protocols
    pub enum Pool {
        UniswapV2(UniswapV2Pool),
        SushiSwapV2(UniswapV2Pool),
        PancakeSwapV2(UniswapV2Pool),
        UniswapV3(UniswapV3Pool),
        SushiSwapV3(UniswapV3Pool),
        PancakeSwapV3(UniswapV3Pool),
        Aerodome(UniswapV2Pool),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Pool {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                Pool::UniswapV2(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "UniswapV2",
                        &__self_0,
                    )
                }
                Pool::SushiSwapV2(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "SushiSwapV2",
                        &__self_0,
                    )
                }
                Pool::PancakeSwapV2(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "PancakeSwapV2",
                        &__self_0,
                    )
                }
                Pool::UniswapV3(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "UniswapV3",
                        &__self_0,
                    )
                }
                Pool::SushiSwapV3(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "SushiSwapV3",
                        &__self_0,
                    )
                }
                Pool::PancakeSwapV3(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "PancakeSwapV3",
                        &__self_0,
                    )
                }
                Pool::Aerodome(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Aerodome",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Pool {
        #[inline]
        fn clone(&self) -> Pool {
            match self {
                Pool::UniswapV2(__self_0) => {
                    Pool::UniswapV2(::core::clone::Clone::clone(__self_0))
                }
                Pool::SushiSwapV2(__self_0) => {
                    Pool::SushiSwapV2(::core::clone::Clone::clone(__self_0))
                }
                Pool::PancakeSwapV2(__self_0) => {
                    Pool::PancakeSwapV2(::core::clone::Clone::clone(__self_0))
                }
                Pool::UniswapV3(__self_0) => {
                    Pool::UniswapV3(::core::clone::Clone::clone(__self_0))
                }
                Pool::SushiSwapV3(__self_0) => {
                    Pool::SushiSwapV3(::core::clone::Clone::clone(__self_0))
                }
                Pool::PancakeSwapV3(__self_0) => {
                    Pool::PancakeSwapV3(::core::clone::Clone::clone(__self_0))
                }
                Pool::Aerodome(__self_0) => {
                    Pool::Aerodome(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Pool {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    Pool::UniswapV2(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Pool",
                            0u32,
                            "UniswapV2",
                            __field0,
                        )
                    }
                    Pool::SushiSwapV2(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Pool",
                            1u32,
                            "SushiSwapV2",
                            __field0,
                        )
                    }
                    Pool::PancakeSwapV2(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Pool",
                            2u32,
                            "PancakeSwapV2",
                            __field0,
                        )
                    }
                    Pool::UniswapV3(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Pool",
                            3u32,
                            "UniswapV3",
                            __field0,
                        )
                    }
                    Pool::SushiSwapV3(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Pool",
                            4u32,
                            "SushiSwapV3",
                            __field0,
                        )
                    }
                    Pool::PancakeSwapV3(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Pool",
                            5u32,
                            "PancakeSwapV3",
                            __field0,
                        )
                    }
                    Pool::Aerodome(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Pool",
                            6u32,
                            "Aerodome",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Pool {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 7",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "UniswapV2" => _serde::__private::Ok(__Field::__field0),
                            "SushiSwapV2" => _serde::__private::Ok(__Field::__field1),
                            "PancakeSwapV2" => _serde::__private::Ok(__Field::__field2),
                            "UniswapV3" => _serde::__private::Ok(__Field::__field3),
                            "SushiSwapV3" => _serde::__private::Ok(__Field::__field4),
                            "PancakeSwapV3" => _serde::__private::Ok(__Field::__field5),
                            "Aerodome" => _serde::__private::Ok(__Field::__field6),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"UniswapV2" => _serde::__private::Ok(__Field::__field0),
                            b"SushiSwapV2" => _serde::__private::Ok(__Field::__field1),
                            b"PancakeSwapV2" => _serde::__private::Ok(__Field::__field2),
                            b"UniswapV3" => _serde::__private::Ok(__Field::__field3),
                            b"SushiSwapV3" => _serde::__private::Ok(__Field::__field4),
                            b"PancakeSwapV3" => _serde::__private::Ok(__Field::__field5),
                            b"Aerodome" => _serde::__private::Ok(__Field::__field6),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Pool>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Pool;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "enum Pool")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        UniswapV2Pool,
                                    >(__variant),
                                    Pool::UniswapV2,
                                )
                            }
                            (__Field::__field1, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        UniswapV2Pool,
                                    >(__variant),
                                    Pool::SushiSwapV2,
                                )
                            }
                            (__Field::__field2, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        UniswapV2Pool,
                                    >(__variant),
                                    Pool::PancakeSwapV2,
                                )
                            }
                            (__Field::__field3, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        UniswapV3Pool,
                                    >(__variant),
                                    Pool::UniswapV3,
                                )
                            }
                            (__Field::__field4, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        UniswapV3Pool,
                                    >(__variant),
                                    Pool::SushiSwapV3,
                                )
                            }
                            (__Field::__field5, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        UniswapV3Pool,
                                    >(__variant),
                                    Pool::PancakeSwapV3,
                                )
                            }
                            (__Field::__field6, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        UniswapV2Pool,
                                    >(__variant),
                                    Pool::Aerodome,
                                )
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "UniswapV2",
                    "SushiSwapV2",
                    "PancakeSwapV2",
                    "UniswapV3",
                    "SushiSwapV3",
                    "PancakeSwapV3",
                    "Aerodome",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "Pool",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Pool>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    impl Pool {
        pub fn new_v2(pool_type: PoolType, pool: UniswapV2Pool) -> Self {
            match pool_type {
                PoolType::UniswapV2 => Pool::UniswapV2(pool),
                PoolType::SushiSwapV2 => Pool::SushiSwapV2(pool),
                PoolType::PancakeSwapV2 => Pool::PancakeSwapV2(pool),
                PoolType::Aerodome => Pool::Aerodome(pool),
                _ => {
                    ::core::panicking::panic_fmt(format_args!("Invalid pool type"));
                }
            }
        }
        pub fn new_v3(pool_type: PoolType, pool: UniswapV3Pool) -> Self {
            match pool_type {
                PoolType::UniswapV3 => Pool::UniswapV3(pool),
                PoolType::SushiSwapV3 => Pool::SushiSwapV3(pool),
                PoolType::PancakeSwapV3 => Pool::PancakeSwapV3(pool),
                _ => {
                    ::core::panicking::panic_fmt(format_args!("Invalid pool type"));
                }
            }
        }
    }
    impl fmt::Display for PoolType {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.write_fmt(format_args!("{0:?}", self))
        }
    }
    impl PoolInfo for Pool {
        fn address(&self) -> Address {
            match self {
                Pool::UniswapV2(pool) => pool.address,
                Pool::SushiSwapV2(pool) => pool.address,
                Pool::PancakeSwapV2(pool) => pool.address,
                Pool::UniswapV3(pool) => pool.address,
                Pool::SushiSwapV3(pool) => pool.address,
                Pool::PancakeSwapV3(pool) => pool.address,
                Pool::Aerodome(pool) => pool.address,
            }
        }
        fn token0_address(&self) -> Address {
            match self {
                Pool::UniswapV2(pool) => pool.token0,
                Pool::SushiSwapV2(pool) => pool.token0,
                Pool::PancakeSwapV2(pool) => pool.token0,
                Pool::UniswapV3(pool) => pool.token0,
                Pool::SushiSwapV3(pool) => pool.token0,
                Pool::PancakeSwapV3(pool) => pool.token0,
                Pool::Aerodome(pool) => pool.token0,
            }
        }
        fn token1_address(&self) -> Address {
            match self {
                Pool::UniswapV2(pool) => pool.token1,
                Pool::SushiSwapV2(pool) => pool.token1,
                Pool::PancakeSwapV2(pool) => pool.token1,
                Pool::UniswapV3(pool) => pool.token1,
                Pool::SushiSwapV3(pool) => pool.token1,
                Pool::PancakeSwapV3(pool) => pool.token1,
                Pool::Aerodome(pool) => pool.token1,
            }
        }
        fn token0_name(&self) -> String {
            match self {
                Pool::UniswapV2(pool) => pool.token0_name.clone(),
                Pool::SushiSwapV2(pool) => pool.token0_name.clone(),
                Pool::PancakeSwapV2(pool) => pool.token0_name.clone(),
                Pool::UniswapV3(pool) => pool.token0_name.clone(),
                Pool::SushiSwapV3(pool) => pool.token0_name.clone(),
                Pool::PancakeSwapV3(pool) => pool.token0_name.clone(),
                Pool::Aerodome(pool) => pool.token0_name.clone(),
            }
        }
        fn token1_name(&self) -> String {
            match self {
                Pool::UniswapV2(pool) => pool.token1_name.clone(),
                Pool::SushiSwapV2(pool) => pool.token1_name.clone(),
                Pool::PancakeSwapV2(pool) => pool.token1_name.clone(),
                Pool::UniswapV3(pool) => pool.token1_name.clone(),
                Pool::SushiSwapV3(pool) => pool.token1_name.clone(),
                Pool::PancakeSwapV3(pool) => pool.token1_name.clone(),
                Pool::Aerodome(pool) => pool.token1_name.clone(),
            }
        }
        fn token0_decimals(&self) -> u8 {
            match self {
                Pool::UniswapV2(pool) => pool.token0_decimals,
                Pool::SushiSwapV2(pool) => pool.token0_decimals,
                Pool::PancakeSwapV2(pool) => pool.token0_decimals,
                Pool::UniswapV3(pool) => pool.token0_decimals,
                Pool::SushiSwapV3(pool) => pool.token0_decimals,
                Pool::PancakeSwapV3(pool) => pool.token0_decimals,
                Pool::Aerodome(pool) => pool.token0_decimals,
            }
        }
        fn token1_decimals(&self) -> u8 {
            match self {
                Pool::UniswapV2(pool) => pool.token1_decimals,
                Pool::SushiSwapV2(pool) => pool.token1_decimals,
                Pool::PancakeSwapV2(pool) => pool.token1_decimals,
                Pool::UniswapV3(pool) => pool.token1_decimals,
                Pool::SushiSwapV3(pool) => pool.token1_decimals,
                Pool::PancakeSwapV3(pool) => pool.token1_decimals,
                Pool::Aerodome(pool) => pool.token1_decimals,
            }
        }
        fn pool_type(&self) -> PoolType {
            match self {
                Pool::UniswapV2(_) => PoolType::UniswapV2,
                Pool::SushiSwapV2(_) => PoolType::SushiSwapV2,
                Pool::PancakeSwapV2(_) => PoolType::PancakeSwapV2,
                Pool::UniswapV3(_) => PoolType::UniswapV3,
                Pool::SushiSwapV3(_) => PoolType::SushiSwapV3,
                Pool::PancakeSwapV3(_) => PoolType::PancakeSwapV3,
                Pool::Aerodome(_) => PoolType::Aerodome,
            }
        }
        fn reserves(&self) -> (U128, U128) {
            match self {
                Pool::UniswapV2(pool) => (pool.token0_reserves, pool.token1_reserves),
                Pool::SushiSwapV2(pool) => (pool.token0_reserves, pool.token1_reserves),
                Pool::PancakeSwapV2(pool) => (pool.token0_reserves, pool.token1_reserves),
                Pool::Aerodome(pool) => (pool.token0_reserves, pool.token1_reserves),
                Pool::UniswapV3(pool) => (pool.liquidity.into(), pool.liquidity.into()),
                Pool::SushiSwapV3(pool) => (pool.liquidity.into(), pool.liquidity.into()),
                Pool::PancakeSwapV3(pool) => {
                    (pool.liquidity.into(), pool.liquidity.into())
                }
            }
        }
    }
    /// Defines common functionality for fetching and decoding pool creation events
    ///
    /// This trait provides a unified interface for different pool types to implement
    /// their specific logic for identifying and parsing pool creation events.
    pub trait PoolFetcher: Send + Sync {
        /// Returns the type of pool this fetcher is responsible for
        fn pool_type(&self) -> PoolType;
        /// Returns the factory address for the given chain
        fn factory_address(&self, chain: Chain) -> Address;
        /// Returns the event signature for pool creation
        fn pair_created_signature(&self) -> &str;
        /// Attempts to create a `Pool` instance from a log entry
        fn log_to_address(&self, log: &Log) -> Address;
    }
    impl PoolType {
        pub async fn build_pools_from_addrs<P, T, N>(
            &self,
            provider: Arc<P>,
            addresses: Vec<Address>,
        ) -> Vec<Pool>
        where
            P: Provider<T, N> + Sync + 'static,
            T: Transport + Sync + Clone,
            N: Network,
        {
            match self {
                PoolType::UniswapV2 => {
                    v2_builder::build_pools(provider, addresses, PoolType::UniswapV2)
                        .await
                }
                PoolType::SushiSwapV2 => {
                    v2_builder::build_pools(provider, addresses, PoolType::SushiSwapV2)
                        .await
                }
                PoolType::PancakeSwapV2 => {
                    v2_builder::build_pools(provider, addresses, PoolType::PancakeSwapV2)
                        .await
                }
                PoolType::UniswapV3 => {
                    v3_builder::build_pools(provider, addresses, PoolType::UniswapV3)
                        .await
                }
                PoolType::SushiSwapV3 => {
                    v3_builder::build_pools(provider, addresses, PoolType::SushiSwapV3)
                        .await
                }
                PoolType::PancakeSwapV3 => {
                    v3_builder::build_pools(provider, addresses, PoolType::PancakeSwapV3)
                        .await
                }
                PoolType::Aerodome => {
                    v2_builder::build_pools(provider, addresses, PoolType::Aerodome)
                        .await
                }
            }
        }
    }
    /// Defines common methods that are used to access information about the pools
    pub trait PoolInfo {
        fn address(&self) -> Address;
        fn token0_address(&self) -> Address;
        fn token1_address(&self) -> Address;
        fn token0_name(&self) -> String;
        fn token1_name(&self) -> String;
        fn token0_decimals(&self) -> u8;
        fn token1_decimals(&self) -> u8;
        fn pool_type(&self) -> PoolType;
        fn reserves(&self) -> (U128, U128);
    }
}
mod util {
    use indicatif::{ProgressBar, ProgressStyle};
    /// Creates a progress bar for visual feedback during synchronization
    pub fn create_progress_bar(total_steps: u64, info: String) -> ProgressBar {
        let pb = ProgressBar::new(total_steps);
        pb.set_style(
            ProgressStyle::default_bar()
                .template(
                    &{
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "{{elapsed_precise}} {0} {{bar:40.cyan/blue}} {{pos}}/{{len}} {{msg}}",
                                info,
                            ),
                        );
                        res
                    },
                )
                .unwrap()
                .progress_chars("##-"),
        );
        pb
    }
}
